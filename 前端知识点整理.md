# CSS

## 一、CSS3新特性

- `border-radius`：圆角边框
- `box-shadow`：盒子阴影
- `background-size`：背景图片大小
- `transition`：过渡
- `transform`：转换（位移、旋转、缩放）
- `animation`：动画
- `linear-gradient`：线性渐变
- `box-sizing`：css3盒子模型

## 二、BFC

BFC(Block Formatting Context)，块级格式化上下文。是用于布局块级盒子的独立渲染区域。

> W3C官方解释：`BFC`它决定了元素如何对其内容进行定位，以及与其它元素的关系和相互作用，当涉及到可视化布局时，`Block Formatting Context`提供了一个环境，`HTML`在这个环境中按照一定的规则进行布局。

简单来说就是，`BFC`是一个完全独立的空间（布局环境），让**空间里的子元素不会影响到外面的布局**。那么怎么使用`BFC`呢，**`BFC`可以看做是一个`CSS`元素属性**。

### 1.怎样触发BFC

- HTML根元素；
- position为`absolute`或`fixed`（绝对定位、固定定位）；
- float属性不为`none`（浮动）；
- overflow不为`visible`；
- display为`inline-block`、`table-cell`、`table-caption`、`flex`。

### 2.BFC解决了什么问题

1. 使用`float`脱离文档流，导致高度塌陷

   ```html
   <style>
     .par {
       border: 5px solid #fcc;
       width: 300px;
     }
   
     .child {
       border: 5px solid #f66;
       width: 100px;
       height: 100px;
       float: left;
     }
   </style>
   <body>
     <div class="par">
       <div class="child"></div>
       <div class="child"></div>
     </div>
   </body>
   ```

   ![img](https://static.vue-js.com/ec5d4410-9511-11eb-85f6-6fac77c0c9b3.png)

   而`BFC`在计算高度时，浮动元素也会参与，所以我们可以触发`.par`元素的`BFC`，则内部浮动元素计算高度时候也会计算。

   ```css
   .par {
     overflow: hidden;
   }
   ```

   ![img](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAcEAAAC6CAYAAADWKfZeAAAERUlEQVR4nO3cMWtUWRiA4S+baBAjRLC1TWthI1hZ+IMtrCysLCzsLRURVBQDiQSGhNli6mQ3sxmz5n2e5haXc/iKgRcO587WcrlcDgAE/XXdAwDAdRFBALJEEIAsEQQgSwQByBJBALJEEIAsEQQga+fCt8vlzPHxzOnpbxoHAC5hZ2dmb29ma2u95Re+XS5nPn+e+fVrrc0BYKPu3p05OFg7go5DAcgSQQCyRBCALBEEIEsEAci6+HboRRaLmQ8fVk+AP8H29syjRzP7+9c9CZdxdjZzeLh6XrH1I3hyMvPu3czR0RWOA7BBt27NPHky8/DhdU/CZSwWq2/WNxBBx6EAZIkgAFkiCECWCAKQJYIAZK1/O/QiDx7MPH26uo4M53nzZubr18ut2d9f/bZ2dzczEzfD27erP/+Hf7CZCN6/P/P8+eo6Mpzn/fvLR/DevZlnz1ZPOM/HjyLIv+I4FIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByNrZyK4/f868ejWzvb2R7bkhfvy4/Jqjo5nXr2d2d69+Hm6OL1+uewL+EJuJ4PfvMy9ebGRr4g4PZ16+vO4pgBvCcSgAWSIIQJYIApAlggBkiSAAWevfDr1zZ+bx45nF4grHAdig7e2Zk5OZT5+uexIu4+xs5vR0I1uvH8Hbt2cODq5wFIDfYLGY+fbtuqfgf8JxKABZIghAlggCkCWCAGSJIABZW8vlcnnu2+Vy5vh4Y1dTAeA/2dmZ2dub2dpaa/nFEQSAG8xxKABZIghAlggCkCWCAGSJIABZIghAlggCkCWCAGSJIABZIghA1t9sT2c0JjdqvAAAAABJRU5ErkJggg==)

2. margin边距重叠

   ```html
   <style>
     p {
       color: #f55;
       background: #fcc;
       width: 200px;
       line-height: 100px;
       text-align: center;
       margin: 100px;
     }
   </style>
   <body>
     <p>Haha</p>
     <p>Hehe</p>
   </body>
   ```

   ![img](data:image/png;base64,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)

   两个`p`元素之间的距离为`100px`，发生了`margin`重叠（塌陷），以最大的为准，如果第一个 P 的`margin`为 80 的话，两个 P 之间的距离还是 100，**以最大的为准**。

   可以**在`p`外面包裹一层容器，并触发这个容器生成一个`BFC`，那么两个`p`就不属于同一个`BFC`**，则不会出现`margin`重叠

   ```html
   <style>
     .wrap {
       overflow: hidden; // 新的BFC
     }
     p {
       color: #f55;
       background: #fcc;
       width: 200px;
       line-height: 100px;
       text-align: center;
       margin: 100px;
     }
   </style>
   <body>
     <p>Haha</p>
     <div class="wrap">
       <p>Hehe</p>
     </div>
   </body>
   ```

   ![img](data:image/png;base64,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)

3. 两栏布局

   ```html
   <style>
     body {
       width: 300px;
       position: relative;
     }
   
     .aside {
       width: 100px;
       height: 150px;
       float: left;
       background: #f66;
     }
   
     .main {
       height: 200px;
       background: #fcc;
     }
   </style>
   <body>
     <div class="aside"></div>
     <div class="main"></div>
   </body>
   ```

   ![img](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAbIAAAEsCAYAAACmHzYvAAAFB0lEQVR4nO3YIU5kURRF0UtBEIRAgiAoFJiav2YMTIAZIJFUXutOtel88bNhLXnFy3E7eRdrrTUAEHXYewAAbCFkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpV2eX7++Zt7eZz88d5pDx9DTz8rL3CqDu9nbm4WHTE+chO51m3t9nPj42PcwPdzzO3N/vvQL4CTaGzNciAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApF2dXQ6HmdfXmbu7HeaQ8fi49wKAmflXyC4vZ47HmefnHeYAwP/xtQhAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKRdrLXWX5e1Zr6+Zk6nnSYB8GtcX8/c3Gx64jxkABDiaxGANCEDIE3IAEgTMgDShAyANCEDIE3IAEgTMgDShAyANCEDIE3IAEj7A5bFIWh0uWkWAAAAAElFTkSuQmCC)

   每个元素的左外边距与包含块的左边界相接触，因此，虽然`.aslide`为浮动元素，但是`main`的左边依然会与包含块的左边相接触。

   而**`BFC`的区域不会与浮动盒子重叠**，所以我们可以**通过触发`main`生成`BFC`**，以此适应两栏布局。

   ```css
   .main {
     overflow: hidden;
   }
   ```

   ![img](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAa0AAAEmCAYAAADRIc8sAAAExElEQVR4nO3YsWnDQACG0XPwANpBtcGtJ/K63sGdh/BlgKhQIER8yXvlccVfCD5OpznnHAAQ8HH0AADYS7QAyBAtADJEC4AM0QIgQ7QAyBAtADJEC4AM0QIg47x5er//8gxybrcxLpejVwB16zrGsuy+7qUFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQMZpzjm/nD4eB0wh5f0eY+PTAfiWdR1jWXZfP2+eXq8/NYe/6vkc4/U6egXwz/g9CECGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZJzmnPPoEQCwh5cWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZHwCQNcaPMMeeNgAAAAASUVORK5CYII=)

### 3.清除浮动的方法总结

#### 1.1 额外标签法

给需要清除浮动的元素后，额外添加一个空白标签。

- 优点：通俗易懂、书写方便；
- 缺点：添加许多无意义的标签，结构化较差。

```html
<div class="fahter">
        <div class="big">big</div>
        <div class="small">small</div>
        <div class="clear">额外标签法</div>
</div>
```

```css
.big, .small {
    float: left;
}

.clear {
	clear: both;
}
```

#### 1.2 父级添加`overflow`

通过`触发BFC`的方式实现清除浮动。

必须定义`width`或`zoom: 1`(设置或检索对象的缩放比例，设置`zoom: 1`可以在IE6下清除浮动、解决margin导致的重叠等问题)，同时不能定义`height`，使用`overflow: hiiden`时，浏览器会自动检查浮动区域的高度。

```css
.fahter{
    width: 400px;
    border: 1px solid deeppink;
    overflow: hidden;
}
```

#### 1.3 使用`after`伪元素清除浮动

额外标签法的升级版，优点是无需单独添加标签、且符合闭合浮动思想，结构语义化正确，不容易出现奇怪的bug。

IE8及非IE浏览器支持`:after`。

```html
<body>
    <div class="father clearfix">
        <div class="big">big</div>
        <div class="small">small</div>
        <!--<div class="clear">额外标签法</div>-->
    </div>
    <div class="footer"></div>
</body>
```

```css
.clearfix:after {/*伪元素是行内元素 正常浏览器清除浮动方法*/
    content: "";
    display: block;
    height: 0;
    clear:both;
    visibility: hidden;
}
.clearfix {
    *zoom: 1;/*ie6清除浮动的方式 *号只有IE6-IE7执行，其他浏览器不执行*/
}
```

#### 1.4 使用`before`和`after`**双伪元素清除浮动**

```html
<div class="father clearfix">
    <div class="big">big</div>
    <div class="small">small</div>
</div>
<div class="footer"></div>
</div>
```

```css
<style>
    .father{
        border: 1px solid black;
        *zoom: 1;
    }
    .clearfix:after,.clearfix:before{
       content: "";
       display: block;
       clear: both;
    }
    .big ,.small{
        width: 200px;
        height: 200px;
        float: left;
    }
    .big{
        background-color: red;
    }
    .small{
        background-color: blue;
    }
</style>
```

单伪元素清除法和双伪元素清除法的区别：单伪元素只能清除浮动，双伪元素既能清除浮动，又能解决**外边距塌陷问题**（垂直方向相邻的块级元素，兄弟元素之间会出现外边距合并的问题，父子元素之间会出现外边距塌陷的问题，**即给子元素设置`margin-top`，父元素会随子元素同时向下移动**）。

解决方法：

- 让父元素上外边距不相邻：
  - 给父元素设置上外框
  - 给父元素设置上内边距
  - 在html结构中父子元素之间加一个`table`标签
- 开启父元素的BFC：
  - 父元素设置`overflow: hidden`
  - 父元素设置`display: table`
- 把父元素或子元素转换为行内块

**双伪元素解决外边距塌陷问题，利用了让父子元素外边距不相邻的原理**。

## 三、盒子模型

盒子模型组成有四部分构成，分别是：`内容`、`内边距`、`外边距`、`边框`。

2种盒子模型：

#### 1.1 标准盒子模型

`box-sizing: content-box`

标准盒子模型 = content(内容) + border(边框) + padding(内边距)

![img](https://static.vue-js.com/c0e1d2e0-8f9b-11eb-85f6-6fac77c0c9b3.png)

- 盒子总宽度 = width + padding + border + margin;
- 盒子总高度 = height + padding + border + margin

#### 1.2 怪异盒子模型

`box-sizing: border-box;`

怪异盒子模型 = content(内容) （内容的宽高已经包含了padding和border）

![img](https://static.vue-js.com/cfbb3ef0-8f9b-11eb-ab90-d9ae814b240d.png)

- 盒子总宽度 = width + margin;
- 盒子总高度 = height + margin;

## 四、flexbox

### 1.flex布局

`flexbox`是一种布局模型，让网页更加简单灵活，基于Flex精确灵活控制块级盒子的布局方式，并且避免浮动布局中脱离文档流现象发生。

### 2.常见属性

- `flex-direction`：决定主轴方向（项目排列方向）

  ```css
  .container {
  	flex-direction: row | row-reverse | column | column-reverse;
  }
  ```

  - row：默认值，水平方向，起点在左端
  - row-reverse：水平方向，起点在右端
  - column：垂直方向，起点在上沿
  - column-reverse：垂直方向，起点在下沿

  ![img](https://static.vue-js.com/0c9abc70-9838-11eb-ab90-d9ae814b240d.png)

- `flex-wrap`：决定容器内项目是否可换行

  ```css
  .container {
  	flex-wrap: nowrap | wrap | wrap-reverse;
  }
  ```

  - nowrap：默认值，不换行，使元素弹性伸缩

  - wrap：换行

  - wrap-reverse：换行，第一行在下方

    ![img](https://pic1.zhimg.com/80/v2-d9886eabf578e74323329237b80e1cdc_720w.webp)

- `flex-flow`：`flex-direction`和`flex-wrap`属性的简写形式，默认值为`row nowrap`

  ```css
  .box {
  	flex-wrap: <flex-direction> | <flex-wrap>;
  }
  ```

- `justify-content`：主轴上的对齐方式

  ```css
  .box {
  	justify-content: flex-start | flex-end | center | space-between;
  }
  ```

  - flex-start：默认值，左对齐
  - flex-end：右对齐
  - center：居中
  - space-between：两端对齐，项目之间的间隔都相等
  - space-around：项目两侧间隔相等

  ![img](https://static.vue-js.com/2d5ca950-9838-11eb-85f6-6fac77c0c9b3.png)

- `align-items`：定义项目在交叉轴上的对齐方式

  ```css
  .box {
  	justify-content: flex-start | flex-end | center | space-between
  }
  ```

  - flex-start：起点对齐
  - flex-end：重点对齐
  - center：中点对齐
  - baseline：项目的第一行文字的基线对齐
  - stretch：默认值，若项目未设置高度或设为`auto`，将占满整个容器的高度

- `align-content`：**只适用于多行的flex容器**，若子项仅有一行，该属性不起作用

  ```css
  .box {
    align-content: flex-start | flex-end | center | space-between | space-around | stretch;
  }
  ```

  - flex-start：与交叉轴的起点对齐
  - flex-end：与交叉轴的终点对齐
  - center：与交叉轴的中点对齐
  - space-between：与交叉轴两端对齐，轴线之间的间隔平均分布
  - space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍
  - stretch（默认值）：轴线占满整个交叉轴

  ![img](https://static.vue-js.com/39bcb0f0-9838-11eb-ab90-d9ae814b240d.png)

### 3.其他容器成员属性

- `order`：定义项目的排列顺序。**数字越小，排列越靠前，默认为0**。

  ```css
  .item {
  	order: <integer>;
  }
  ```

- `flex-grow`：定义**项目的放大比例**（容器宽度>元素总宽度时如何伸展）。默认为0，即如果存在剩余空间，也不放大。

  ```css
  .item {
  	flex-grow: <number>
  }
  ```

  ![img](https://static.vue-js.com/48c8c5c0-9838-11eb-ab90-d9ae814b240d.png)

  ![img](https://static.vue-js.com/5b822b20-9838-11eb-ab90-d9ae814b240d.png)

  注意：若弹性容器的宽度正好等于元素宽度总和，无多余宽度，此时无论`flex-grow`是什么值都不会生效。

- `flex-shrink`：定义了项目的**缩小比例**（容器宽度<元素总宽度时如何收缩）。默认为 1，即如果空间不足，该项目将缩小。

  ```css
  .item {
    flex-shrink: <number>; /* default 1 */
  }
  ```

- `flex-basis`：设置的是元素在主轴上的初始尺寸，所谓的初始尺寸就是元素在`flex-grow`和`flex-shrink`生效前的尺寸。默认值为`auto`，即项目的本来大小；如设置了`width`则元素尺寸由`width/height`决定（主轴方向），没有设置则由内容决定；**当设置为 0 的是，会根据内容撑开**；也可以设为跟`width`或`height`属性一样的值（比如 350px），则项目将占据固定空间。

  ```css
  .item {
    flex-basis: <length> | auto; /* default auto */
  }
  ```

- `flex`：`flex`属性是`flex-grow`, `flex-shrink` 和 `flex-basis`的简写，默认值为`0 1 auto`。

  ```css
  .item {
    flex: none | [ < 'flex-grow' > < 'flex-shrink' >? || < 'flex-basis' > ];
  }
  ```

  - flex: 1 = flex: 1 1 **0%**
  - flex: 2 = flex: 2 1 0%
  - flex: auto = flex: 1 1 **auto**
  - flex: none = flex: 0 0 auto，常用于固定尺寸不伸缩

  > `flex:1`和`flex:auto`的区别，可以归结于`flex-basis:0`和`flex-basis:auto`的区别：
  >
  > 当设置为0时（绝对弹性元素），此时相当于告诉`flex-grow`和`flex-shrink`在伸缩的时候不需要考虑我的尺寸
  >
  > 当设置为`auto`时（相对弹性元素），此时则需要在伸缩时将元素尺寸纳入考虑

  注意：建议优先使用这个属性，而不是单独写三个分离的属性。

- `align-self`：允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性。默认值为`auto`，表示继承父元素的`align-items`属性，如果没有父元素，则等同于`stretch`。

  ```css
  .item {
    align-self: auto | flex-start | flex-end | center | baseline | stretch;
  }
  ```

  ![img](https://static.vue-js.com/6f8304a0-9838-11eb-85f6-6fac77c0c9b3.png)

## 五、CSS绘制三角形

### 1.原理

边框实际上并不是一条直线，如果我们将四条边设置为不同的颜色，并逐渐将边框放大，可以看到每条边框都是一个梯形：

![img](https://static.vue-js.com/78d4bd90-a27a-11eb-85f6-6fac77c0c9b3.png)

当分别取消边框的时候，会发生下面几种情况：

- 取消一条边的时候，与这条边相接触的部分会变成直线；
- 当仅有邻边时，两个边会变成对分的三角形；
- 当保留边没有其他接触时，极限情况下所有内容都会消失。

![img](https://static.vue-js.com/84586ef0-a27a-11eb-85f6-6fac77c0c9b3.png)

### 2.实心三角形

使用CSS绘制三角形的原理是利用**盒子边框**完成的，其步骤如下：

1. 设置一个盒子；

2. 设置四周不同颜色的边框；

   ![img](https://static.vue-js.com/e3f244e0-a279-11eb-ab90-d9ae814b240d.png)

3. 为边框设置粗细；

   ![img](https://static.vue-js.com/ee0b42b0-a279-11eb-ab90-d9ae814b240d.png)

4. 将`盒子宽高设置为0`，`仅保留边框`；

   ![img](https://static.vue-js.com/2afaa030-a27a-11eb-85f6-6fac77c0c9b3.png)

5. 得到四个三角形，选择其中一个，`将其他三个三角形设置为透明`色。

```css
div {
  width: 0px;
  height: 0px;
  border-top: 20px solid transparent;
  border-bottom: 20px solid red;
  border-left: 20px solid transparent;
  border-right: 20px solid transparent;
}
```

### 3.空心三角形

```css
.border {
	width: 0;
	height: 0;
	border-style: solid;
	border-width: 0 50px 50px;
	border-color: transparent transparent #d9534f;
	position: relative;
}
```

利用伪类新建一个小一点的三角形定位到大的三角形上，实现空心三角形的效果。

```css
.border:after {
	content: '';
	border-style: solid;
	border-width: 0 40px 40px;
    border-color: transparent transparent #96ceb4;
    position: absolute;
    top: 0;
    left: 0;
}
```

![i](https://static.vue-js.com/59f4d720-a27a-11eb-85f6-6fac77c0c9b3.png)

最终代码如下：

```css
.border {
	width: 0;
	height: 0;
	border-style: solid;
	border-width: 0 50px 50px;
	border-color: transparent transparent #d9534f;
	position: relative;
}

.border:after {
	content: '';
	border-style: solid;
	border-width: 0 40px 40px;
	border-color: transparent transparent #fff;
	position: absolute;
	top: 6px;
	left: -40px;
}
```

## 六、CSS选择器

```html
<div id="box">
  <div class="one">
    <p class="one_1"></p>
    <p class="one_1"></p>
  </div>
  <div class="two"></div>
  <div class="two"></div>
  <div class="two"></div>
</div>
```

### 1.选择器

- id选择器：`#box`，选择id为box的元素

- 类选择器：`.box`，选择类名为box的所有元素

- 标签选择器：`div`，选择标签为div的所有元素

- 后代选择器：`#box div`，选择id为box的元素内部所有div元素

- 子选择器：`.one>.one_1`，选择父元素类名为one的所有类名为one_1的元素

- 相邻兄弟选择器：`.one+.two`，选择紧邻类名为one的元素之后同级的类名为two的元素

  ```html
  <div id="box">
      <div class="two">0</div>
      <div class="one">
        <p class="one_1"></p>
        <p class="one_1"></p>
      </div>
      <div class="two">1</div>
      <div class="two">2</div>
      <div class="two">3</div>
      <div class="one"></div>
    </div>
  ```

  ```css
  .one+.two {
      width: 100px;
      height: 100px;
      background: red;
  }
  ```

  ![image-20231128153638960](https://gitee.com/v876774538/my-img/raw/master/image-20231128153638960.png)

- 群组选择器：`div, p`，选择div、p的所有元素

- 交集选择器：`.one .one_1`，选择同时符合.one和.one_1条件的元素

- 伪类选择器：

  - `:link`：选择未被访问的链接
  - `:visited`：选择已被访问的链接
  - `:hover`：鼠标指针悬停在上面的元素
  - `:active`：选择活动链接（当你点击一个链接时，它变成活动链接。为了产生预期的效果，在css定义中，`:active`必须位于`:hover`之后）
  - `:focus`：选择具有焦点的
  - `:first-child`：父元素的首个子元素

- 伪元素选择器：

  - `:first-letter`：用来指定元素第一个字母的样式

  - `:first-line`：用来指定元素第一行

    ```html
    <div id="box">
        <p>
            天上白玉京，十二楼五城。<br>
            仙人抚我顶，结发受长生。<br>
            误逐世间乐，颇穷理乱情。<br>
            九十六圣君，浮云挂空名。<br>
            天地赌一掷，未能忘战争。<br>
            试涉霸王略，将期轩冕荣。<br>
            时命乃大谬， 弃之海上行。<br>
            学剑翻自哂， 为文竟何成。<br>
            剑非万人敌， 文窃四海声。<br>
            儿戏不足道， 五噫出西京。<br>
        </p>
    </div>
    ```

    ```css
    p {
        color: #333;
    }
    
    p:first-letter {
        color: red;
    }
    
    p:first-line {
        color: blue;
    }
    ```

    ![image-20231128155201051](https://gitee.com/v876774538/my-img/raw/master/image-20231128155201051.png)

  - `:before`：选择器在被选元素的内容前面插入内容

  - `:after`：选择器在被选元素的内容后面插入内容

- 属性选择器

  - `[attribute]`：选择带有attribute属性的元素

    ```css
    a[target] {
    	background: yellow;
    }
    ```

  - `[attribute=value]`：选择所有使用attribute=value的元素

    ```css
    a[target="_blank"] {
    	background: yellow;
    }
    ```

  - `[attribute~=value]`：选择attribute属性包含value的元素

    ```css
    [title~="flower"] {
      border: 5px solid yellow;
    }
    ```

    上面的例子会匹配以下属性的元素：title="flower"、title="summer flower" 以及 title="flower new"，**但不匹配：title="my-flower" 或 title="flowers"。**

    ```html
    <div id="box">
        <div class="flower">flower</div>
        <div class="flowers">flowers</div>
        <div class="summer flower">summer flower</div>
        <div class="my-flower">my-flower</div>
    </div>
    ```

    ```css
    div {
        width: 100px;
        height: 100px;
        border: 1px solid #333;
    }
    
    [class~="flower"] {
        background: red;
    }
    ```

    ![image-20231128160721193](https://gitee.com/v876774538/my-img/raw/master/image-20231128160721193.png)

  - `[attribute|=value]`：选择attribute属性以value开头的元素

    ```css
    [class|="top"] {
      background: yellow;
    }
    ```

    下例选取 class 属性以 "top" 开头的所有元素：

    **提示：**值必须是**完整或单独的单词**，比如 class="top" 或者后跟连字符的，比如 class="top-text"。

    ```html
    <div id="box">
        <div class="flower">flower</div>
        <div class="flowers">flowers</div>
        <div class="summer flower">summer flower</div>
        <div class="my-flower">my-flower</div>
        <div class="flower-my">flower-my</div>
    </div>
    ```

    ```css
    div {
        width: 100px;
        height: 100px;
        border: 1px solid #333;
    }
    
    [class|="flower"] {
        background: red;
    }
    ```

    ![image-20231128161011075](https://gitee.com/v876774538/my-img/raw/master/image-20231128161011075.png)

CSS3新增选择器：

- 全部兄弟选择器（层次选择器）：`.one~.two`，选择**所有**符合条件的兄弟元素

  ```css
  .one~.two {
      width: 100px;
      height: 100px;
      background: red;
  }
  ```

  ![image-20231128155615800](https://gitee.com/v876774538/my-img/raw/master/image-20231128155615800.png)

- 属性选择器：

  - `[attribute*=value]`：选择attribute属性值包含value的所有元素

    **提示：**值不必是完整单词！

  - `[attribute^=value]`：选择attribute属性开头为value的所有元素

    **提示：**值不必是完整单词！

  - `[attribute$=value]`：选择attribute属性结尾为value的所有元素

    **提示：**值不必是完整单词！

  > 应用场景：**为不带`class`或`id`的表单设置样式**。

  ```css
  input[type="text"] {
    width: 150px;
    display: block;
    margin-bottom: 10px;
    background-color: yellow;
  }
  
  input[type="button"] {
    width: 120px;
    margin-left: 35px;
    display: block;
  }
  ```

### 2.优先级

> 内联 > ID 选择器 > 类选择器 > 标签选择器

**计算规则**：具体的计算层⾯，优先级是由`A、B、C、D`的值来决定的。

- 如果`存在内联样式`，那么`A=1`，否则A=0；
- B的值等于`ID选择器出现的次数`；
- C的值等于`类选择器`、`属性选择器`和`伪类`出现的次数；
- D的值等于`标签选择器`和`伪元素`出现的总次数

举例：

```css
#nav-global > ul > li > a.nav-link;
```

- A=0
- B=1
- C=1
- D=3

推出其优先级值为：(0, 1, 1, 3)。

**比较规则**：

- 从左往右依次比较，较大者优先级更高；
- 若相等，则继续右移一位进行比较；
- 若4位全部相等，则后者覆盖前者

**提示**：若外部样式需要覆盖内联样式，需要使用`!important`。

### 3.CSS继承属性

在CSS中，继承指的是给父元素设置一些属性，后代元素会自动拥有这些属性。

**继承属性**有：

- 字体系列属性

  ```css
  font: 组合字体 
  font-family: 规定元素的字体系列
  font-weight: 设置字体的粗细
  font-size: 设置字体的尺寸
  font-style: 定义字体的风格
  font-variant: 偏大或偏小的字体
  ```

  **提示**：

  - a 标签的字体颜色不能被继承
  - h1-h6 标签字体的大下也是不能被继承的

- 文本系列属性

  ```css
  text-indent：文本缩进
  text-align：文本水平对刘
  line-height：行高
  word-spacing：增加或减少单词间的空白
  letter-spacing：增加或减少字符间的空白
  text-transform：控制文本大小写
  direction：规定文本的书写方向
  color：文本颜色
  ```

- 元素可见性

  ```css
  visibility
  ```

- 表格布局属性

  ```css
  caption-side：定位表格标题位置
  border-collapse：合并表格边框
  border-spacing：设置相邻单元格的边框间的距离
  empty-cells：单元格的边框的出现与消失
  table-layout：表格的宽度由什么决定
  ```

- 列表属性

  ```css
  list-style-type：文字前面的小点点样式
  list-style-position：小点点位置
  list-style：以上的属性可通过这属性集合
  ```

- 引用

  ```css
  quotes：设置嵌套引用的引号类型
  ```

- 光标属性

  ```css
  cursor：箭头可以变成需要的形状
  ```

**无继承的属性**：

- 元素显示类型/子元素布局类型

  ```css
  display
  ```

- 文本属性

  ```css
  vertical-align: 垂直居中
  text-decoration: 水平居中
  ```

- 盒子模型的属性

  ```css
  width: 宽度
  height: 高度
  padding: 内边距
  margin: 外边距
  border: 边框
  ```

- 背景属性

  ```css
  background-image: 背景图片
  background-color: 背景颜色
  background-position: 背景图像起始位置
  ```

- 定位属性

  ```css
  float: 浮动
  clear: 清除浮动
  position: 定位
  ```

- 生成内容属性：content、counter-reset、counter-increment

- 轮廓样式属性：outline-style、outline-width、outline-color、outline

- 页面样式属性：size、page-break-before、page-break-after

## 七、em/px/rem/vh/vw区别

在CSS单位中，可以分为**相对长度单位**和**绝对长度单位**：

|   CSS单位    |                                        |
| :----------: | -------------------------------------- |
| 相对长度单位 | em、ex、ch、rem、vw、vh、vmin、vmax、% |
| 绝对长度单位 | cm、mm、in、px、pt、pc                 |

### 1.px

#### 1.1 说明

`px`表示像素，所谓像素就是呈现在我们显示器上的一个个小点，这这个设备中，每个像素点都是大小等同的，与其他属性无关，所以像素是绝对长度单位。

### 2.em

#### 2.1 说明

`em`是相对长度单位，相对于当前对象内文本的字体尺寸。若当前对象内文本的字体尺寸未被设置，则采用相对于浏览器默认字体尺寸（`1em = 16px`）。

> 为了简化`font-size`的换算，我们需要在CSS中的`body`选择器中声明`font-size: 62.5%`，使em的值变为`1em = 16px * 62.5% = 10px`。即12px = 1.2em，16px = 1.6em。

#### 2.2 特点

- em的值并不是固定的
- em会**继承父级元素的字体大小**
- em是相对长度单位，若当前对象内文本的字体尺寸未被设置，则采用相对于浏览器默认字体尺寸
- **任意浏览器的默认字体大小都是16px**

#### 2.3 举例

```html
<div class="big">
	左边距14px
	<div class="small">左边距12px</div>
</div>
```

```css
html {
	font-size: 10px;  
} /*  公式16px*62.5%=10px  */
.big {
	margin-left: 1.4rem
}
.small {
	margin-left: 1.2rem;
}
```

![image-20231129143918619](https://gitee.com/v876774538/my-img/raw/master/image-20231129143918619.png)

### 3.rem

#### 3.1 说明

`rem`，CSS3新增的相对长度单位，相对于`HTML根元素`的`font-size`的值。

> 同理，若想要简化`font-size`转化，我们可以在根元素css中加入`font-size: 62.5%`。

```css
html {
	font-size: 62.5%;
} /*  公式16px*62.5%=10px  */
```

#### 3.2 特点

- rem单位集相对大小和绝对大小的优点于一身
- 与em不同之处就在于rem总是相对于根元素，而不需要像em一样使用级联的方式来计算尺寸

### 4.vh、vw

#### 4.1 说明

`vw`，即根据窗口的**宽度**，分成100等份：100vw表示满宽，50vw表示一半宽度。

vw始终针对窗口的宽度，同理，`vh`为窗口的**高度**。

此处的窗口分为几种情况：

- 桌面端：指浏览器的可视区域。即`window.innerWidth/window.innerHeight`大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。

  ![图片.png](http://ww.qdxiaochuan.com/zb_users/upload/2021/05/202105071620362786893461.png)

- 移动端：布局视口

  ![图片.png](http://ww.qdxiaochuan.com/zb_users/upload/2021/05/202105071620362817755517.png)

#### 4.2 vh/vw和%的区别

- vh与vw都是根据窗口大小比例适应显示，**根据浏览器窗口来进行定位的**

  ```css
  1vw = 窗口宽度的1%
  1vh = 窗口高度的1%
  ```

- %则根据**父元素**进行定位

  - 对于普通定位元素，%根据父元素进行定位
  - 对于`posiiton: absolute`的元素，相对于已定位的父元素
  - 对于`position: fixed`的元素，相对于ViewPort（可视窗口）

## 八、响应式设计

### 1.介绍

响应式网站设计（Responsive Web Design）是一种网络页面设计布局，页面的设计与开发应当根据用户行为以及设备环境（系统平台、屏幕尺寸等进行响应的响应和调整）。

响应式网站常见特点：

- 同时适配PC、平板和手机端等
- 标签导航在接近手持终端设备时改变为经典的抽屉式导航
- 网站的布局会根据视口来调整模块的大小和位置

![img](https://static.vue-js.com/ae68be30-9dba-11eb-85f6-6fac77c0c9b3.png)

### 2.实现方法

响应式设计的基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理，为了处理移动端，页面头部必须有`meta`声明`viewport`：

```html
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no”>
```

属性对应如下：

- `width=device-width`：自适应手机屏幕的尺寸宽度
- `maximun-scale`：缩放比例的最大值
- `inital-scale`：缩放的初始化
- `user-scalable`：是否允许用户缩放

#### 2.1 媒体查询

使用`@media`查询，可以针对不同的媒体类型定义不同的样式，如：

```css
@media screen and (max-width: 1920px) {
	...
}
```

```css
@media screen and (min-width: 375px) and (max-width: 600px) {
	body {
		font-size: 18px;
	}
}
```

#### 2.2 百分比

比如当浏览器的宽度或高度发生变化时，通过百分比单位，我们可以使浏览器中的组件的宽高随浏览器的变化而变化，从而实现响应式的效果。

`height`、`width`属性的百分比依托于父元素的宽高，但其他盒子属性则不完全依赖父元素：

- 子元素的`top`/`left`和`bottom`/`right`如果设置百分比，则相对于直接**非static定位的父元素**的高度/宽度

- 子元素的`padding`如果设置百分比，不论垂直方向或是水平方向，都**相对于直接父元素的width**，而与父元素的height无关

- 子元素的`margin`如果设置百分比，不论垂直方向还是水平方向，也是**相对于直接父元素的width**

- `border-radius`相对于自身的**宽高**

  ```css
  border-radius: 50%;	// 圆
  ```

  **补充**

  border-radius设置原则：

  - 若为一个值，则用其为半径构建圆形，这个圆与边框的交集形成圆角的效果；

  - 若为两个值，则这两个值分别为半长轴、半短轴构建椭圆，这个椭圆与边框的交集形成圆角效果

    ![img](https://img-blog.csdnimg.cn/20210309165959853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDEzNzU3NQ==,size_16,color_FFFFFF,t_70)

  举例：

  - 盒子宽高都为100px，设置`border-top-left-radius: 50%`，相当于用50px作为半径构建圆形

    ![img](https://img-blog.csdnimg.cn/20210309171931507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDEzNzU3NQ==,size_16,color_FFFFFF,t_70)

  - 盒子宽200px，高100px，设置`border-top-left-radius: 50%`，相当于用100px作为半长轴，50px作为半短轴构建圆形

    ![img](https://img-blog.csdnimg.cn/2021030917181783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDEzNzU3NQ==,size_16,color_FFFFFF,t_70)

  - 盒子宽高都为100px，设置`border-top-left-radius: 10% 50%`，相当于用10px作为半短轴，50px作为半长轴构建圆形

    ![img](https://img-blog.csdnimg.cn/20210309172342705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDEzNzU3NQ==,size_16,color_FFFFFF,t_70)

  - 盒子宽200px，高100px，设置`border-top-left-radius: 10% 50%`，相当于用20px作为半短轴，50px作为半长轴构建圆形

    ![img](https://img-blog.csdnimg.cn/20210309172437772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDEzNzU3NQ==,size_16,color_FFFFFF,t_70)

#### 2.3 vw/vh

`vw`表示相对于视图窗口的宽度，`vh`表示相对于视图窗口的高度。

任意层级元素，在使用vw为单位的情况下，1vw都等于**视图宽度**的百分之一。

#### 2.4 rem

> 前文提到，`rem`是相对于根元素`html`的`font-size`属性改变尺寸大小的单位，默认情况下浏览器字体大小为16px，此时`1rem = 16px`。

可以利用媒体查询的方法，针对不同设备分辨率改变根元素`font-size`的值，如：

```css
@media screen and (max-width: 414px) {
	html {
		font-size: 18px;
	}
}

@media screen and (max-width: 375px) {
	html {
		font-size: 16px;
	}
}

@media screen and (max-width: 320px) {
	html {
		font-size: 12px;
	}
}
```

为了更准确地监听设备可视窗口的变化，可以采用`js`的方法动态地修改`font-size`的值，以达到响应式的目的：

```js
// 动态为根元素设置字体大小
function init() {
	// 获取屏幕宽度
	var width = document.documentElement.clientWidth
	// 设置根元素字体大小
	document.documentElement.style.fontSize = width / 10 + 'px'
}

// 首次加载应用，设置
init()
// 监听手机旋转的事件和时机，重新设置
window.addventListener('orientationchange', init)
// 监听手机窗口变化，重新设置
window.addEventListener('resize', init)
```

无论设备可视窗口如何变化，始终设置`rem`为`width`的 1/10，实现了百分比布局。

**SANTIME官网**：http://syy333.dynv6.net:20080/syy/santime.git

```html
<script>
    (function (win) {
        var tid

        function refreshRem() {
            let designSize = 1920 // 设计图尺寸
            let html = document.documentElement
            let wW = html.clientWidth // 窗口宽度
            let rem = (wW * 100) / designSize
            document.documentElement.style.fontSize = rem + 'px'
        }

        win.addEventListener(
            'resize',
            function () {
                clearTimeout(tid)
                tid = setTimeout(refreshRem, 300)
            },
            false
        )
        win.addEventListener(
            'pageshow',
            function (e) {
                if (e.persisted) {
                    clearTimeout(tid)
                    tid = setTimeout(refreshRem, 300)
                }
            },
            false
        )

        refreshRem()
    })(window)

    $(function () {
        $('#foot').load('foot.html')
    })
</script>
```

#### 2.5 scale

页面缩放，最好用于固定宽高比的Web应用，如大屏或者固定窗口业务应用。

**三益友官网**：http://syy333.dynv6.net:20080/zhangzl/syy.git master分支

```js
window.onload = function() {
  setScale();
}
window.onresize = function () {
  setScale();
};
function setScale() {
  // 设计稿：1920 * 1080
  // 1.设计稿尺寸
  let targetWidth = 1920;
  // 2.拿到当前设备（浏览器）的宽度
  // document.documentElement  获取html的宽度
  let currentWidth = document.documentElement.clientWidth || document.body.clientWidth;
  // 3.计算缩放比率(屏幕过宽，根据高度计算缩放比例)
  let scaleRatio = currentWidth / targetWidth;
  // 4.开始缩放网页
  // 宽度>1920 顶部中心缩放
  if (currentWidth > targetWidth) {
    document.body.style = `transform: scale(${scaleRatio}); transform-origin: top center;`;
  }
  // 宽度<1920 顶部靠左缩放
  else {
    document.body.style = `transform: scale(${scaleRatio}); transform-origin: top left;`;
  }
}
```

注意：`transform`会导致`position:fixed`失效，故只能使用`position:absolute`，采用将滚动距离赋值给绝对定位的元素的方法。

```js
handleScroll() {
  var scrollTop =
    window.pageYOffset ||
    document.documentElement.scrollTop ||
    document.body.scrollTop;
  // let top = this.selectIndex == 0 ? 670 : 502;
  let top = document.documentElement.querySelector(".header").offsetHeight + document.documentElement.querySelector(".header").offsetTop;
  var headerElement = document.documentElement.querySelector(".header1");
  if (scrollTop >= top) {
    if (!this.show) {
      this.show = true;
      this.show1 = true;
    }
    headerElement.style = `top: ${scrollTop / this.scaleRatio}px`;
  } else {
    if (this.show) {
      this.show1 = false;
      setTimeout(() => {
        this.show = false;
      }, 400);
    }
  }
},
```

参考文献：[前端大屏适配几种方案_前端大屏适配方案_狮子歌歌_丶的博客-CSDN博客](https://blog.csdn.net/Liushiliu104/article/details/129372083?spm=1001.2100.3001.7377&utm_medium=distribute.pc_feed_blog_category.none-task-blog-classify_tag-8-129372083-null-null.nonecase&depth_1-utm_source=distribute.pc_feed_blog_category.none-task-blog-classify_tag-8-129372083-null-null.nonecase)

## 九、常见布局实现

### 1.两栏布局

#### 1.1 效果

双栏布局十分常见，往往是以一个**定宽栏**和一个**自适应的栏**并排展示存在。适用于有明显**主次关系**的网页。

![img](https://static.vue-js.com/fcb8ac50-976e-11eb-85f6-6fac77c0c9b3.png)



#### 1.2 实现思路

1. float浮动

   - 使用`float`左浮动左边栏
   - 右边模块用`margin-left`撑出内容块做内容展示
   - 为父级元素添加BFC，防止下方元素飞到上方内容

   ```html
   <!DOCTYPE html>
   <html lang="en">
   
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
   </head>
   
   <body>
       <div class="index">
           <div class="nav">
               <div class="li">1</div>
               <div class="li">2</div>
               <div class="li">3</div>
               <div class="li">4</div>
               <div class="li">5</div>
           </div>
           <div class="main">
               <div class="title">Title</div>
               <div class="box"></div>
   
           </div>
       </div>
   </body>
   <style>
       body {
           margin: 0;
       }
       
       .clearfix:after,
       .clearfix:before {
           content: "";
           display: block;
           clear: both;
       }
   
       .index {
           /* 父元素添加BFC */
           overflow: hidden;
           /* background: lightslategray; */
       }
   
       .nav {
           width: 21%;
           height: 100%;
           min-height: 100vh;
           float: left;
           background: lightblue;
       }
   
       .nav .li {
           height: 30px;
           line-height: 30px;
           padding: 0 15px;
           box-sizing: border-box;
       }
   
       .nav .li:first-child {
           background: lightcoral;
       }
   
       .main {
           margin-left: 21%;
           padding: 20px;
           box-sizing: border-box;
       }
   
       .main .box {
           width: 200px;
           height: 100px;
           background: red;
       }
   </style>
   
   </html>
   ```

   ![image-20231130101955341](https://gitee.com/v876774538/my-img/raw/master/image-20231130101955341.png)

2. flex布局

   ```html
   <!DOCTYPE html>
   <html lang="en">
   
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
   </head>
   
   <body>
       <div class="index">
           <div class="nav">
               <div class="li">1</div>
               <div class="li">2</div>
               <div class="li">3</div>
               <div class="li">4</div>
               <div class="li">5</div>
           </div>
           <div class="main">
               <div class="title">Title</div>
               <div class="box"></div>
   
           </div>
       </div>
   </body>
   <style>
       body {
           margin: 0;
       }
   
       .index {
           /* flex弹性布局 */
           display: flex;
       }
   
       .nav {
           width: 21%;
           height: 100%;
           min-height: 100vh;
           float: left;
           background: lightblue;
       }
   
       .nav .li {
           height: 30px;
           line-height: 30px;
           padding: 0 15px;
           box-sizing: border-box;
       }
   
       .nav .li:first-child {
           background: lightcoral;
       }
   
       .main {
           padding: 20px;
           box-sizing: border-box;
       }
   
       .main .box {
           width: 200px;
           height: 100px;
           background: red;
       }
   </style>
   
   </html>
   ```

### 2.三栏布局

#### 2.1 效果

![img](https://static.vue-js.com/0bf016e0-976f-11eb-ab90-d9ae814b240d.png)

#### 2.2 实现思路

1. 两边float，中间margin

   ```html
   <!DOCTYPE html>
   <html lang="en">
   
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
   </head>
   
   <body>
       <div class="wrap">
           <div class="left">左侧</div>
           <div class="right">右侧</div>
           <div class="center">
               中间
               <div class="box"></div>
           </div>
       </div>
   </body>
   <style>
       body {
           margin: 0;
       }
   
       .wrap {
           overflow: hidden;
       }
   
       .left, .right {
           width: 20%;
           height: 100%;
           min-height: 100vh;
       }
       
       .left {
           float: left;
           background: lightblue;
       }
   
       .right {
           float: right;
           background: lightcoral;
       }
   
       .center {
           margin: 0 20%;
           padding: 20px;
           box-sizing: border-box;
       }
   
       .center .box {
           width: 200px;
           height: 200px;
           background: red;
       }
   </style>
   
   </html>
   ```

   ![image-20231130103127406](https://gitee.com/v876774538/my-img/raw/master/image-20231130103127406.png)

2. 两边absolute，中间margin

   ```css
   body {
       margin: 0;
   }
   
   .wrap {
       position: relative;
   }
   
   .left, .right {
       width: 20%;
       height: 100%;
       min-height: 100vh;
   }
   
   .left {
       position: absolute;
       top: 0;
       left: 0;
       background: lightblue;
   }
   
   .right {
       position: absolute;
       top: 0;
       right: 0;
       background: lightcoral;
   }
   
   .center {
       margin: 0 20%;
       padding: 20px;
       box-sizing: border-box;
   }
   
   .center .box {
       width: 200px;
       height: 200px;
       background: red;
   }
   ```

3. 两边使用float和负margin

   ```html
   <!DOCTYPE html>
   <html lang="en">
   
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
   </head>
   
   <body>
       <div class="main-wrapper">
           <div class="main">中间自适应</div>
       </div>
       <div class="left">左边固定宽度</div>
       <div class="right">右边固定宽度</div>
   </body>
   <style>
       .left,
       .right,
       .main {
           height: 200px;
           line-height: 200px;
           text-align: center;
       }
   
       .main-wrapper {
           float: left;
           width: 100%;
       }
   
       .main {
           margin: 0 110px;
           background: black;
           color: white;
       }
   
       .left,
       .right {
           float: left;
           width: 100px;
           margin-left: -100%;
           background: green;
       }
   
       .right {
           margin-left: -100px;
           /* 同自身宽度 */
       }
   </style>
   
   </html>
   ```

   ![image-20231130110912093](https://gitee.com/v876774538/my-img/raw/master/image-20231130110912093.png)

4. display: table

   `<table>`标签用于展示行列数据，不适合用于布局。但可以使用`display: table`来实现布局的效果。

   ```html
   <!DOCTYPE html>
   <html lang="en">
   
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
   </head>
   
   <body>
       <div class="container">
           <div class="left">左边固定宽度</div>
           <div class="center">中间自适应</div>
           <div class="right">右边固定宽度</div>
       </div>
   </body>
   <style>
       body {
           margin: 0;
       }
   
       .container {
           /* 设置为表格 */
           display: table;
           /* 列宽由自身宽度决定 无需自动计算 */
           table-layout: fixed;
           width: 100%;
           height: 100%;
           min-height: 100vh;
       }
   
       .left, .right, .center {
           /* 设置为单元格 */
           display: table-cell;
       }
   
       .left, .right {
           width: 20%;
           height: 100%;
           min-height: 100vh;
       }
   
       .left {
           background: lightblue;
       }
   
       .right {
           background: lightcoral;
       }
   </style>
   
   </html>
   ```

   ![image-20231130111621587](https://gitee.com/v876774538/my-img/raw/master/image-20231130111621587.png)

5. flex实现

   ```html
   <!DOCTYPE html>
   <html lang="en">
   
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
   </head>
   
   <body>
       <div class="container">
           <div class="left">左边固定宽度</div>
           <div class="center">中间自适应</div>
           <div class="right">右边固定宽度</div>
       </div>
   </body>
   <style>
       body {
           margin: 0;
       }
   
       .container {
           width: 100%;
           height: 100%;
           min-height: 100vh;
           display: flex;
       }
   
       .left, .right, .center {
       }
   
       .left, .right {
           width: 20%;
           height: 100%;
           min-height: 100vh;
       }
   
       .left {
           background: lightblue;
       }
   
       .right {
           background: lightcoral;
       }
   
       .center {
           width: 100%;
           /* flex: 1; */
           background: lightseagreen;
       }
   </style>
   
   </html>
   ```

   - 仅需将容器设置为`display:flex;`，
   - 盒内元素两端对其，将中间元素设置为`100%`宽度，或者设为`flex:1`，即可填充空白
   - 盒内元素的高度撑开容器的高度

   优点：

   - 结构简单直观
   - 可以结合 flex 的其他功能实现更多效果，例如使用 order 属性调整显示顺序，让主体内容优先加载，但展示在中间

6. grid网格布局

   ```html
   <!DOCTYPE html>
   <html lang="en">
   
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
   </head>
   
   <body>
       <div class="container">
           <div class="left">左边固定宽度</div>
           <div class="center">中间自适应</div>
           <div class="right">右边固定宽度</div>
       </div>
   </body>
   <style>
       body {
           margin: 0;
       }
   
       .container {
           width: 100%;
           display: grid;
           grid-template-columns: 300px auto 300px;
       }
   
       .left, .right, .center {
           height: 100px;
       }
   
       .left {
           background: lightblue;
       }
   
       .right {
           background: lightcoral;
       }
   
       .center {
           width: 100%;
           /* flex: 1; */
           background: lightseagreen;
       }
   </style>
   
   </html>
   ```

   ![image-20231219191135377](https://gitee.com/v876774538/my-img/raw/master/image-20231219191135377.png)

   **grid布局的使用方法**：

   - 启用网格布局：`display: grid`

     块级容器（宽度撑满整行时）`display: grid;`

     行内容器（宽度随内容自适应时）`display: inline-grid;`

     > 注意：使用网格布局后，项目的`float`、`display: inline-block`、`display: table-cell`、`vertical-align`和`column-*`等设置都将失效。

   - 划分列：`grid-template-columns`

     - 将容器等分为3列，每列宽度为100px

       ```css
       grid-template-columns: 100px 100px 100px;
       ```

     - 将容器等分为3列，每列宽度为总宽度/3

       ```css
       grid-template-columns: 33.33% 33.33% 33.33%;
       ```

     - 将容器划分为3列，第一列的宽度:第二列的宽度 = 1:2

       ```css
       grid-template-columns: 1fr 2fr;
       ```

     - `fr`是fraction的缩写，意为“片段”，可与绝对长度的单位结合使用

       ```css
       grid-template-columns: 150px 1fr 2fr;
       ```

     - `auto`由浏览器自己决定长度

       ```css
       grid-template-columns: 100px auto 100px;
       ```

       ```css
       .container {
           grid-template-columns: 80px auto 100px;
           grid-template-rows: 25% 100px auto 60px;
       }
       ```

       ![img](https://img-blog.csdnimg.cn/adc776445c12412c93917b5271cc5182.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pyd6ZizMzk=,size_20,color_FFFFFF,t_70,g_se,x_16)

       > 参考：[css【详解】grid布局—— 网格布局（栅格布局）_css grid-CSDN博客](https://blog.csdn.net/weixin_41192489/article/details/115588135)

## 十、文本溢出的省略样式

### 1.单行溢出

```css
white-spcae: nowrap;		// 文本强制不换行
text-overflow: ellipsis;	// 文本溢出展示省略号，规定当文本溢出时，显示省略号来代表被修剪的文本
overflow: hidden;			// 溢出隐藏，文字长度超出限定宽度，则隐藏超出的内容
```

```css
.p {
	width: 400px;	// 必须规定宽或最大宽度
	height: 40px;
	line-height: 40px;
	white-space: nowrap;
	overflow: hiiden;
	text-overflow: ellipsis;
}
```

### 2.多行溢出

```css
display: -webkit-box;			// 元素转换为弹性容器，在一行排列
-webkit-box-orient: vertical；	// 表示盒子对象的子元素的排列方式
-webkit-line-clamp: 3;			// 限制文本的行数，表示文本第几行省略
text-overflow: ellipsis;		// 溢出展示省略号
overflow: hiidden;				// 溢出隐藏
```

```css
.p {
	width: 400px;
	-webkit-line-clamp: 2;
	display: -webkit-box;
	-webkit-box-orient: vertical;
	overflow: hiiden;
	text-overflow: ellipsis;
}
```

## 十一、生成固定宽高比的盒子

### 1.padding-top

在Chrome88之前不支持`aspect-ratio`的时候，主要的方案是使用`padding-top`或`padding-bottom`来生成固定宽高比的盒子。

此方案也被称为`Padding-Top Hack`。该解决方案需要一个**父容器**和一个**绝对放置的子容器**。然后，可以将宽高比计算为百分比以设置为`padding-top`：

- 1：1长宽比= 1/1 = 1 = `padding-top: 100%`
- 4：3长宽比= 3/4 = 0.75 = `padding-top: 75%`
- 3：2长宽比= 2/3 = 0.66666 = `padding-top: 66.67%`
- 16：9长宽比= 9/16 = 0.5625 = `padding-top: 56.25%`

```html
<div class="container">
	<img class="media" src=""/>
</div>
```

```css
.container {
	position: relative;
	width: 100%;
	padding-top: 100%;	// 1:1 aspect ratio
}

.media {
	position: absolute;
	top: 0;
    width: 100%;
    height: 100%;
    background: blue;
}
```

![image-20231219195301731](https://gitee.com/v876774538/my-img/raw/master/image-20231219195301731.png)

### 2.aspect-ratio

```css
body {
    margin: 0;
}

.container {
    position: relative;
    width: 100%;
    aspect-ratio: 1 / 1;
}

.media {
    position: absolute;
    top: 0;
    width: 100%;
    height: 100%;
    background: blue;
}
```

## 十二、块级元素、行内元素和行内块的区别

### 1.块级元素(block)

- 占据一行；

- 高度、行高以及内外边距都可以设置；

- 宽度默认为它容器的100%；

- 可以容纳内联元素和其他块元素。

  常见块级元素：`div`、`h1`、`p`

### 2.行内元素(inline)

- 和其他元素共享一行；

- 高、行高以及内外边距均不可改变；

- 宽度就是其文字或图片的宽度，由内容撑开，不可改变。

  常见行内元素：`i`、`span`、`a`

### 3.行内块元素(inline-block)

- 和其他元素共享一行

- 行高以及内外边距都可以改变。

  常见行内块元素：`button`、`img`、`input`

## 十三、link和import的区别

```css
<style>
	/*每个页面公共css */
	@import url("./common/common.less");

	...
</style>
```

```html
<link rel="shortcut icon" href="https://img.alicdn.com/tps/i4/TB1_oz6GVXXXXaFXpXXJDFnIXXX-64-64.ico" type="image/x-icon"/>
<link rel="stylesheet" href="https://g.alicdn.com/thx/cube/1.3.2/cube.min.css">
<link rel="stylesheet" href="demo.css">
<link rel="stylesheet" href="iconfont.css">
```

### 1.从属关系区别

- `@import`是CSS提供的语法规则，只有导入样式表的作用；
- `link`是HTML提供的标签，不仅可以加载CSS文件，还可以定义RSS、rel连接属性等。

### 2.加载顺序区别

- 加载页面时，`link`标签引入的CSS被同时加载；
- `@import`引入的CSS将在**页面加载完毕后被加载**。

### 3.兼容性区别

- `@import`是CSS2.1才有的语法，故只可在IE5+被识别；
- `link`标签作为HTML元素，不存在兼容性问题。

### 4.DOM可控性区别

- 可以通过JS操作DOM，插入`link标签`来改变样式；
- 由于DOM方法是基于文档的，无法使用`@import`的方式插入样式。



# js

## 一、引用类型和基本类型的区别

### 1.总结

在js中把我们的数据进行了分类，可以理解为两大类：

- **基本数据类型**：`string`、`number`、`null`、`Boolean`、`undefind`、`symbol`
- **应用数据类型**：`Object`、`Array`、`Function`

> 区别：**基本数据类型保存在栈里**，可以**直接访问**它的值；而**引用数据类型保存在堆中**，栈里保存的是访问它们的**地址**，访问时通过地址访问堆中的值。

### 2.如何判断数据类型

- `typeof`：判断的粒度较粗，它能准确判断基础类型（不包括`null`）以及`Object`和`Function`，转而言之，它不能判断`null`和`Array`，会将它们都判断为`Object`。

- `instanceof`：用来判断对象的更具体的类型。instanceof的模拟实现，它的主要原理是沿着对象的原型链的方向，判断原型对象是否是构造器的prototype。

- `Array.isArray`：专门用来判断**是否为数组**。

- `Function.prototype.toString.call`：最全面的方法，代码运行如下

  ```js
  // 以数组为例
  Function.prototype.toString.call([])	// [object Array]
  ```

  返回结果是一个**字符串**

  ```js
  Object.prototype.toString.call([]).slice(8, -1).toLowerCase()	// 可以得到具体的类型，代码中的-1表示倒数第一个元素
  ```

  ```js
  var arr = ['1', '2']
  var obj = {name: '张三'}
  console.log('判断arr', Object.prototype.toString.call(arr).slice(8, -1).toLowerCase())	// array
  console.log('判断obj', Object.prototype.toString.call(obj).slice(8, -1).toLowerCase())	object
  ```

### 3.基本类型

#### 3.1 Number

数值最常见的整数类型为十进制，还可以设置八进制（0开头）、十六进制（0x开头）

```js
let intNum = 55
let octNum = 070
let hexNum = 0xa
```

浮点类型在数值中必须包含小数点

```js
let floatNum1 = 1.1
let floatNum2 = 0.1
let floatNum3 = .1
let floatNum4 = 3.125e7
console.log(floatNum1, floatNum2, floatNum3, floatNum4)	// 1.1 0.1 0.1 31250000
```

在数值类型中，存在一个特殊数字`NaN`，意为不是数值。用于**表示本来要返回数值的操作失败**了。

```js
console.log(0 / 0)	// NaN
console.log(-0 / +0)	// NaN
```

#### 3.2 String

字符串可以使用双引号`""`、单引号`''`或反引号`表示。

```js
let firstName = 'John'
let lastName = 'Jacob'
let lastName = `Jingleheimerschmidt`
```

字符串一旦创建，它们的值**是不可变的**。

```js
let lang = 'Java'
lang = lang + 'Script' // 先销毁再创建
```

#### 3.3 Boolean

布尔型`Boolean`有两个字面值：true/false。

通过`Boolean`可以将其他类型的数据转换成布尔值：

| 数据类型  | true                  | false        |
| --------- | --------------------- | ------------ |
| String    | 非空字符串            | 空字符串`''` |
| Number    | 非0数值（包括无穷值） | `0`、`NaN`   |
| Object    | 任意对象              | `null`       |
| Undefined | /                     | `undefined`  |

#### 3.4 Undefined

`Undefined`类型只有一个特殊值`undefined`。

当使用`var`或`let`**声明了变量但没有初始化**时，就相当于给变量赋予了`undefined`值。

```js
let message
console.log(message)	// undefined

console.log(age) // 没有声明过这个变量，报错
```

#### 3.5 Null

`Null`类型同样只有一个特殊值`null`。

`null`代表空对象指针，给`typeof`传一个`null`会返回`object`。

```js
let car = null
console.log(typeof car)	// object
```

`undefined`由`null`派生而来，因此：

```js
console.log(null == undefined)	// true
```

#### 3.6 Symbol

`Symbol`（符号）是原始值，且符号实例是唯一、不可变的。

符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。

```js
let genericSymbol = Symbol()
let otherGenericSymbol = Symbol()
console.log(genericSymbol == otherGenericSymbol)    // false

let fooSymbol = Symbol('foo')
let otherFooSymbol = Symbol('foo')
console.log(fooSymbol == otherFooSymbol)    // false
```

### 4.引用类型

#### 4.1 Object

创建`object`常用方式为对象**字面量表示法**，属性名可以是字符串或数值。

```js
let person = {
	name: 'Nicholas',
	age: 29,
	5: true,
}
```

#### 4.2 Array

js中的数组是一组有序的数据，但跟其他语言不同的是，数组中每个槽位**可以存储任意类型的数据**，数组大小也是动态的，会随着**数据添加**而**自动增长**。

```js
let colors = ['red', 2, {age: 20}]
colors.push(2)
console.log(colors)
```

![image-20231222135450705](https://gitee.com/v876774538/my-img/raw/master/image-20231222135450705.png)

#### 4.3 Function

`function`（函数）实际上是对象，每个函数都是`function`类型的实例，而`function`也有属性和方法，跟其他引用类型一样。

函数三种常见的表达方式：

1. 函数声明

   ```js
   function sum(num1, num2) {
   	return num1 + num2
   }
   ```

2. 函数表达式

   ```js
   let sum = function(num1, num2) {
   	return num1 + num2
   }
   ```

3. 箭头函数

   ```js
   let sum = (num1, num2) => {
   	return num1 + num2
   }
   ```

#### 4.4 其他引用类型

除上述三种引用类型外，还包括`Date`、`RegExp`、`Map`、`Set`等……

### 5.存储区别

#### 5.1 基本数据类型

基本数据类型存储在**栈**中，可以直接访问它的值。

```js
let a = 10;
let b = a;	// 赋值
b = 20;
console.log(a)	// 10
```

![img](https://static.vue-js.com/906ffb90-6463-11eb-85f6-6fac77c0c9b3.png)

#### 5.2 引用数据类型

引用数据类型存放在**堆**中，栈中存放它们的**引用地址**。

```js
var obj1 = {}
var obj2 = obj1	// 将obj2的地址指向obj1的堆
obj2.name = 'xxx'
console.log(obj1.name)	// xxx
```

![img](https://static.vue-js.com/a34bdd10-6463-11eb-ab90-d9ae814b240d.png)

## 二、==和===的区别

### 1.总结

- `=`：赋值操作
- `==`：判断二者的值是否相等，相等返回true，反之返回false
- `===`：判断二者是否**全等**（值和类型都相等），相等返回true，反之返回false

### 2.==

js中存在**隐式转换**，操作符`==`在比较中会**先进行类型转换**，再确定操作数是否相等。

- 如果任一操作数是布尔值，则将其转换为数值再比较是否相等

  ```js
  let result = true == 1	// true
  ```

- 如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等

  ```js
  let result = '55' == 55	// true
  ```

- 如果一个操作数是对象，另一个操作数不是，则调用对象的 `valueOf()`方法取得其原始值，再根据前面的规则进行比较

  ```js
  let obj = {
  	valueOf: function() {
  		return 1
  	}
  }
  let result = obj == 1	// true
  ```

- `null`和`undefined`相等

  ```js
  let result = null == undefined // true
  ```

- 如果有任一操作数是`NaN`，则返回`false`

  ```js
  let result = NaN == NaN	// false
  ```

- 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都**指向同一个对象**，则相等操作符返回`true`

  ```js
  let obj1 = {name: 'xxx'}
  let obj2 = {name: 'xxx'}
  let result = (obj1 == obj2)	// false
  ```

由于`==`会进行隐式转换，因此会带来一些**反直觉的结果**：

```js
'' == '0' // false
0 == '' // true
0 == '0' // true

false == 'false' // false
false == '0' // true

false == undefined // false
false == null // false
null == undefined // true

' \t\r\n' == 0 // true
```

### 3.===

全等操作符由三个等号`===`表示，只有两个操作数在**不进行转换**的前提下相等才会返回`true`。

```js
let result1 == '55' === 55	// false
let result2 == 55 === 55	// true
```

`undefined`和`null`与自身严格相等

```js
let result1 = null === null	// true
let result2 = undefined === undefined	// true
```

### 4.a==1 && a==2 && a==3

使`a == 1 && a == 2 && a == 3`成立：

```js
var a = { value: 0 }
a.toString = function() {
	return this.value += 1
}
```

解析：首先`a`是一个对象。判断a值时，存在**对象到数字的转换**。

1. 如果对象具有`valueOf()`方法，后者返回一个原始值，js将这个原始值转换为数字，最后返回该数字；
2. 其次，对象若具有`toString`方法，后者返回一个原始值，则js将这个原始值转换为数字，最后返回该数字；
3. 否则，js将抛出一个类型错误异常。

### 5.a===1 && a===2 && a===3

使`a === 1 && a === 2 &&& a === 3`成立：

```js
var value = 0;
Object.defineProperty(window, 'a', {
	get: function() {
		return this.value += 1
	}
})

console.log(a === 1 && a === 2 && a === 3)
```

## 三、typeof和instanceof的区别

### 1.typeof

`typeof`操作符返回一个**字符串**，表示**未经计算的操作数的类型**。

#### 1.1 使用方法

```js
typeof operand
```

`operand`表示对象或原始值的表达式。

```js
typeof 1	// 'number'
typeof '1'	// 'string'
typeof undefined // 'undefined'
typeof true	// 'boolean'
typeof Symbol()	// 'symbol'
typeof null	// 'object' ←注意
typeof []	// 'object'	←注意
typeof {}	// 'object'
typeof console	// 'object'
typeof console.log	// 'function'
```

#### 1.2 注意事项

`typeof`一般用来判断变量是否存在，返回它的类型。

- 其中基本数据类型`null`返回的是`object`，但并不代表它属于应用数据类型。如果需要在`if`中判断是否为`null`，直接通过`=== null`来判断即可；

- 采用`typeof`判断引用数据类型，除了`function`会被识别之外，其他的都输出为`object`

- 可以使用`typeof`来判断变量是否存在：

  ```js
  if (typeof a != 'undefined') {
  	// 变量存在
  }
  ```

### 2.instanceof

`instanceof`用于检测构造函数的`prototype`属性是否出现在某个实例对象的原型链上。

#### 2.1 使用方法

```js
object instanceof constructor
```

`object`为实例对象，`constructor`为构造函数。

构造函数通过`new`可以实例对象，`instanceof`能判断这个对象是否是之前那个构造函数生成的对象。

```js
// 定义构造函数
let Car = function() {}
let benc = new Car()
benc instanceof Car	// true

let car = new String('xxx')
car instanceof String	// true

let str = 'xxx'
str instanceof String	// false
```

#### 2.2 实现原理参考

顺着原型链查找，直到查找到相同的原型对象，返回`true`，反之返回`false`

```js
function myInstanceof(left, right) {
	// typeof判断基础数据类型 是直接返回false
	if (typeof left != 'object' left === null) {
		return n
	}
	// getProtypeOf是Object对象自带的API，能够拿到参数的原型对象
	let proto = Object.getProtypeOf(left)
	while(true) {
		if (proto === null) {
			return false
		}
		if (proto === right.prototype) {
			return true	// 找到相同原型对象，返回true	
		}
        proto = Object.getPrototypeof(proto)
	}
}
```

### 3.区别

`typeof`与`instanceof`都是判断数据类型的方法，区别如下：

- `typeof`会返回**变量的基本类型**字符串，`instance`则直接返回**布尔值**；
- `instanceof`可以准确地判断复杂应用数据类型，但不能正确判断基础数据类型；
- `typeof`存在弊端：虽然可以判断除null之外的基础数据类型。但是引用数据类型中，除了function类型之外，其他都返回object，无法准确判断。

### 4.全局通用的数据类型判断方法

`Object.prototype.toString`，调用该方法，统一返回格式`[object xxx]`。

```js
Object.prototype.toString({}) // "[object Object]"
Object.prototype.toString.call({}) // 同上结果，加上call也ok
Object.prototype.toString.call(1) // "[object Number]"
Object.prototype.toString.call('1') // "[object String]"
Object.prototype.toString.call(true) // "[object Boolean]"
Object.prototype.toString.call(function () {}) // "[object Function]"
Object.prototype.toString.call(null) //"[object Null]"
Object.prototype.toString.call(undefined) //"[object Undefined]"
Object.prototype.toString.call(/123/g) //"[object RegExp]"
Object.prototype.toString.call(new Date()) //"[object Date]"
Object.prototype.toString.call([]) //"[object Array]"
Object.prototype.toString.call(document) //"[object HTMLDocument]"
Object.prototype.toString.call(window) //"[object Window]"
```

使用`Object.prototype.toString.call([]).slice(8, -1).toLowerCase()`得到具体的数据类型。

```js
function getType(obj) {
  let type = typeof obj
  if (type !== 'object') {
    // 先进行typeof判断，如果是基础数据类型，直接返回
    return type
  }
  // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果
  return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, '$1')
}
```

```js
getType([]) // "Array" typeof []是object，因此toString返回
getType('123') // "string" typeof 直接返回
getType(window) // "Window" toString返回
getType(null) // "Null"首字母大写，typeof null是object，需toString来判断
getType(undefined) // "undefined" typeof 直接返回
getType() // "undefined" typeof 直接返回
getType(function () {}) // "function" typeof能判断，因此首字母小写
getType(/123/g) //"RegExp" toString返回
```

## 四、深拷贝与浅拷贝

### 1.浅拷贝

浅拷贝，即是将一个对象的值复制给另一个对象，若属性是基本类型，拷贝的就是基础类型的值；如果对象中包含对其他对象的引用，则该应用仍然指向**原来对象的地址**。

浅拷贝只**拷贝一层**，深层次的应用类型则共享内存地址。

#### 1.1 简单实现对象浅拷贝

```js
function shallowClone(obj) {
	const newObj = {}
	for(let prop in obj) {
		if (obj.hasOwnProperty(prop)) {
			newObj[prop] = obj[prop]
		}
	}
	return newObj
}
```

备注：`hasOwnProperty()`方法，检测属性是否为对象的自有属性

```js
let obj = {
    name:'张睿',
    age:18,
    eat:{
        eatname:'面条',
        water:{
            watername:'农夫山泉'
        }
    }
}
console.log(obj.hasOwnProperty('name')) //true
console.log(obj.hasOwnProperty('age'))  //true
console.log(obj.hasOwnProperty('eat'))  //true
console.log(obj.hasOwnProperty('eatname'))  //false
console.log(obj.hasOwnProperty('water'))  //false
console.log(obj.hasOwnProperty('watername'))  //false
console.log(obj.eat.hasOwnProperty('eatname'))  //true
console.log(obj.eat.hasOwnProperty('water'))  //true
console.log(obj.eat.hasOwnProperty('watername'))  //false
console.log(obj.eat.water.hasOwnProperty('watername'))  //true
```

#### 1.2 Object.assign

```js
var sourceObj1 = {
    name: 'zs',
    age: 23
}
var sourceObj2 = {
    state: 'single',
    mood: 'happy'
}

var result = Object.assign(sourceObj, sourceObj2)
```

#### 1.3 数组的slice()

`slice()`方法用于数组截取指定元素。该方法不会改变原数组，只会将截取的元素**封装到一个新数组**，**原数组不会改变**。

```js
const fxArr = ['One', 'Two', 'Three']
const fxArrs = fxArr.slice(0)
fxArrs[1] = 'love'
console.log(fxArr)	// ['One', 'Two', 'Three']
console.log(fxArrs)	// ['One', 'love', 'Three']
```

#### 1.4 数组的concat()

`concat()`方法用于连接两个或多个数组。`concat()`方法会将新数组的成员添加到原数组的尾部，并**返回一个新数组**，**原数组不会改变**。

```js
const fxArr = ['One', 'Two', 'Three', { name: 'zhangsan' }]
const fxArrs = fxArr.concat()
fxArrs[1] = 'love'
fxArrs[3].name = 'lisi'
console.log(fxArr) // ["One", "Two", "Three", { name: 'lisi' }]
console.log(fxArrs) // ["One", "love", "Three" { name: 'lisi' }]	// 第二层只引用了地址，因此会一起改变
```

#### 1.5 拓展运算符

```js
const fxArr = ['One', 'Two', 'Three']
const fxArrs = [...fxArr]
fxArrs[1] = 'love'
console.log(fxArr) // ["One", "Two", "Three"]
console.log(fxArrs) // ["One", "love", "Three"]
```

### 2.深拷贝

深拷贝**开辟一个新的栈**，两个对象的属性完全相同，但对应两个不同的地址，修改其中一个对象的属性，不会改变另一个对象的属性值。

#### 2.1 _.cloneDeep()

> Lodash是一个著名的javascript原生库，通过使用其封装的数组、数字、对象、字符串等方法，使javascript变得更加简单。

```bash
npm i -g npm
npm i --save lodash
```

```js
const _ = require('lodash')
const obj1 = {
	a: 1,
	b: { f: { g: 1 } },
	c: [1, 2, 3]
}
const obj2 = _.cloneDeep(obj1)
console.log(obj1.b.f === obj2.b.f)	// false
```

#### 2.2 jQuery.extend()

> `jQuery.extend( [deep ], target, object1 [, objectN ] )`
>
> 深度复制合并对象，第一个参数是boolean类型的true时，将object1, ..., objectN深度复制后合并到target中。

```js
const $ = require('jquery')
const obj1 = {
	a: 1,
	b: { f: { g: 1 } },
	c: [1, 2, 3]
}
const obj2 = $.extend(true, {}, obj1)
console.log(obj1.b.f === obj2.b.f)	// false
```

#### 2.3 JSON.stringify-parse

```js
const obj2 = JSON.parse(JSON.stringify(obj1))
```

这种方式存在一定的弊端：会忽略`undefined`、`symbol`和`函数`。

```js
const obj = {
  name: 'A',
  name1: undefined,
  name3: function () {},
  name4: Symbol('A'),
}
const obj2 = JSON.parse(JSON.stringify(obj))
console.log(obj2) // {name: "A"}
```

#### 2.4 循环递归

```js
function deepClone(obj, hash = new WeakMap()) {
  if (obj === null) return obj // 如果是null或者undefined我就不进行拷贝操作
  if (obj instanceof Date) return new Date(obj)
  if (obj instanceof RegExp) return new RegExp(obj)
  // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝
  if (typeof obj !== 'object') return obj
  // 是对象的话就要进行深拷贝
  if (hash.get(obj)) return hash.get(obj)
  let cloneObj = new obj.constructor()
  // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身
  hash.set(obj, cloneObj)
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      // 实现一个递归拷贝
      cloneObj[key] = deepClone(obj[key], hash)
    }
  }
  return cloneObj
}
```

## 五、作用域链

### 1.作用域

**作用域**，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合。

作用域决定了代码区块中变量和其他资源的可见性。

```js
function myFunction() {
	let inVariable = '函数内部变量'
}
myFunction()
console.log(invariable)	// Uncaught ReferenceError: inVariable is not defined
```

上述例子中，我们在函数`myFunction`内部创建一个`inVariable`变量，当我们在全局访问该变量时，系统报错。这说明我们在全局是无法获取到（闭包除外）函数内部的变量的。

#### 1.1 全局作用域

任何不在函数中或大括号中声明的变量，都是在**全局作用域**下。

全局作用域下声明的变量可以在程序的任意位置访问。

```js
// 全局变量
var greeting = 'Hello World!'
function greet() {
	console.log(greeting)
}

greet()
```

#### 1.2 函数作用域

**函数作用域**也称为局部作用域，如果一个变量是在函数内部声明的，那么它就在一个函数作用域中。

这些变量仅能在函数内部访问。

```js
function greet() {
	var greeting = 'Hello World!'
	console.log(greeting)
}
greet()
console.log(greeting)	// 报错
```

#### 1.3 块级作用域

ES6中引入了`let`和`const`关键字。

与`var`关键字不同的是，在大括号中使用`let`和`const`声明变量，使它们存在于**块级作用域**中，在大括号之外不能访问这些变量。

```js
{
	// 块级作用域
	let greeting = 'Hello World!'
	var lang = 'English'
	console.log(greeting)
}
console.log(lang)	// 'English'
console.log(greeting)	// 报错
```

#### 1.4 词法作用域

词法作用域，又称为静态作用域，它在变量被创建时就确定好了，而非在执行阶段确定。

也就是说我们在编写代码时它的作用域便已确定，`javascript`遵循的就是**词法作用域**。

```js
var a = 2
function foo() {
  console.log(a)	// 输出2
}
function bar() {
  var a = 3
  foo()
}
n()
```

![image-20240108150302672](https://gitee.com/v876774538/my-img/raw/master/image-20240108150302672.png)

### 2.作用域链

当在javascript中使用一个变量时，首先js引擎会尝试在当前作用域下寻找该变量，如果没找到，再到它的上层作用域中寻找，以此类推，直到找到该变量或到达全局作用域。

如果在全局作用域中仍然无法找到该变量，它就会在全局范围内隐式声明该变量（非严格模式）或直接报错。

![image-20240108150742825](https://gitee.com/v876774538/my-img/raw/master/image-20240108150742825.png)

```js
var sex = '男'
function person() {
  var name = '张三'
  function student() {
    var age = 18
    console.log(name) // 张三
    console.log(sex) // 男
  }
  student()
  console.log(age) // Uncaught ReferenceError: age is not defined
}
person()
```

## 六、箭头函数

ES6提出了新语法箭头函数。

`Function`不但承担了函数的功能，还可以当做构造函数来使用，箭头函数最大意义是解放了`Function`的功能，大大简化了`Function`的使用频率。

### 1.基础语法

```js
var a = () => {
	console.log(this)	// window
}
```

### 2.注意事项

与普通函数相比，它：

- 写法更加简洁，这一点在高阶函数的使用中尤为方便，如`map`、`forEach`；
- 箭头函数内部没有自己的`this`，它的`this`指向外层作用域的`this`，不能通过`call`、`apply`、`bind`来修改this指向；
- 件数函数内部没有`arguments`对象，但是ES6配套提供了**剩余参数**用来代替arguments；
- 不能当做构造器使用。

## 七、原型和原型链

### 1.原型

> 原型是一个特殊的对象，我们在使用构造函数时，它的`prototype`属性就是我们所说的原型对象。它的主要作用是解决继承的问题。
>
> 在开发中我们一般把一些通用的方法挂载到原型上，这样`new`出来的对象也会具有这样的属性。
>
> 比如，在vue中有时也会给vue的原型添加一些公共类方法来实现所有组件可以共享成员：`$router`和`$store`。

Javascript常备描述为一种基于原型的语言——每个对象拥有一个原型对象。

当试图访问一个对象的属性时，它不仅仅在该对象上搜索，还会搜索该对象的原型、以及该对象的原型的原型，层层向上，直到查询到一个名字匹配的属性或达到原型链的末尾。

**举例**：

函数可以有属性，每个函数都有一个特殊的属性叫做原型`prototype`。

```js
function doSomething() {
	...
}
console.log(doSomething.prototype)
```

控制台输出**原型对象**：

```js
{
    constructor: ƒ doSomething(),
    __proto__: {
        constructor: ƒ Object(),
        hasOwnProperty: ƒ hasOwnProperty(),
        isPrototypeOf: ƒ isPrototypeOf(),
        propertyIsEnumerable: ƒ propertyIsEnumerable(),
        toLocaleString: ƒ toLocaleString(),
        toString: ƒ toString(),
        valueOf: ƒ valueOf()
    }
}
```

原型对象有一个自由属性`constructor`，这个属性指向该函数，如下图关系所示：

![image-20240108170607212](https://gitee.com/v876774538/my-img/raw/master/image-20240108170607212.png)

### 2.原型链



## 八、闭包

## 九、内存泄露

## 十、bind-call-apply的区别

## 十一、继承
