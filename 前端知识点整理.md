# CSS

## 一、CSS3新特性

- `border-radius`：圆角边框
- `box-shadow`：盒子阴影
- `background-size`：背景图片大小
- `transition`：过渡
- `transform`：转换（位移、旋转、缩放）
- `animation`：动画
- `linear-gradient`：线性渐变
- `box-sizing`：css3盒子模型

## 二、BFC

BFC(Block Formatting Context)，块级格式化上下文。是用于布局块级盒子的独立渲染区域。

> W3C官方解释：`BFC`它决定了元素如何对其内容进行定位，以及与其它元素的关系和相互作用，当涉及到可视化布局时，`Block Formatting Context`提供了一个环境，`HTML`在这个环境中按照一定的规则进行布局。

简单来说就是，`BFC`是一个完全独立的空间（布局环境），让**空间里的子元素不会影响到外面的布局**。那么怎么使用`BFC`呢，**`BFC`可以看做是一个`CSS`元素属性**。

### 1.怎样触发BFC

- HTML根元素；
- position为`absolute`或`fixed`（绝对定位、固定定位）；
- float属性不为`none`（浮动）；
- overflow不为`visible`；
- display为`inline-block`、`table-cell`、`table-caption`、`flex`。

### 2.BFC解决了什么问题

1. 使用`float`脱离文档流，导致高度塌陷

   ```html
   <style>
     .par {
       border: 5px solid #fcc;
       width: 300px;
     }
   
     .child {
       border: 5px solid #f66;
       width: 100px;
       height: 100px;
       float: left;
     }
   </style>
   <body>
     <div class="par">
       <div class="child"></div>
       <div class="child"></div>
     </div>
   </body>
   ```

   ![img](https://static.vue-js.com/ec5d4410-9511-11eb-85f6-6fac77c0c9b3.png)

   而`BFC`在计算高度时，浮动元素也会参与，所以我们可以触发`.par`元素的`BFC`，则内部浮动元素计算高度时候也会计算。

   ```css
   .par {
     overflow: hidden;
   }
   ```

   ![img](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAcEAAAC6CAYAAADWKfZeAAAERUlEQVR4nO3cMWtUWRiA4S+baBAjRLC1TWthI1hZ+IMtrCysLCzsLRURVBQDiQSGhNli6mQ3sxmz5n2e5haXc/iKgRcO587WcrlcDgAE/XXdAwDAdRFBALJEEIAsEQQgSwQByBJBALJEEIAsEQQga+fCt8vlzPHxzOnpbxoHAC5hZ2dmb29ma2u95Re+XS5nPn+e+fVrrc0BYKPu3p05OFg7go5DAcgSQQCyRBCALBEEIEsEAci6+HboRRaLmQ8fVk+AP8H29syjRzP7+9c9CZdxdjZzeLh6XrH1I3hyMvPu3czR0RWOA7BBt27NPHky8/DhdU/CZSwWq2/WNxBBx6EAZIkgAFkiCECWCAKQJYIAZK1/O/QiDx7MPH26uo4M53nzZubr18ut2d9f/bZ2dzczEzfD27erP/+Hf7CZCN6/P/P8+eo6Mpzn/fvLR/DevZlnz1ZPOM/HjyLIv+I4FIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByNrZyK4/f868ejWzvb2R7bkhfvy4/Jqjo5nXr2d2d69+Hm6OL1+uewL+EJuJ4PfvMy9ebGRr4g4PZ16+vO4pgBvCcSgAWSIIQJYIApAlggBkiSAAWevfDr1zZ+bx45nF4grHAdig7e2Zk5OZT5+uexIu4+xs5vR0I1uvH8Hbt2cODq5wFIDfYLGY+fbtuqfgf8JxKABZIghAlggCkCWCAGSJIABZW8vlcnnu2+Vy5vh4Y1dTAeA/2dmZ2dub2dpaa/nFEQSAG8xxKABZIghAlggCkCWCAGSJIABZIghAlggCkCWCAGSJIABZIghA1t9sT2c0JjdqvAAAAABJRU5ErkJggg==)

2. margin边距重叠

   ```html
   <style>
     p {
       color: #f55;
       background: #fcc;
       width: 200px;
       line-height: 100px;
       text-align: center;
       margin: 100px;
     }
   </style>
   <body>
     <p>Haha</p>
     <p>Hehe</p>
   </body>
   ```

   ![img](data:image/png;base64,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)

   两个`p`元素之间的距离为`100px`，发生了`margin`重叠（塌陷），以最大的为准，如果第一个 P 的`margin`为 80 的话，两个 P 之间的距离还是 100，**以最大的为准**。

   可以**在`p`外面包裹一层容器，并触发这个容器生成一个`BFC`，那么两个`p`就不属于同一个`BFC`**，则不会出现`margin`重叠

   ```html
   <style>
     .wrap {
       overflow: hidden; // 新的BFC
     }
     p {
       color: #f55;
       background: #fcc;
       width: 200px;
       line-height: 100px;
       text-align: center;
       margin: 100px;
     }
   </style>
   <body>
     <p>Haha</p>
     <div class="wrap">
       <p>Hehe</p>
     </div>
   </body>
   ```

   ![img](data:image/png;base64,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)

3. 两栏布局

   ```html
   <style>
     body {
       width: 300px;
       position: relative;
     }
   
     .aside {
       width: 100px;
       height: 150px;
       float: left;
       background: #f66;
     }
   
     .main {
       height: 200px;
       background: #fcc;
     }
   </style>
   <body>
     <div class="aside"></div>
     <div class="main"></div>
   </body>
   ```

   ![img](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAbIAAAEsCAYAAACmHzYvAAAFB0lEQVR4nO3YIU5kURRF0UtBEIRAgiAoFJiav2YMTIAZIJFUXutOtel88bNhLXnFy3E7eRdrrTUAEHXYewAAbCFkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpV2eX7++Zt7eZz88d5pDx9DTz8rL3CqDu9nbm4WHTE+chO51m3t9nPj42PcwPdzzO3N/vvQL4CTaGzNciAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApF2dXQ6HmdfXmbu7HeaQ8fi49wKAmflXyC4vZ47HmefnHeYAwP/xtQhAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKRdrLXWX5e1Zr6+Zk6nnSYB8GtcX8/c3Gx64jxkABDiaxGANCEDIE3IAEgTMgDShAyANCEDIE3IAEgTMgDShAyANCEDIE3IAEj7A5bFIWh0uWkWAAAAAElFTkSuQmCC)

   每个元素的左外边距与包含块的左边界相接触，因此，虽然`.aslide`为浮动元素，但是`main`的左边依然会与包含块的左边相接触。

   而**`BFC`的区域不会与浮动盒子重叠**，所以我们可以**通过触发`main`生成`BFC`**，以此适应两栏布局。

   ```css
   .main {
     overflow: hidden;
   }
   ```

   ![img](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAa0AAAEmCAYAAADRIc8sAAAExElEQVR4nO3YsWnDQACG0XPwANpBtcGtJ/K63sGdh/BlgKhQIER8yXvlccVfCD5OpznnHAAQ8HH0AADYS7QAyBAtADJEC4AM0QIgQ7QAyBAtADJEC4AM0QIg47x5er//8gxybrcxLpejVwB16zrGsuy+7qUFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQMZpzjm/nD4eB0wh5f0eY+PTAfiWdR1jWXZfP2+eXq8/NYe/6vkc4/U6egXwz/g9CECGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZJzmnPPoEQCwh5cWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZHwCQNcaPMMeeNgAAAAASUVORK5CYII=)

### 3.清除浮动的方法总结

#### 1.1 额外标签法

给需要清除浮动的元素后，额外添加一个空白标签。

- 优点：通俗易懂、书写方便；
- 缺点：添加许多无意义的标签，结构化较差。

```html
<div class="fahter">
        <div class="big">big</div>
        <div class="small">small</div>
        <div class="clear">额外标签法</div>
</div>
```

```css
.big, .small {
    float: left;
}

.clear {
	clear: both;
}
```

#### 1.2 父级添加`overflow`

通过`触发BFC`的方式实现清除浮动。

必须定义`width`或`zoom: 1`(设置或检索对象的缩放比例，设置`zoom: 1`可以在IE6下清除浮动、解决margin导致的重叠等问题)，同时不能定义`height`，使用`overflow: hiiden`时，浏览器会自动检查浮动区域的高度。

```css
.fahter{
    width: 400px;
    border: 1px solid deeppink;
    overflow: hidden;
}
```

#### 1.3 使用`after`伪元素清除浮动

额外标签法的升级版，优点是无需单独添加标签、且符合闭合浮动思想，结构语义化正确，不容易出现奇怪的bug。

IE8及非IE浏览器支持`:after`。

```html
<body>
    <div class="father clearfix">
        <div class="big">big</div>
        <div class="small">small</div>
        <!--<div class="clear">额外标签法</div>-->
    </div>
    <div class="footer"></div>
</body>
```

```css
.clearfix:after {/*伪元素是行内元素 正常浏览器清除浮动方法*/
    content: "";
    display: block;
    height: 0;
    clear:both;
    visibility: hidden;
}
.clearfix {
    *zoom: 1;/*ie6清除浮动的方式 *号只有IE6-IE7执行，其他浏览器不执行*/
}
```

#### 1.4 使用`before`和`after`**双伪元素清除浮动**

```html
<div class="father clearfix">
    <div class="big">big</div>
    <div class="small">small</div>
</div>
<div class="footer"></div>
</div>
```

```css
<style>
    .father{
        border: 1px solid black;
        *zoom: 1;
    }
    .clearfix:after,.clearfix:before{
       content: "";
       display: block;
       clear: both;
    }
    .big ,.small{
        width: 200px;
        height: 200px;
        float: left;
    }
    .big{
        background-color: red;
    }
    .small{
        background-color: blue;
    }
</style>
```

单伪元素清除法和双伪元素清除法的区别：单伪元素只能清除浮动，双伪元素既能清除浮动，又能解决**外边距塌陷问题**（垂直方向相邻的块级元素，兄弟元素之间会出现外边距合并的问题，父子元素之间会出现外边距塌陷的问题，**即给子元素设置`margin-top`，父元素会随子元素同时向下移动**）。

解决方法：

- 让父元素上外边距不相邻：
  - 给父元素设置上外框
  - 给父元素设置上内边距
  - 在html结构中父子元素之间加一个`table`标签
- 开启父元素的BFC：
  - 父元素设置`overflow: hidden`
  - 父元素设置`display: table`
- 把父元素或子元素转换为行内块

**双伪元素解决外边距塌陷问题，利用了让父子元素外边距不相邻的原理**。

## 三、盒子模型

盒子模型组成有四部分构成，分别是：`内容`、`内边距`、`外边距`、`边框`。

2种盒子模型：

#### 1.1 标准盒子模型

`box-sizing: content-box`

标准盒子模型 = content(内容) + border(边框) + padding(内边距)

![img](https://static.vue-js.com/c0e1d2e0-8f9b-11eb-85f6-6fac77c0c9b3.png)

- 盒子总宽度 = width + padding + border + margin;
- 盒子总高度 = height + padding + border + margin

#### 1.2 怪异盒子模型

`box-sizing: border-box;`

怪异盒子模型 = content(内容) （内容的宽高已经包含了padding和border）

![img](https://static.vue-js.com/cfbb3ef0-8f9b-11eb-ab90-d9ae814b240d.png)

- 盒子总宽度 = width + margin;
- 盒子总高度 = height + margin;

## 四、flexbox

### 1.flex布局

`flexbox`是一种布局模型，让网页更加简单灵活，基于Flex精确灵活控制块级盒子的布局方式，并且避免浮动布局中脱离文档流现象发生。

### 2.常见属性

- `flex-direction`：决定主轴方向（项目排列方向）

  ```css
  .container {
  	flex-direction: row | row-reverse | column | column-reverse;
  }
  ```

  - row：默认值，水平方向，起点在左端
  - row-reverse：水平方向，起点在右端
  - column：垂直方向，起点在上沿
  - column-reverse：垂直方向，起点在下沿

  ![img](https://static.vue-js.com/0c9abc70-9838-11eb-ab90-d9ae814b240d.png)

- `flex-wrap`：决定容器内项目是否可换行

  ```css
  .container {
  	flex-wrap: nowrap | wrap | wrap-reverse;
  }
  ```

  - nowrap：默认值，不换行，使元素弹性伸缩

  - wrap：换行

  - wrap-reverse：换行，第一行在下方

    ![img](https://pic1.zhimg.com/80/v2-d9886eabf578e74323329237b80e1cdc_720w.webp)

- `flex-flow`：`flex-direction`和`flex-wrap`属性的简写形式，默认值为`row nowrap`

  ```css
  .box {
  	flex-wrap: <flex-direction> | <flex-wrap>;
  }
  ```

- `justify-content`：主轴上的对齐方式

  ```css
  .box {
  	justify-content: flex-start | flex-end | center | space-between;
  }
  ```

  - flex-start：默认值，左对齐
  - flex-end：右对齐
  - center：居中
  - space-between：两端对齐，项目之间的间隔都相等
  - space-around：项目两侧间隔相等

  ![img](https://static.vue-js.com/2d5ca950-9838-11eb-85f6-6fac77c0c9b3.png)

- `align-items`：定义项目在交叉轴上的对齐方式

  ```css
  .box {
  	justify-content: flex-start | flex-end | center | space-between
  }
  ```

  - flex-start：起点对齐
  - flex-end：重点对齐
  - center：中点对齐
  - baseline：项目的第一行文字的基线对齐
  - stretch：默认值，若项目未设置高度或设为`auto`，将占满整个容器的高度

- `align-content`：**只适用于多行的flex容器**，若子项仅有一行，该属性不起作用

  ```css
  .box {
    align-content: flex-start | flex-end | center | space-between | space-around | stretch;
  }
  ```

  - flex-start：与交叉轴的起点对齐
  - flex-end：与交叉轴的终点对齐
  - center：与交叉轴的中点对齐
  - space-between：与交叉轴两端对齐，轴线之间的间隔平均分布
  - space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍
  - stretch（默认值）：轴线占满整个交叉轴

  ![img](https://static.vue-js.com/39bcb0f0-9838-11eb-ab90-d9ae814b240d.png)

### 3.其他容器成员属性

- `order`：定义项目的排列顺序。**数字越小，排列越靠前，默认为0**。

  ```css
  .item {
  	order: <integer>;
  }
  ```

- `flex-grow`：定义**项目的放大比例**（容器宽度>元素总宽度时如何伸展）。默认为0，即如果存在剩余空间，也不放大。

  ```css
  .item {
  	flex-grow: <number>
  }
  ```

  ![img](https://static.vue-js.com/48c8c5c0-9838-11eb-ab90-d9ae814b240d.png)

  ![img](https://static.vue-js.com/5b822b20-9838-11eb-ab90-d9ae814b240d.png)

  注意：若弹性容器的宽度正好等于元素宽度总和，无多余宽度，此时无论`flex-grow`是什么值都不会生效。

- `flex-shrink`：定义了项目的**缩小比例**（容器宽度<元素总宽度时如何收缩）。默认为 1，即如果空间不足，该项目将缩小。

  ```css
  .item {
    flex-shrink: <number>; /* default 1 */
  }
  ```

- `flex-basis`：设置的是元素在主轴上的初始尺寸，所谓的初始尺寸就是元素在`flex-grow`和`flex-shrink`生效前的尺寸。默认值为`auto`，即项目的本来大小；如设置了`width`则元素尺寸由`width/height`决定（主轴方向），没有设置则由内容决定；**当设置为 0 的是，会根据内容撑开**；也可以设为跟`width`或`height`属性一样的值（比如 350px），则项目将占据固定空间。

  ```css
  .item {
    flex-basis: <length> | auto; /* default auto */
  }
  ```

- `flex`：`flex`属性是`flex-grow`, `flex-shrink` 和 `flex-basis`的简写，默认值为`0 1 auto`。

  ```css
  .item {
    flex: none | [ < 'flex-grow' > < 'flex-shrink' >? || < 'flex-basis' > ];
  }
  ```

  - flex: 1 = flex: 1 1 **0%**
  - flex: 2 = flex: 2 1 0%
  - flex: auto = flex: 1 1 **auto**
  - flex: none = flex: 0 0 auto，常用于固定尺寸不伸缩

  > `flex:1`和`flex:auto`的区别，可以归结于`flex-basis:0`和`flex-basis:auto`的区别：
  >
  > 当设置为0时（绝对弹性元素），此时相当于告诉`flex-grow`和`flex-shrink`在伸缩的时候不需要考虑我的尺寸
  >
  > 当设置为`auto`时（相对弹性元素），此时则需要在伸缩时将元素尺寸纳入考虑

  注意：建议优先使用这个属性，而不是单独写三个分离的属性。

- `align-self`：允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性。默认值为`auto`，表示继承父元素的`align-items`属性，如果没有父元素，则等同于`stretch`。

  ```css
  .item {
    align-self: auto | flex-start | flex-end | center | baseline | stretch;
  }
  ```

  ![img](https://static.vue-js.com/6f8304a0-9838-11eb-85f6-6fac77c0c9b3.png)

## 五、CSS绘制三角形

### 1.原理

边框实际上并不是一条直线，如果我们将四条边设置为不同的颜色，并逐渐将边框放大，可以看到每条边框都是一个梯形：

![img](https://static.vue-js.com/78d4bd90-a27a-11eb-85f6-6fac77c0c9b3.png)

当分别取消边框的时候，会发生下面几种情况：

- 取消一条边的时候，与这条边相接触的部分会变成直线；
- 当仅有邻边时，两个边会变成对分的三角形；
- 当保留边没有其他接触时，极限情况下所有内容都会消失。

![img](https://static.vue-js.com/84586ef0-a27a-11eb-85f6-6fac77c0c9b3.png)

### 2.实心三角形

使用CSS绘制三角形的原理是利用**盒子边框**完成的，其步骤如下：

1. 设置一个盒子；

2. 设置四周不同颜色的边框；

   ![img](https://static.vue-js.com/e3f244e0-a279-11eb-ab90-d9ae814b240d.png)

3. 为边框设置粗细；

   ![img](https://static.vue-js.com/ee0b42b0-a279-11eb-ab90-d9ae814b240d.png)

4. 将`盒子宽高设置为0`，`仅保留边框`；

   ![img](https://static.vue-js.com/2afaa030-a27a-11eb-85f6-6fac77c0c9b3.png)

5. 得到四个三角形，选择其中一个，`将其他三个三角形设置为透明`色。

```css
div {
  width: 0px;
  height: 0px;
  border-top: 20px solid transparent;
  border-bottom: 20px solid red;
  border-left: 20px solid transparent;
  border-right: 20px solid transparent;
}
```

### 3.空心三角形

```css
.border {
	width: 0;
	height: 0;
	border-style: solid;
	border-width: 0 50px 50px;
	border-color: transparent transparent #d9534f;
	position: relative;
}
```

利用伪类新建一个小一点的三角形定位到大的三角形上，实现空心三角形的效果。

```css
.border:after {
	content: '';
	border-style: solid;
	border-width: 0 40px 40px;
    border-color: transparent transparent #96ceb4;
    position: absolute;
    top: 0;
    left: 0;
}
```

![i](https://static.vue-js.com/59f4d720-a27a-11eb-85f6-6fac77c0c9b3.png)

最终代码如下：

```css
.border {
	width: 0;
	height: 0;
	border-style: solid;
	border-width: 0 50px 50px;
	border-color: transparent transparent #d9534f;
	position: relative;
}

.border:after {
	content: '';
	border-style: solid;
	border-width: 0 40px 40px;
	border-color: transparent transparent #fff;
	position: absolute;
	top: 6px;
	left: -40px;
}
```

## 六、CSS选择器

```html
<div id="box">
  <div class="one">
    <p class="one_1"></p>
    <p class="one_1"></p>
  </div>
  <div class="two"></div>
  <div class="two"></div>
  <div class="two"></div>
</div>
```

### 1.选择器

- id选择器：`#box`，选择id为box的元素

- 类选择器：`.box`，选择类名为box的所有元素

- 标签选择器：`div`，选择标签为div的所有元素

- 后代选择器：`#box div`，选择id为box的元素内部所有div元素

- 子选择器：`.one>.one_1`，选择父元素类名为one的所有类名为one_1的元素

- 相邻兄弟选择器：`.one+.two`，选择紧邻类名为one的元素之后同级的类名为two的元素

  ```html
  <div id="box">
      <div class="two">0</div>
      <div class="one">
        <p class="one_1"></p>
        <p class="one_1"></p>
      </div>
      <div class="two">1</div>
      <div class="two">2</div>
      <div class="two">3</div>
      <div class="one"></div>
    </div>
  ```

  ```css
  .one+.two {
      width: 100px;
      height: 100px;
      background: red;
  }
  ```

  ![image-20231128153638960](https://gitee.com/v876774538/my-img/raw/master/image-20231128153638960.png)

- 群组选择器：`div, p`，选择div、p的所有元素

- 交集选择器：`.one .one_1`，选择同时符合.one和.one_1条件的元素

- 伪类选择器：

  - `:link`：选择未被访问的链接
  - `:visited`：选择已被访问的链接
  - `:hover`：鼠标指针悬停在上面的元素
  - `:active`：选择活动链接（当你点击一个链接时，它变成活动链接。为了产生预期的效果，在css定义中，`:active`必须位于`:hover`之后）
  - `:focus`：选择具有焦点的
  - `:first-child`：父元素的首个子元素

- 伪元素选择器：

  - `:first-letter`：用来指定元素第一个字母的样式

  - `:first-line`：用来指定元素第一行

    ```html
    <div id="box">
        <p>
            天上白玉京，十二楼五城。<br>
            仙人抚我顶，结发受长生。<br>
            误逐世间乐，颇穷理乱情。<br>
            九十六圣君，浮云挂空名。<br>
            天地赌一掷，未能忘战争。<br>
            试涉霸王略，将期轩冕荣。<br>
            时命乃大谬， 弃之海上行。<br>
            学剑翻自哂， 为文竟何成。<br>
            剑非万人敌， 文窃四海声。<br>
            儿戏不足道， 五噫出西京。<br>
        </p>
    </div>
    ```

    ```css
    p {
        color: #333;
    }
    
    p:first-letter {
        color: red;
    }
    
    p:first-line {
        color: blue;
    }
    ```

    ![image-20231128155201051](https://gitee.com/v876774538/my-img/raw/master/image-20231128155201051.png)

  - `:before`：选择器在被选元素的内容前面插入内容

  - `:after`：选择器在被选元素的内容后面插入内容

- 属性选择器

  - `[attribute]`：选择带有attribute属性的元素

    ```css
    a[target] {
    	background: yellow;
    }
    ```

  - `[attribute=value]`：选择所有使用attribute=value的元素

    ```css
    a[target="_blank"] {
    	background: yellow;
    }
    ```

  - `[attribute~=value]`：选择attribute属性包含value的元素

    ```css
    [title~="flower"] {
      border: 5px solid yellow;
    }
    ```

    上面的例子会匹配以下属性的元素：title="flower"、title="summer flower" 以及 title="flower new"，**但不匹配：title="my-flower" 或 title="flowers"。**

    ```html
    <div id="box">
        <div class="flower">flower</div>
        <div class="flowers">flowers</div>
        <div class="summer flower">summer flower</div>
        <div class="my-flower">my-flower</div>
    </div>
    ```

    ```css
    div {
        width: 100px;
        height: 100px;
        border: 1px solid #333;
    }
    
    [class~="flower"] {
        background: red;
    }
    ```

    ![image-20231128160721193](https://gitee.com/v876774538/my-img/raw/master/image-20231128160721193.png)

  - `[attribute|=value]`：选择attribute属性以value开头的元素

    ```css
    [class|="top"] {
      background: yellow;
    }
    ```

    下例选取 class 属性以 "top" 开头的所有元素：

    **提示：**值必须是**完整或单独的单词**，比如 class="top" 或者后跟连字符的，比如 class="top-text"。

    ```html
    <div id="box">
        <div class="flower">flower</div>
        <div class="flowers">flowers</div>
        <div class="summer flower">summer flower</div>
        <div class="my-flower">my-flower</div>
        <div class="flower-my">flower-my</div>
    </div>
    ```

    ```css
    div {
        width: 100px;
        height: 100px;
        border: 1px solid #333;
    }
    
    [class|="flower"] {
        background: red;
    }
    ```

    ![image-20231128161011075](https://gitee.com/v876774538/my-img/raw/master/image-20231128161011075.png)

CSS3新增选择器：

- 全部兄弟选择器（层次选择器）：`.one~.two`，选择**所有**符合条件的兄弟元素

  ```css
  .one~.two {
      width: 100px;
      height: 100px;
      background: red;
  }
  ```

  ![image-20231128155615800](https://gitee.com/v876774538/my-img/raw/master/image-20231128155615800.png)

- 属性选择器：

  - `[attribute*=value]`：选择attribute属性值包含value的所有元素

    **提示：**值不必是完整单词！

  - `[attribute^=value]`：选择attribute属性开头为value的所有元素

    **提示：**值不必是完整单词！

  - `[attribute$=value]`：选择attribute属性结尾为value的所有元素

    **提示：**值不必是完整单词！

  > 应用场景：**为不带`class`或`id`的表单设置样式**。

  ```css
  input[type="text"] {
    width: 150px;
    display: block;
    margin-bottom: 10px;
    background-color: yellow;
  }
  
  input[type="button"] {
    width: 120px;
    margin-left: 35px;
    display: block;
  }
  ```

### 2.优先级

> 内联 > ID 选择器 > 类选择器 > 标签选择器

**计算规则**：具体的计算层⾯，优先级是由`A、B、C、D`的值来决定的。

- 如果`存在内联样式`，那么`A=1`，否则A=0；
- B的值等于`ID选择器出现的次数`；
- C的值等于`类选择器`、`属性选择器`和`伪类`出现的次数；
- D的值等于`标签选择器`和`伪元素`出现的总次数

举例：

```css
#nav-global > ul > li > a.nav-link;
```

- A=0
- B=1
- C=1
- D=3

推出其优先级值为：(0, 1, 1, 3)。

**比较规则**：

- 从左往右依次比较，较大者优先级更高；
- 若相等，则继续右移一位进行比较；
- 若4位全部相等，则后者覆盖前者

**提示**：若外部样式需要覆盖内联样式，需要使用`!important`。

### 3.CSS继承属性

在CSS中，继承指的是给父元素设置一些属性，后代元素会自动拥有这些属性。

**继承属性**有：

- 字体系列属性

  ```css
  font: 组合字体 
  font-family: 规定元素的字体系列
  font-weight: 设置字体的粗细
  font-size: 设置字体的尺寸
  font-style: 定义字体的风格
  font-variant: 偏大或偏小的字体
  ```

  **提示**：

  - a 标签的字体颜色不能被继承
  - h1-h6 标签字体的大下也是不能被继承的

- 文本系列属性

  ```css
  text-indent：文本缩进
  text-align：文本水平对刘
  line-height：行高
  word-spacing：增加或减少单词间的空白
  letter-spacing：增加或减少字符间的空白
  text-transform：控制文本大小写
  direction：规定文本的书写方向
  color：文本颜色
  ```

- 元素可见性

  ```css
  visibility
  ```

- 表格布局属性

  ```css
  caption-side：定位表格标题位置
  border-collapse：合并表格边框
  border-spacing：设置相邻单元格的边框间的距离
  empty-cells：单元格的边框的出现与消失
  table-layout：表格的宽度由什么决定
  ```

- 列表属性

  ```css
  list-style-type：文字前面的小点点样式
  list-style-position：小点点位置
  list-style：以上的属性可通过这属性集合
  ```

- 引用

  ```css
  quotes：设置嵌套引用的引号类型
  ```

- 光标属性

  ```css
  cursor：箭头可以变成需要的形状
  ```

**无继承的属性**：

- 元素显示类型/子元素布局类型

  ```css
  display
  ```

- 文本属性

  ```css
  vertical-align: 垂直居中
  text-decoration: 水平居中
  ```

- 盒子模型的属性

  ```css
  width: 宽度
  height: 高度
  padding: 内边距
  margin: 外边距
  border: 边框
  ```

- 背景属性

  ```css
  background-image: 背景图片
  background-color: 背景颜色
  background-position: 背景图像起始位置
  ```

- 定位属性

  ```css
  float: 浮动
  clear: 清除浮动
  position: 定位
  ```

- 生成内容属性：content、counter-reset、counter-increment

- 轮廓样式属性：outline-style、outline-width、outline-color、outline

- 页面样式属性：size、page-break-before、page-break-after

## 七、em/px/rem/vh/vw区别

在CSS单位中，可以分为**相对长度单位**和**绝对长度单位**：

|   CSS单位    |                                        |
| :----------: | -------------------------------------- |
| 相对长度单位 | em、ex、ch、rem、vw、vh、vmin、vmax、% |
| 绝对长度单位 | cm、mm、in、px、pt、pc                 |

### 1.px

#### 1.1 说明

`px`表示像素，所谓像素就是呈现在我们显示器上的一个个小点，这这个设备中，每个像素点都是大小等同的，与其他属性无关，所以像素是绝对长度单位。

### 2.em

#### 2.1 说明

`em`是相对长度单位，相对于当前对象内文本的字体尺寸。若当前对象内文本的字体尺寸未被设置，则采用相对于浏览器默认字体尺寸（`1em = 16px`）。

> 为了简化`font-size`的换算，我们需要在CSS中的`body`选择器中声明`font-size: 62.5%`，使em的值变为`1em = 16px * 62.5% = 10px`。即12px = 1.2em，16px = 1.6em。

#### 2.2 特点

- em的值并不是固定的
- em会**继承父级元素的字体大小**
- em是相对长度单位，若当前对象内文本的字体尺寸未被设置，则采用相对于浏览器默认字体尺寸
- **任意浏览器的默认字体大小都是16px**

#### 2.3 举例

```html
<div class="big">
	左边距14px
	<div class="small">左边距12px</div>
</div>
```

```css
html {
	font-size: 10px;  
} /*  公式16px*62.5%=10px  */
.big {
	margin-left: 1.4rem
}
.small {
	margin-left: 1.2rem;
}
```

![image-20231129143918619](https://gitee.com/v876774538/my-img/raw/master/image-20231129143918619.png)

### 3.rem

#### 3.1 说明

`rem`，CSS3新增的相对长度单位，相对于`HTML根元素`的`font-size`的值。

> 同理，若想要简化`font-size`转化，我们可以在根元素css中加入`font-size: 62.5%`。

```css
html {
	font-size: 62.5%;
} /*  公式16px*62.5%=10px  */
```

#### 3.2 特点

- rem单位集相对大小和绝对大小的优点于一身
- 与em不同之处就在于rem总是相对于根元素，而不需要像em一样使用级联的方式来计算尺寸

### 4.vh、vw

#### 4.1 说明

`vw`，即根据窗口的**宽度**，分成100等份：100vw表示满宽，50vw表示一半宽度。

vw始终针对窗口的宽度，同理，`vh`为窗口的**高度**。

此处的窗口分为几种情况：

- 桌面端：指浏览器的可视区域。即`window.innerWidth/window.innerHeight`大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。

  ![图片.png](http://ww.qdxiaochuan.com/zb_users/upload/2021/05/202105071620362786893461.png)

- 移动端：布局视口

  ![图片.png](http://ww.qdxiaochuan.com/zb_users/upload/2021/05/202105071620362817755517.png)

#### 4.2 vh/vw和%的区别

- vh与vw都是根据窗口大小比例适应显示，**根据浏览器窗口来进行定位的**

  ```css
  1vw = 窗口宽度的1%
  1vh = 窗口高度的1%
  ```

- %则根据**父元素**进行定位

  - 对于普通定位元素，%根据父元素进行定位
  - 对于`posiiton: absolute`的元素，相对于已定位的父元素
  - 对于`position: fixed`的元素，相对于ViewPort（可视窗口）

## 八、响应式设计

### 1.介绍

响应式网站设计（Responsive Web Design）是一种网络页面设计布局，页面的设计与开发应当根据用户行为以及设备环境（系统平台、屏幕尺寸等进行响应的响应和调整）。

响应式网站常见特点：

- 同时适配PC、平板和手机端等
- 标签导航在接近手持终端设备时改变为经典的抽屉式导航
- 网站的布局会根据视口来调整模块的大小和位置

![img](https://static.vue-js.com/ae68be30-9dba-11eb-85f6-6fac77c0c9b3.png)

### 2.实现方法

响应式设计的基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理，为了处理移动端，页面头部必须有`meta`声明`viewport`：

```html
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no”>
```

属性对应如下：

- `width=device-width`：自适应手机屏幕的尺寸宽度
- `maximun-scale`：缩放比例的最大值
- `inital-scale`：缩放的初始化
- `user-scalable`：是否允许用户缩放

#### 2.1 媒体查询

使用`@media`查询，可以针对不同的媒体类型定义不同的样式，如：

```css
@media screen and (max-width: 1920px) {
	...
}
```

```css
@media screen and (min-width: 375px) and (max-width: 600px) {
	body {
		font-size: 18px;
	}
}
```

#### 2.2 百分比

比如当浏览器的宽度或高度发生变化时，通过百分比单位，我们可以使浏览器中的组件的宽高随浏览器的变化而变化，从而实现响应式的效果。

`height`、`width`属性的百分比依托于父元素的宽高，但其他盒子属性则不完全依赖父元素：

- 子元素的`top`/`left`和`bottom`/`right`如果设置百分比，则相对于直接**非static定位的父元素**的高度/宽度

- 子元素的`padding`如果设置百分比，不论垂直方向或是水平方向，都**相对于直接父元素的width**，而与父元素的height无关

- 子元素的`margin`如果设置百分比，不论垂直方向还是水平方向，也是**相对于直接父元素的width**

- `border-radius`相对于自身的**宽高**

  ```css
  border-radius: 50%;	// 圆
  ```

  **补充**

  border-radius设置原则：

  - 若为一个值，则用其为半径构建圆形，这个圆与边框的交集形成圆角的效果；

  - 若为两个值，则这两个值分别为半长轴、半短轴构建椭圆，这个椭圆与边框的交集形成圆角效果

    ![img](https://img-blog.csdnimg.cn/20210309165959853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDEzNzU3NQ==,size_16,color_FFFFFF,t_70)

  举例：

  - 盒子宽高都为100px，设置`border-top-left-radius: 50%`，相当于用50px作为半径构建圆形

    ![img](https://img-blog.csdnimg.cn/20210309171931507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDEzNzU3NQ==,size_16,color_FFFFFF,t_70)

  - 盒子宽200px，高100px，设置`border-top-left-radius: 50%`，相当于用100px作为半长轴，50px作为半短轴构建圆形

    ![img](https://img-blog.csdnimg.cn/2021030917181783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDEzNzU3NQ==,size_16,color_FFFFFF,t_70)

  - 盒子宽高都为100px，设置`border-top-left-radius: 10% 50%`，相当于用10px作为半短轴，50px作为半长轴构建圆形

    ![img](https://img-blog.csdnimg.cn/20210309172342705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDEzNzU3NQ==,size_16,color_FFFFFF,t_70)

  - 盒子宽200px，高100px，设置`border-top-left-radius: 10% 50%`，相当于用20px作为半短轴，50px作为半长轴构建圆形

    ![img](https://img-blog.csdnimg.cn/20210309172437772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDEzNzU3NQ==,size_16,color_FFFFFF,t_70)

#### 2.3 vw/vh

`vw`表示相对于视图窗口的宽度，`vh`表示相对于视图窗口的高度。

任意层级元素，在使用vw为单位的情况下，1vw都等于**视图宽度**的百分之一。

#### 2.4 rem

> 前文提到，`rem`是相对于根元素`html`的`font-size`属性改变尺寸大小的单位，默认情况下浏览器字体大小为16px，此时`1rem = 16px`。

可以利用媒体查询的方法，针对不同设备分辨率改变根元素`font-size`的值，如：

```css
@media screen and (max-width: 414px) {
	html {
		font-size: 18px;
	}
}

@media screen and (max-width: 375px) {
	html {
		font-size: 16px;
	}
}

@media screen and (max-width: 320px) {
	html {
		font-size: 12px;
	}
}
```

为了更准确地监听设备可视窗口的变化，可以采用`js`的方法动态地修改`font-size`的值，以达到响应式的目的：

```js
// 动态为根元素设置字体大小
function init() {
	// 获取屏幕宽度
	var width = document.documentElement.clientWidth
	// 设置根元素字体大小
	document.documentElement.style.fontSize = width / 10 + 'px'
}

// 首次加载应用，设置
init()
// 监听手机旋转的事件和时机，重新设置
window.addventListener('orientationchange', init)
// 监听手机窗口变化，重新设置
window.addEventListener('resize', init)
```

无论设备可视窗口如何变化，始终设置`rem`为`width`的 1/10，实现了百分比布局。

**SANTIME官网**：http://syy333.dynv6.net:20080/syy/santime.git

```html
<script>
    (function (win) {
        var tid

        function refreshRem() {
            let designSize = 1920 // 设计图尺寸
            let html = document.documentElement
            let wW = html.clientWidth // 窗口宽度
            let rem = (wW * 100) / designSize
            document.documentElement.style.fontSize = rem + 'px'
        }

        win.addEventListener(
            'resize',
            function () {
                clearTimeout(tid)
                tid = setTimeout(refreshRem, 300)
            },
            false
        )
        win.addEventListener(
            'pageshow',
            function (e) {
                if (e.persisted) {
                    clearTimeout(tid)
                    tid = setTimeout(refreshRem, 300)
                }
            },
            false
        )

        refreshRem()
    })(window)

    $(function () {
        $('#foot').load('foot.html')
    })
</script>
```

#### 2.5 scale

页面缩放，最好用于固定宽高比的Web应用，如大屏或者固定窗口业务应用。

**三益友官网**：http://syy333.dynv6.net:20080/zhangzl/syy.git master分支

```js
window.onload = function() {
  setScale();
}
window.onresize = function () {
  setScale();
};
function setScale() {
  // 设计稿：1920 * 1080
  // 1.设计稿尺寸
  let targetWidth = 1920;
  // 2.拿到当前设备（浏览器）的宽度
  // document.documentElement  获取html的宽度
  let currentWidth = document.documentElement.clientWidth || document.body.clientWidth;
  // 3.计算缩放比率(屏幕过宽，根据高度计算缩放比例)
  let scaleRatio = currentWidth / targetWidth;
  // 4.开始缩放网页
  // 宽度>1920 顶部中心缩放
  if (currentWidth > targetWidth) {
    document.body.style = `transform: scale(${scaleRatio}); transform-origin: top center;`;
  }
  // 宽度<1920 顶部靠左缩放
  else {
    document.body.style = `transform: scale(${scaleRatio}); transform-origin: top left;`;
  }
}
```

注意：`transform`会导致`position:fixed`失效，故只能使用`position:absolute`，采用将滚动距离赋值给绝对定位的元素的方法。

```js
handleScroll() {
  var scrollTop =
    window.pageYOffset ||
    document.documentElement.scrollTop ||
    document.body.scrollTop;
  // let top = this.selectIndex == 0 ? 670 : 502;
  let top = document.documentElement.querySelector(".header").offsetHeight + document.documentElement.querySelector(".header").offsetTop;
  var headerElement = document.documentElement.querySelector(".header1");
  if (scrollTop >= top) {
    if (!this.show) {
      this.show = true;
      this.show1 = true;
    }
    headerElement.style = `top: ${scrollTop / this.scaleRatio}px`;
  } else {
    if (this.show) {
      this.show1 = false;
      setTimeout(() => {
        this.show = false;
      }, 400);
    }
  }
},
```

参考文献：[前端大屏适配几种方案_前端大屏适配方案_狮子歌歌_丶的博客-CSDN博客](https://blog.csdn.net/Liushiliu104/article/details/129372083?spm=1001.2100.3001.7377&utm_medium=distribute.pc_feed_blog_category.none-task-blog-classify_tag-8-129372083-null-null.nonecase&depth_1-utm_source=distribute.pc_feed_blog_category.none-task-blog-classify_tag-8-129372083-null-null.nonecase)

## 九、常见布局实现

### 1.两栏布局

#### 1.1 效果

双栏布局十分常见，往往是以一个**定宽栏**和一个**自适应的栏**并排展示存在。适用于有明显**主次关系**的网页。

![img](https://static.vue-js.com/fcb8ac50-976e-11eb-85f6-6fac77c0c9b3.png)



#### 1.2 实现思路

1. float浮动

   - 使用`float`左浮动左边栏
   - 右边模块用`margin-left`撑出内容块做内容展示
   - 为父级元素添加BFC，防止下方元素飞到上方内容

   ```html
   <!DOCTYPE html>
   <html lang="en">
   
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
   </head>
   
   <body>
       <div class="index">
           <div class="nav">
               <div class="li">1</div>
               <div class="li">2</div>
               <div class="li">3</div>
               <div class="li">4</div>
               <div class="li">5</div>
           </div>
           <div class="main">
               <div class="title">Title</div>
               <div class="box"></div>
   
           </div>
       </div>
   </body>
   <style>
       body {
           margin: 0;
       }
       
       .clearfix:after,
       .clearfix:before {
           content: "";
           display: block;
           clear: both;
       }
   
       .index {
           /* 父元素添加BFC */
           overflow: hidden;
           /* background: lightslategray; */
       }
   
       .nav {
           width: 21%;
           height: 100%;
           min-height: 100vh;
           float: left;
           background: lightblue;
       }
   
       .nav .li {
           height: 30px;
           line-height: 30px;
           padding: 0 15px;
           box-sizing: border-box;
       }
   
       .nav .li:first-child {
           background: lightcoral;
       }
   
       .main {
           margin-left: 21%;
           padding: 20px;
           box-sizing: border-box;
       }
   
       .main .box {
           width: 200px;
           height: 100px;
           background: red;
       }
   </style>
   
   </html>
   ```

   ![image-20231130101955341](https://gitee.com/v876774538/my-img/raw/master/image-20231130101955341.png)

2. flex布局

   ```html
   <!DOCTYPE html>
   <html lang="en">
   
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
   </head>
   
   <body>
       <div class="index">
           <div class="nav">
               <div class="li">1</div>
               <div class="li">2</div>
               <div class="li">3</div>
               <div class="li">4</div>
               <div class="li">5</div>
           </div>
           <div class="main">
               <div class="title">Title</div>
               <div class="box"></div>
   
           </div>
       </div>
   </body>
   <style>
       body {
           margin: 0;
       }
   
       .index {
           /* flex弹性布局 */
           display: flex;
       }
   
       .nav {
           width: 21%;
           height: 100%;
           min-height: 100vh;
           float: left;
           background: lightblue;
       }
   
       .nav .li {
           height: 30px;
           line-height: 30px;
           padding: 0 15px;
           box-sizing: border-box;
       }
   
       .nav .li:first-child {
           background: lightcoral;
       }
   
       .main {
           padding: 20px;
           box-sizing: border-box;
       }
   
       .main .box {
           width: 200px;
           height: 100px;
           background: red;
       }
   </style>
   
   </html>
   ```

### 2.三栏布局

#### 2.1 效果

![img](https://static.vue-js.com/0bf016e0-976f-11eb-ab90-d9ae814b240d.png)

#### 2.2 实现思路

1. 两边float，中间margin

   ```html
   <!DOCTYPE html>
   <html lang="en">
   
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
   </head>
   
   <body>
       <div class="wrap">
           <div class="left">左侧</div>
           <div class="right">右侧</div>
           <div class="center">
               中间
               <div class="box"></div>
           </div>
       </div>
   </body>
   <style>
       body {
           margin: 0;
       }
   
       .wrap {
           overflow: hidden;
       }
   
       .left, .right {
           width: 20%;
           height: 100%;
           min-height: 100vh;
       }
       
       .left {
           float: left;
           background: lightblue;
       }
   
       .right {
           float: right;
           background: lightcoral;
       }
   
       .center {
           margin: 0 20%;
           padding: 20px;
           box-sizing: border-box;
       }
   
       .center .box {
           width: 200px;
           height: 200px;
           background: red;
       }
   </style>
   
   </html>
   ```

   ![image-20231130103127406](https://gitee.com/v876774538/my-img/raw/master/image-20231130103127406.png)

2. 两边absolute，中间margin

   ```css
   body {
       margin: 0;
   }
   
   .wrap {
       position: relative;
   }
   
   .left, .right {
       width: 20%;
       height: 100%;
       min-height: 100vh;
   }
   
   .left {
       position: absolute;
       top: 0;
       left: 0;
       background: lightblue;
   }
   
   .right {
       position: absolute;
       top: 0;
       right: 0;
       background: lightcoral;
   }
   
   .center {
       margin: 0 20%;
       padding: 20px;
       box-sizing: border-box;
   }
   
   .center .box {
       width: 200px;
       height: 200px;
       background: red;
   }
   ```

3. 两边使用float和负margin

   ```html
   <!DOCTYPE html>
   <html lang="en">
   
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
   </head>
   
   <body>
       <div class="main-wrapper">
           <div class="main">中间自适应</div>
       </div>
       <div class="left">左边固定宽度</div>
       <div class="right">右边固定宽度</div>
   </body>
   <style>
       .left,
       .right,
       .main {
           height: 200px;
           line-height: 200px;
           text-align: center;
       }
   
       .main-wrapper {
           float: left;
           width: 100%;
       }
   
       .main {
           margin: 0 110px;
           background: black;
           color: white;
       }
   
       .left,
       .right {
           float: left;
           width: 100px;
           margin-left: -100%;
           background: green;
       }
   
       .right {
           margin-left: -100px;
           /* 同自身宽度 */
       }
   </style>
   
   </html>
   ```

   ![image-20231130110912093](https://gitee.com/v876774538/my-img/raw/master/image-20231130110912093.png)

4. display: table

   `<table>`标签用于展示行列数据，不适合用于布局。但可以使用`display: table`来实现布局的效果。

   ```html
   <!DOCTYPE html>
   <html lang="en">
   
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
   </head>
   
   <body>
       <div class="container">
           <div class="left">左边固定宽度</div>
           <div class="center">中间自适应</div>
           <div class="right">右边固定宽度</div>
       </div>
   </body>
   <style>
       body {
           margin: 0;
       }
   
       .container {
           /* 设置为表格 */
           display: table;
           /* 列宽由自身宽度决定 无需自动计算 */
           table-layout: fixed;
           width: 100%;
           height: 100%;
           min-height: 100vh;
       }
   
       .left, .right, .center {
           /* 设置为单元格 */
           display: table-cell;
       }
   
       .left, .right {
           width: 20%;
           height: 100%;
           min-height: 100vh;
       }
   
       .left {
           background: lightblue;
       }
   
       .right {
           background: lightcoral;
       }
   </style>
   
   </html>
   ```

   ![image-20231130111621587](https://gitee.com/v876774538/my-img/raw/master/image-20231130111621587.png)

5. flex实现

   ```html
   <!DOCTYPE html>
   <html lang="en">
   
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
   </head>
   
   <body>
       <div class="container">
           <div class="left">左边固定宽度</div>
           <div class="center">中间自适应</div>
           <div class="right">右边固定宽度</div>
       </div>
   </body>
   <style>
       body {
           margin: 0;
       }
   
       .container {
           width: 100%;
           height: 100%;
           min-height: 100vh;
           display: flex;
       }
   
       .left, .right, .center {
       }
   
       .left, .right {
           width: 20%;
           height: 100%;
           min-height: 100vh;
       }
   
       .left {
           background: lightblue;
       }
   
       .right {
           background: lightcoral;
       }
   
       .center {
           width: 100%;
           /* flex: 1; */
           background: lightseagreen;
       }
   </style>
   
   </html>
   ```

   - 仅需将容器设置为`display:flex;`，
   - 盒内元素两端对其，将中间元素设置为`100%`宽度，或者设为`flex:1`，即可填充空白
   - 盒内元素的高度撑开容器的高度

   优点：

   - 结构简单直观
   - 可以结合 flex 的其他功能实现更多效果，例如使用 order 属性调整显示顺序，让主体内容优先加载，但展示在中间

6. grid网格布局

   ```html
   <!DOCTYPE html>
   <html lang="en">
   
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
   </head>
   
   <body>
       <div class="container">
           <div class="left">左边固定宽度</div>
           <div class="center">中间自适应</div>
           <div class="right">右边固定宽度</div>
       </div>
   </body>
   <style>
       body {
           margin: 0;
       }
   
       .container {
           width: 100%;
           display: grid;
           grid-template-columns: 300px auto 300px;
       }
   
       .left, .right, .center {
           height: 100px;
       }
   
       .left {
           background: lightblue;
       }
   
       .right {
           background: lightcoral;
       }
   
       .center {
           width: 100%;
           /* flex: 1; */
           background: lightseagreen;
       }
   </style>
   
   </html>
   ```

   ![image-20231219191135377](https://gitee.com/v876774538/my-img/raw/master/image-20231219191135377.png)

   **grid布局的使用方法**：

   - 启用网格布局：`display: grid`

     块级容器（宽度撑满整行时）`display: grid;`

     行内容器（宽度随内容自适应时）`display: inline-grid;`

     > 注意：使用网格布局后，项目的`float`、`display: inline-block`、`display: table-cell`、`vertical-align`和`column-*`等设置都将失效。

   - 划分列：`grid-template-columns`

     - 将容器等分为3列，每列宽度为100px

       ```css
       grid-template-columns: 100px 100px 100px;
       ```

     - 将容器等分为3列，每列宽度为总宽度/3

       ```css
       grid-template-columns: 33.33% 33.33% 33.33%;
       ```

     - 将容器划分为3列，第一列的宽度:第二列的宽度 = 1:2

       ```css
       grid-template-columns: 1fr 2fr;
       ```

     - `fr`是fraction的缩写，意为“片段”，可与绝对长度的单位结合使用

       ```css
       grid-template-columns: 150px 1fr 2fr;
       ```

     - `auto`由浏览器自己决定长度

       ```css
       grid-template-columns: 100px auto 100px;
       ```

       ```css
       .container {
           grid-template-columns: 80px auto 100px;
           grid-template-rows: 25% 100px auto 60px;
       }
       ```

       ![img](https://img-blog.csdnimg.cn/adc776445c12412c93917b5271cc5182.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pyd6ZizMzk=,size_20,color_FFFFFF,t_70,g_se,x_16)

       > 参考：[css【详解】grid布局—— 网格布局（栅格布局）_css grid-CSDN博客](https://blog.csdn.net/weixin_41192489/article/details/115588135)

## 十、文本溢出的省略样式

### 1.单行溢出

```css
white-spcae: nowrap;		// 文本强制不换行
text-overflow: ellipsis;	// 文本溢出展示省略号，规定当文本溢出时，显示省略号来代表被修剪的文本
overflow: hidden;			// 溢出隐藏，文字长度超出限定宽度，则隐藏超出的内容
```

```css
.p {
	width: 400px;	// 必须规定宽或最大宽度
	height: 40px;
	line-height: 40px;
	white-space: nowrap;
	overflow: hiiden;
	text-overflow: ellipsis;
}
```

### 2.多行溢出

```css
display: -webkit-box;			// 元素转换为弹性容器，在一行排列
-webkit-box-orient: vertical；	// 表示盒子对象的子元素的排列方式
-webkit-line-clamp: 3;			// 限制文本的行数，表示文本第几行省略
text-overflow: ellipsis;		// 溢出展示省略号
overflow: hiidden;				// 溢出隐藏
```

```css
.p {
	width: 400px;
	-webkit-line-clamp: 2;
	display: -webkit-box;
	-webkit-box-orient: vertical;
	overflow: hiiden;
	text-overflow: ellipsis;
}
```

## 十一、生成固定宽高比的盒子

### 1.padding-top

在Chrome88之前不支持`aspect-ratio`的时候，主要的方案是使用`padding-top`或`padding-bottom`来生成固定宽高比的盒子。

此方案也被称为`Padding-Top Hack`。该解决方案需要一个**父容器**和一个**绝对放置的子容器**。然后，可以将宽高比计算为百分比以设置为`padding-top`：

- 1：1长宽比= 1/1 = 1 = `padding-top: 100%`
- 4：3长宽比= 3/4 = 0.75 = `padding-top: 75%`
- 3：2长宽比= 2/3 = 0.66666 = `padding-top: 66.67%`
- 16：9长宽比= 9/16 = 0.5625 = `padding-top: 56.25%`

```html
<div class="container">
	<img class="media" src=""/>
</div>
```

```css
.container {
	position: relative;
	width: 100%;
	padding-top: 100%;	// 1:1 aspect ratio
}

.media {
	position: absolute;
	top: 0;
    width: 100%;
    height: 100%;
    background: blue;
}
```

![image-20231219195301731](https://gitee.com/v876774538/my-img/raw/master/image-20231219195301731.png)

### 2.aspect-ratio

```css
body {
    margin: 0;
}

.container {
    position: relative;
    width: 100%;
    aspect-ratio: 1 / 1;
}

.media {
    position: absolute;
    top: 0;
    width: 100%;
    height: 100%;
    background: blue;
}
```

## 十二、块级元素、行内元素和行内块的区别

### 1.块级元素(block)

- 占据一行；

- 高度、行高以及内外边距都可以设置；

- 宽度默认为它容器的100%；

- 可以容纳内联元素和其他块元素。

  常见块级元素：`div`、`h1`、`p`

### 2.行内元素(inline)

- 和其他元素共享一行；

- 高、行高以及内外边距均不可改变；

- 宽度就是其文字或图片的宽度，由内容撑开，不可改变。

  常见行内元素：`i`、`span`、`a`

### 3.行内块元素(inline-block)

- 和其他元素共享一行

- 行高以及内外边距都可以改变。

  常见行内块元素：`button`、`img`、`input`

## 十三、link和import的区别

```css
<style>
	/*每个页面公共css */
	@import url("./common/common.less");

	...
</style>
```

```html
<link rel="shortcut icon" href="https://img.alicdn.com/tps/i4/TB1_oz6GVXXXXaFXpXXJDFnIXXX-64-64.ico" type="image/x-icon"/>
<link rel="stylesheet" href="https://g.alicdn.com/thx/cube/1.3.2/cube.min.css">
<link rel="stylesheet" href="demo.css">
<link rel="stylesheet" href="iconfont.css">
```

### 1.从属关系区别

- `@import`是CSS提供的语法规则，只有导入样式表的作用；
- `link`是HTML提供的标签，不仅可以加载CSS文件，还可以定义RSS、rel连接属性等。

### 2.加载顺序区别

- 加载页面时，`link`标签引入的CSS被同时加载；
- `@import`引入的CSS将在**页面加载完毕后被加载**。

### 3.兼容性区别

- `@import`是CSS2.1才有的语法，故只可在IE5+被识别；
- `link`标签作为HTML元素，不存在兼容性问题。

### 4.DOM可控性区别

- 可以通过JS操作DOM，插入`link标签`来改变样式；
- 由于DOM方法是基于文档的，无法使用`@import`的方式插入样式。



# js

## 一、引用类型和基本类型的区别

### 1.总结

在js中把我们的数据进行了分类，可以理解为两大类：

- **基本数据类型**：`string`、`number`、`null`、`Boolean`、`undefind`、`symbol`
- **应用数据类型**：`Object`、`Array`、`Function`

> 区别：**基本数据类型保存在栈里**，可以**直接访问**它的值；而**引用数据类型保存在堆中**，栈里保存的是访问它们的**地址**，访问时通过地址访问堆中的值。

### 2.如何判断数据类型

- `typeof`：判断的粒度较粗，它能准确判断基础类型（不包括`null`）以及`Object`和`Function`，转而言之，它不能判断`null`和`Array`，会将它们都判断为`Object`。

- `instanceof`：用来判断对象的更具体的类型。instanceof的模拟实现，它的主要原理是沿着对象的原型链的方向，判断原型对象是否是构造器的prototype。

- `Array.isArray`：专门用来判断**是否为数组**。

- `Function.prototype.toString.call`：最全面的方法，代码运行如下

  ```js
  // 以数组为例
  Function.prototype.toString.call([])	// [object Array]
  ```

  返回结果是一个**字符串**

  ```js
  Object.prototype.toString.call([]).slice(8, -1).toLowerCase()	// 可以得到具体的类型，代码中的-1表示倒数第一个元素
  ```

  ```js
  var arr = ['1', '2']
  var obj = {name: '张三'}
  console.log('判断arr', Object.prototype.toString.call(arr).slice(8, -1).toLowerCase())	// array
  console.log('判断obj', Object.prototype.toString.call(obj).slice(8, -1).toLowerCase())	object
  ```

### 3.基本类型

#### 3.1 Number

数值最常见的整数类型为十进制，还可以设置八进制（0开头）、十六进制（0x开头）

```js
let intNum = 55
let octNum = 070
let hexNum = 0xa
```

浮点类型在数值中必须包含小数点

```js
let floatNum1 = 1.1
let floatNum2 = 0.1
let floatNum3 = .1
let floatNum4 = 3.125e7
console.log(floatNum1, floatNum2, floatNum3, floatNum4)	// 1.1 0.1 0.1 31250000
```

在数值类型中，存在一个特殊数字`NaN`，意为不是数值。用于**表示本来要返回数值的操作失败**了。

```js
console.log(0 / 0)	// NaN
console.log(-0 / +0)	// NaN
```

#### 3.2 String

字符串可以使用双引号`""`、单引号`''`或反引号`表示。

```js
let firstName = 'John'
let lastName = 'Jacob'
let lastName = `Jingleheimerschmidt`
```

字符串一旦创建，它们的值**是不可变的**。

```js
let lang = 'Java'
lang = lang + 'Script' // 先销毁再创建
```

#### 3.3 Boolean

布尔型`Boolean`有两个字面值：true/false。

通过`Boolean`可以将其他类型的数据转换成布尔值：

| 数据类型  | true                  | false        |
| --------- | --------------------- | ------------ |
| String    | 非空字符串            | 空字符串`''` |
| Number    | 非0数值（包括无穷值） | `0`、`NaN`   |
| Object    | 任意对象              | `null`       |
| Undefined | /                     | `undefined`  |

#### 3.4 Undefined

`Undefined`类型只有一个特殊值`undefined`。

当使用`var`或`let`**声明了变量但没有初始化**时，就相当于给变量赋予了`undefined`值。

```js
let message
console.log(message)	// undefined

console.log(age) // 没有声明过这个变量，报错
```

#### 3.5 Null

`Null`类型同样只有一个特殊值`null`。

`null`代表空对象指针，给`typeof`传一个`null`会返回`object`。

```js
let car = null
console.log(typeof car)	// object
```

`undefined`由`null`派生而来，因此：

```js
console.log(null == undefined)	// true
```

#### 3.6 Symbol

`Symbol`（符号）是原始值，且符号实例是唯一、不可变的。

符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。

```js
let genericSymbol = Symbol()
let otherGenericSymbol = Symbol()
console.log(genericSymbol == otherGenericSymbol)    // false

let fooSymbol = Symbol('foo')
let otherFooSymbol = Symbol('foo')
console.log(fooSymbol == otherFooSymbol)    // false
```

### 4.引用类型

#### 4.1 Object

创建`object`常用方式为对象**字面量表示法**，属性名可以是字符串或数值。

```js
let person = {
	name: 'Nicholas',
	age: 29,
	5: true,
}
```

#### 4.2 Array

js中的数组是一组有序的数据，但跟其他语言不同的是，数组中每个槽位**可以存储任意类型的数据**，数组大小也是动态的，会随着**数据添加**而**自动增长**。

```js
let colors = ['red', 2, {age: 20}]
colors.push(2)
console.log(colors)
```

![image-20231222135450705](https://gitee.com/v876774538/my-img/raw/master/image-20231222135450705.png)

#### 4.3 Function

`function`（函数）实际上是对象，每个函数都是`function`类型的实例，而`function`也有属性和方法，跟其他引用类型一样。

函数三种常见的表达方式：

1. 函数声明

   ```js
   function sum(num1, num2) {
   	return num1 + num2
   }
   ```

2. 函数表达式

   ```js
   let sum = function(num1, num2) {
   	return num1 + num2
   }
   ```

3. 箭头函数

   ```js
   let sum = (num1, num2) => {
   	return num1 + num2
   }
   ```

#### 4.4 其他引用类型

除上述三种引用类型外，还包括`Date`、`RegExp`、`Map`、`Set`等……

### 5.存储区别

#### 5.1 基本数据类型

基本数据类型存储在**栈**中，可以直接访问它的值。

```js
let a = 10;
let b = a;	// 赋值
b = 20;
console.log(a)	// 10
```

![img](https://static.vue-js.com/906ffb90-6463-11eb-85f6-6fac77c0c9b3.png)

#### 5.2 引用数据类型

引用数据类型存放在**堆**中，栈中存放它们的**引用地址**。

```js
var obj1 = {}
var obj2 = obj1	// 将obj2的地址指向obj1的堆
obj2.name = 'xxx'
console.log(obj1.name)	// xxx
```

![img](https://static.vue-js.com/a34bdd10-6463-11eb-ab90-d9ae814b240d.png)

## 二、==和===的区别

### 1.总结

- `=`：赋值操作
- `==`：判断二者的值是否相等，相等返回true，反之返回false
- `===`：判断二者是否**全等**（值和类型都相等），相等返回true，反之返回false

### 2.==

js中存在**隐式转换**，操作符`==`在比较中会**先进行类型转换**，再确定操作数是否相等。

- 如果任一操作数是布尔值，则将其转换为数值再比较是否相等

  ```js
  let result = true == 1	// true
  ```

- 如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等

  ```js
  let result = '55' == 55	// true
  ```

- 如果一个操作数是对象，另一个操作数不是，则调用对象的 `valueOf()`方法取得其原始值，再根据前面的规则进行比较

  ```js
  let obj = {
  	valueOf: function() {
  		return 1
  	}
  }
  let result = obj == 1	// true
  ```

- `null`和`undefined`相等

  ```js
  let result = null == undefined // true
  ```

- 如果有任一操作数是`NaN`，则返回`false`

  ```js
  let result = NaN == NaN	// false
  ```

- 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都**指向同一个对象**，则相等操作符返回`true`

  ```js
  let obj1 = {name: 'xxx'}
  let obj2 = {name: 'xxx'}
  let result = (obj1 == obj2)	// false
  ```

由于`==`会进行隐式转换，因此会带来一些**反直觉的结果**：

```js
'' == '0' // false
0 == '' // true
0 == '0' // true

false == 'false' // false
false == '0' // true

false == undefined // false
false == null // false
null == undefined // true

' \t\r\n' == 0 // true
```

### 3.===

全等操作符由三个等号`===`表示，只有两个操作数在**不进行转换**的前提下相等才会返回`true`。

```js
let result1 == '55' === 55	// false
let result2 == 55 === 55	// true
```

`undefined`和`null`与自身严格相等

```js
let result1 = null === null	// true
let result2 = undefined === undefined	// true
```

### 4.a==1 && a==2 && a==3

使`a == 1 && a == 2 && a == 3`成立：

```js
var a = { value: 0 }
a.toString = function() {
	return this.value += 1
}
```

解析：首先`a`是一个对象。判断a值时，存在**对象到数字的转换**。

1. 如果对象具有`valueOf()`方法，后者返回一个原始值，js将这个原始值转换为数字，最后返回该数字；
2. 其次，对象若具有`toString`方法，后者返回一个原始值，则js将这个原始值转换为数字，最后返回该数字；
3. 否则，js将抛出一个类型错误异常。

### 5.a===1 && a===2 && a===3

使`a === 1 && a === 2 &&& a === 3`成立：

```js
var value = 0;
Object.defineProperty(window, 'a', {
	get: function() {
		return this.value += 1
	}
})

console.log(a === 1 && a === 2 && a === 3)
```

## 三、typeof和instanceof的区别

### 1.typeof

`typeof`操作符返回一个**字符串**，表示**未经计算的操作数的类型**。

#### 1.1 使用方法

```js
typeof operand
```

`operand`表示对象或原始值的表达式。

```js
typeof 1	// 'number'
typeof '1'	// 'string'
typeof undefined // 'undefined'
typeof true	// 'boolean'
typeof Symbol()	// 'symbol'
typeof null	// 'object' ←注意
typeof []	// 'object'	←注意
typeof {}	// 'object'
typeof console	// 'object'
typeof console.log	// 'function'
```

#### 1.2 注意事项

`typeof`一般用来判断变量是否存在，返回它的类型。

- 其中基本数据类型`null`返回的是`object`，但并不代表它属于应用数据类型。如果需要在`if`中判断是否为`null`，直接通过`=== null`来判断即可；

- 采用`typeof`判断引用数据类型，除了`function`会被识别之外，其他的都输出为`object`

- 可以使用`typeof`来判断变量是否存在：

  ```js
  if (typeof a != 'undefined') {
  	// 变量存在
  }
  ```

### 2.instanceof

`instanceof`用于检测构造函数的`prototype`属性是否出现在某个实例对象的原型链上。

#### 2.1 使用方法

```js
object instanceof constructor
```

`object`为实例对象，`constructor`为构造函数。

构造函数通过`new`可以实例对象，`instanceof`能判断这个对象是否是之前那个构造函数生成的对象。

```js
// 定义构造函数
let Car = function() {}
let benc = new Car()
benc instanceof Car	// true

let car = new String('xxx')
car instanceof String	// true

let str = 'xxx'
str instanceof String	// false
```

#### 2.2 实现原理参考

顺着原型链查找，直到查找到相同的原型对象，返回`true`，反之返回`false`

```js
function myInstanceof(left, right) {
	// typeof判断基础数据类型 是直接返回false
	if (typeof left != 'object' left === null) {
		return n
	}
	// getProtypeOf是Object对象自带的API，能够拿到参数的原型对象
	let proto = Object.getProtypeOf(left)
	while(true) {
		if (proto === null) {
			return false
		}
		if (proto === right.prototype) {
			return true	// 找到相同原型对象，返回true	
		}
        proto = Object.getPrototypeof(proto)
	}
}
```

### 3.区别

`typeof`与`instanceof`都是判断数据类型的方法，区别如下：

- `typeof`会返回**变量的基本类型**字符串，`instance`则直接返回**布尔值**；
- `instanceof`可以准确地判断复杂应用数据类型，但不能正确判断基础数据类型；
- `typeof`存在弊端：虽然可以判断除null之外的基础数据类型。但是引用数据类型中，除了function类型之外，其他都返回object，无法准确判断。

### 4.全局通用的数据类型判断方法

`Object.prototype.toString`，调用该方法，统一返回格式`[object xxx]`。

```js
Object.prototype.toString({}) // "[object Object]"
Object.prototype.toString.call({}) // 同上结果，加上call也ok
Object.prototype.toString.call(1) // "[object Number]"
Object.prototype.toString.call('1') // "[object String]"
Object.prototype.toString.call(true) // "[object Boolean]"
Object.prototype.toString.call(function () {}) // "[object Function]"
Object.prototype.toString.call(null) //"[object Null]"
Object.prototype.toString.call(undefined) //"[object Undefined]"
Object.prototype.toString.call(/123/g) //"[object RegExp]"
Object.prototype.toString.call(new Date()) //"[object Date]"
Object.prototype.toString.call([]) //"[object Array]"
Object.prototype.toString.call(document) //"[object HTMLDocument]"
Object.prototype.toString.call(window) //"[object Window]"
```

使用`Object.prototype.toString.call([]).slice(8, -1).toLowerCase()`得到具体的数据类型。

```js
function getType(obj) {
  let type = typeof obj
  if (type !== 'object') {
    // 先进行typeof判断，如果是基础数据类型，直接返回
    return type
  }
  // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果
  return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, '$1')
}
```

```js
getType([]) // "Array" typeof []是object，因此toString返回
getType('123') // "string" typeof 直接返回
getType(window) // "Window" toString返回
getType(null) // "Null"首字母大写，typeof null是object，需toString来判断
getType(undefined) // "undefined" typeof 直接返回
getType() // "undefined" typeof 直接返回
getType(function () {}) // "function" typeof能判断，因此首字母小写
getType(/123/g) //"RegExp" toString返回
```

## 四、深拷贝与浅拷贝

### 1.浅拷贝

浅拷贝，即是将一个对象的值复制给另一个对象，若属性是基本类型，拷贝的就是基础类型的值；如果对象中包含对其他对象的引用，则该应用仍然指向**原来对象的地址**。

浅拷贝只**拷贝一层**，深层次的应用类型则共享内存地址。

#### 1.1 简单实现对象浅拷贝

```js
function shallowClone(obj) {
	const newObj = {}
	for(let prop in obj) {
		if (obj.hasOwnProperty(prop)) {
			newObj[prop] = obj[prop]
		}
	}
	return newObj
}
```

备注：`hasOwnProperty()`方法，检测属性是否为对象的自有属性

```js
let obj = {
    name:'张睿',
    age:18,
    eat:{
        eatname:'面条',
        water:{
            watername:'农夫山泉'
        }
    }
}
console.log(obj.hasOwnProperty('name')) //true
console.log(obj.hasOwnProperty('age'))  //true
console.log(obj.hasOwnProperty('eat'))  //true
console.log(obj.hasOwnProperty('eatname'))  //false
console.log(obj.hasOwnProperty('water'))  //false
console.log(obj.hasOwnProperty('watername'))  //false
console.log(obj.eat.hasOwnProperty('eatname'))  //true
console.log(obj.eat.hasOwnProperty('water'))  //true
console.log(obj.eat.hasOwnProperty('watername'))  //false
console.log(obj.eat.water.hasOwnProperty('watername'))  //true
```

#### 1.2 Object.assign

```js
var sourceObj1 = {
    name: 'zs',
    age: 23
}
var sourceObj2 = {
    state: 'single',
    mood: 'happy'
}

var result = Object.assign(sourceObj, sourceObj2)
```

#### 1.3 数组的slice()

`slice()`方法用于数组截取指定元素。该方法不会改变原数组，只会将截取的元素**封装到一个新数组**，**原数组不会改变**。

```js
const fxArr = ['One', 'Two', 'Three']
const fxArrs = fxArr.slice(0)
fxArrs[1] = 'love'
console.log(fxArr)	// ['One', 'Two', 'Three']
console.log(fxArrs)	// ['One', 'love', 'Three']
```

#### 1.4 数组的concat()

`concat()`方法用于连接两个或多个数组。`concat()`方法会将新数组的成员添加到原数组的尾部，并**返回一个新数组**，**原数组不会改变**。

```js
const fxArr = ['One', 'Two', 'Three', { name: 'zhangsan' }]
const fxArrs = fxArr.concat()
fxArrs[1] = 'love'
fxArrs[3].name = 'lisi'
console.log(fxArr) // ["One", "Two", "Three", { name: 'lisi' }]
console.log(fxArrs) // ["One", "love", "Three" { name: 'lisi' }]	// 第二层只引用了地址，因此会一起改变
```

#### 1.5 拓展运算符

```js
const fxArr = ['One', 'Two', 'Three']
const fxArrs = [...fxArr]
fxArrs[1] = 'love'
console.log(fxArr) // ["One", "Two", "Three"]
console.log(fxArrs) // ["One", "love", "Three"]
```

### 2.深拷贝

深拷贝**开辟一个新的栈**，两个对象的属性完全相同，但对应两个不同的地址，修改其中一个对象的属性，不会改变另一个对象的属性值。

#### 2.1 _.cloneDeep()

> Lodash是一个著名的javascript原生库，通过使用其封装的数组、数字、对象、字符串等方法，使javascript变得更加简单。

```bash
npm i -g npm
npm i --save lodash
```

```js
const _ = require('lodash')
const obj1 = {
	a: 1,
	b: { f: { g: 1 } },
	c: [1, 2, 3]
}
const obj2 = _.cloneDeep(obj1)
console.log(obj1.b.f === obj2.b.f)	// false
```

#### 2.2 jQuery.extend()

> `jQuery.extend( [deep ], target, object1 [, objectN ] )`
>
> 深度复制合并对象，第一个参数是boolean类型的true时，将object1, ..., objectN深度复制后合并到target中。

```js
const $ = require('jquery')
const obj1 = {
	a: 1,
	b: { f: { g: 1 } },
	c: [1, 2, 3]
}
const obj2 = $.extend(true, {}, obj1)
console.log(obj1.b.f === obj2.b.f)	// false
```

#### 2.3 JSON.stringify-parse

```js
const obj2 = JSON.parse(JSON.stringify(obj1))
```

这种方式存在一定的弊端：会忽略`undefined`、`symbol`和`函数`。

```js
const obj = {
  name: 'A',
  name1: undefined,
  name3: function () {},
  name4: Symbol('A'),
}
const obj2 = JSON.parse(JSON.stringify(obj))
console.log(obj2) // {name: "A"}
```

#### 2.4 循环递归

```js
function deepClone(obj, hash = new WeakMap()) {
  if (obj === null) return obj // 如果是null或者undefined我就不进行拷贝操作
  if (obj instanceof Date) return new Date(obj)
  if (obj instanceof RegExp) return new RegExp(obj)
  // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝
  if (typeof obj !== 'object') return obj
  // 是对象的话就要进行深拷贝
  if (hash.get(obj)) return hash.get(obj)
  let cloneObj = new obj.constructor()
  // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身
  hash.set(obj, cloneObj)
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      // 实现一个递归拷贝
      cloneObj[key] = deepClone(obj[key], hash)
    }
  }
  return cloneObj
}
```

## 五、作用域链

### 1.作用域

**作用域**，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合。

作用域决定了代码区块中变量和其他资源的可见性。

```js
function myFunction() {
	let inVariable = '函数内部变量'
}
myFunction()
console.log(invariable)	// Uncaught ReferenceError: inVariable is not defined
```

上述例子中，我们在函数`myFunction`内部创建一个`inVariable`变量，当我们在全局访问该变量时，系统报错。这说明我们在全局是无法获取到（闭包除外）函数内部的变量的。

#### 1.1 全局作用域

任何不在函数中或大括号中声明的变量，都是在**全局作用域**下。

全局作用域下声明的变量可以在程序的任意位置访问。

```js
// 全局变量
var greeting = 'Hello World!'
function greet() {
	console.log(greeting)
}

greet()
```

#### 1.2 函数作用域

**函数作用域**也称为局部作用域，如果一个变量是在函数内部声明的，那么它就在一个函数作用域中。

这些变量仅能在函数内部访问。

```js
function greet() {
	var greeting = 'Hello World!'
	console.log(greeting)
}
greet()
console.log(greeting)	// 报错
```

#### 1.3 块级作用域

ES6中引入了`let`和`const`关键字。

与`var`关键字不同的是，在大括号中使用`let`和`const`声明变量，使它们存在于**块级作用域**中，在大括号之外不能访问这些变量。

```js
{
	// 块级作用域
	let greeting = 'Hello World!'
	var lang = 'English'
	console.log(greeting)
}
console.log(lang)	// 'English'
console.log(greeting)	// 报错
```

#### 1.4 词法作用域

词法作用域，又称为静态作用域，它在变量被创建时就确定好了，而非在执行阶段确定。

也就是说我们在编写代码时它的作用域便已确定，`javascript`遵循的就是**词法作用域**。

```js
var a = 2
function foo() {
  console.log(a)	// 输出2
}
function bar() {
  var a = 3
  foo()
}
n()
```

![image-20240108150302672](https://gitee.com/v876774538/my-img/raw/master/image-20240108150302672.png)

### 2.作用域链

当在javascript中使用一个变量时，首先js引擎会尝试在当前作用域下寻找该变量，如果没找到，再到它的上层作用域中寻找，以此类推，直到找到该变量或到达全局作用域。

如果在全局作用域中仍然无法找到该变量，它就会在全局范围内隐式声明该变量（非严格模式）或直接报错。

![image-20240108150742825](https://gitee.com/v876774538/my-img/raw/master/image-20240108150742825.png)

```js
var sex = '男'
function person() {
  var name = '张三'
  function student() {
    var age = 18
    console.log(name) // 张三
    console.log(sex) // 男
  }
  student()
  console.log(age) // Uncaught ReferenceError: age is not defined
}
person()
```

## 六、箭头函数

ES6提出了新语法箭头函数。

`Function`不但承担了函数的功能，还可以当做构造函数来使用，箭头函数最大意义是解放了`Function`的功能，大大简化了`Function`的使用频率。

### 1.基础语法

```js
var a = () => {
	console.log(this)	// window
}
```

### 2.注意事项

与普通函数相比，它：

- 写法更加简洁，这一点在高阶函数的使用中尤为方便，如`map`、`forEach`；
- 箭头函数内部没有自己的`this`，它的`this`指向外层作用域的`this`，不能通过`call`、`apply`、`bind`来修改this指向；
- 件数函数内部没有`arguments`对象，但是ES6配套提供了**剩余参数**用来代替arguments；
- 不能当做构造器使用。

## 七、原型和原型链

### 1.基本概念

1. 隐式原型：所有引用类型（函数、数组、对象）都有`__proto__`属性，例如`arr.__proto__`
2. 显式原型：所有函数拥有`prototype`属性，例如：`func.prototype`
3. 原型对象：**拥有`prototype`属性的对象**，在定义函数时被创建

### 2.`prototype`和`__proto__`

- js中所有**函数**都有一个`prototype`的属性，该属性引用了一个对象，该对象称为原型对象；
- js中每个**对象**都有一个`__proto__`属性：该属性指向它**构造函数的`prototype`**（不同对象之间的**桥梁**）；
- js中每个**对象**都有一个`constructor`属性：指向对象的构造函数

### 3.构造函数

在javascript中，用`new`关键字来调用的函数，称为**构造函数**。构造函数的首字母一般大写。

```js
// 构造函数
function Person() {
	...
}

var person = new Person()	// 创建实例
```

注意：在javascript中的内置对象，如`Object`、`Array`，都是由`Function`构造函数创建的实例。

### 4.举例

```js
// 创建实例
function Person(name) {
	this.name = name
	this.age = 18
	this.sayName = function() {
		console.log(this.name)
	}
}
// 创建实例
var person = new Person('person')
```

根据代码，我们可以得到下图：

![image-20240110103903498](https://gitee.com/v876774538/my-img/raw/master/image-20240110103903498.png)

### 5.总结

1. `__proto__`作为不同对象之间的桥梁，用来**指向创建它的构造函数的原型对象(prototype)**

   ![image-20240110104056000](https://gitee.com/v876774538/my-img/raw/master/image-20240110104056000.png)

2. 每个对象的`__proto__`都指向它的构造函数的原型对象`prototype`

   ```js
   person1.__proto__ === Person.prototype
   ```

3. 构造函数是一个函数对象，是通过`Function`构造器产生的

   ```js
   Person.__proto__ == Function.prototype
   ```

4. 原型对象本身是一个普通对象，而普通对象的构造函数都是`Object`

   ```js
   Person.prototype.__proto__ == Object.prototype
   ```

5. 所有的构造器本质都是函数对象，函数对象都是由`Function`构造产生，因此

   ```js
   Object.__proto__ == Function.prototype
   ```

## 八、闭包

> 闭包是一个可以访问其他函数内部变量的函数，主要作用是**解决变量污染**的问题，也可以用来**延长局部变量的生命周期**。

### 1.概念

一个函数和对其周围状态(lexical environment，词法环境)的引用捆绑在一起，或者说函数被引用包围，这样的组合就是**闭包**(closure)。

也就是说，闭包让你可以**在一个内层函数中访问到其外层函数的作用域**（也可以理解为作为函数内部与外部连接的桥梁）。

**举例**：

```js
function init() {
	var name = 'Mozilla'	// 局部变量
	// 内部函数
	function displayName() {
		alert(name)	// 使用了父函数中声明的变量
	}
	displayName()
}

init()
```

### 2.使用场景

> - 创建私有变量
> - 延长变量的生命周期：一般函数的词法环境在函数返回后就会被销毁，但是闭包会保存对创建时所在词法环境的引用，即便创建时所在的执行上下文被销毁，创建时所在的词法环境仍然存在，以达到延长变量生命周期的目的

**举例**：在页面上添加一些可以调整字号的按钮

```js
function makeSizer(size) {
	return function() {
		document.body.style.fontSize = size + 'px'
	}
}

var size12 = makeSize(12)
var size14 = makeSize(14)
var size16 = makeSize(16)

document.getElementById('size-12').onclick = size12
document.getElementById('size-14').onclick = size14
document.getElementById('size-16').onclick = size16
```

#### 2.1 柯里化函数

柯里化的目的在于避免频繁调用具有相同参数函数的同时，又能够轻松地重用

```js
// 求长方形面积
function getArea(width, height) {
	return width * height
}

// 如果我们碰到的长方形的宽总是10 如
const area1 = getArea(10, 20)
const area2 = getArea(10, 30)
const area3 = getArea(10, 40)
```

```js
// 使用闭包柯里化这个计算面积的函数
function getArea(width) {
	return (height) => {
		return width * height
	}
}

const getTenWidthArea = getArea(10)
// 宽度为10的长方形计算面积
const area1 = getTenWidthArea(20)

// 宽度20
const getTwentyWidthArea = getArea(20)
```

#### 2.2 使用闭包模拟私有方法

在javascript中并不支持声明私有变量，但我们可以使用闭包来模拟私有方法

```js
function makeCounter() {
    var privateCounter = 0

    function changeBy(val) {
        privateCounter += val
    }
    return {
        increment: function () {
            changeBy(1)
        },
        decrement: function () {
            changeBy(-1)
        },
        value: function () {
            return privateCounter
        }
    }
}

var Counter1 = makeCounter()
var Counter2 = makeCounter()
console.log(Counter1.value())   // 0
Counter1.increment()
Counter1.increment()
console.log(Counter1.value())   // 2
Counter1.decrement()
console.log(Counter1.value())   // 1
console.log(Counter2.value())   // 0
```

两个计数器`Counter1`和`Counter2`各自独立，每个闭包都是引用各自词法作用域内的变量`privateCounter`。

每次调用其中一个计数器，通过改变这个变量的值，会改变这个闭包的词法环境。对这个闭包内变量的修改，不会影响到另一个的变量。

#### 2.3 注意事项

> 如果不是某些特定任务需要使用闭包，在其他函数中创建函数是不明智的。因为**闭包在处理速度和内存消耗方面对脚本性能具有负面影响。**

例如，在创建新的对象或者类时，**方法通常应该关联于对象的原型，而不是定义到对象的构造器中**。原因在于每个对象的创建，方法都会被重新赋值。

```js
function MyObject(name, message) {
	this.name = name.toString()
	this.message = message.toString()
	this.getName = function() {
		return this.name
	}
	this.getMessage = function() {
		return this.message
	}
}
```

可以避免使用闭包，修改为如下代码：

```js
function MyObject(name, message) {
	this.name = name.toString()
	this.message = message.toString()
}
// 挂载到MyObject原型对象上
MyObject.prototype.getName = function() {
	return this.name
}
MyObject.prototype.getMessage = function() {
	return this.message
}
```

## 九、内存泄露

内存泄露一般是指变量的内存没有及时回收，导致内存资源浪费的问题。

### 1.概念

> **内存泄露**(Memory leak)是指在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存。并不是说内存在物理上消失，而是应用程序分配某段内存之后，由于设计错误，导致**在释放该段内存之前就失去了对该段内存的控制**，从而造成内存浪费。

在C语言中，由于是手动管理内存，内存泄露是经常出现的事情：

```c
char * buffer;
buffer = (char*) malloc(42);	// 申请内存

// Do something with buffer

free(buffer)	// 释放内存
```

大多数语言提供自动内存管理，以减轻程序员的负担，这被称为“**垃圾回收机制**”。

### 2.垃圾回收机制

> javascript具有**自动垃圾回收机**制(Garbage Collecation, GC)，也就是说，执行环境会负责管理代码执行过程中使用的内存。

原理：垃圾收集器会**周期性**地找出那些不再继续使用的变量，并释放其内存。

#### 2.1 标记清除

javascript中最常用的垃圾回收机制。

当变量进入执行环境时，就标记这个变量为“**进入环境**”，进入环境的变量所占用的内存不会被释放；当变量离开环境时，则将其标记为“**离开环境**”，等待回收。

```js
var m = 0, n = 9;	// m, n, add标记为进入环境
add(m, n)	// a, b, c标记为进入环境
console.log(n)	// a, b, c标记为离开环境，等待垃圾回收
function add(a, b) {
	a++
	var c = a + b
	return c
}
```

#### 2.2 引用计数

语言引擎有一张“引用表”，保存了内存里面的所有资源（通常是各种值）的引用次数。若一个值的引用次数是0，那么久表示这个值不会再用到了，可以将这块内存释放。

如果该值不再需要，但其引用次数却不为0，垃圾回收机制无法释放这块内存，就会导致内存泄露：

```js
const arr = [1, 2, 3, 4]	// arr声明引用次数1 却未被使用 将会导致内存泄露
console.log('Hello world!')
```

```js
// 若需要arr这块内存被垃圾回收机制释放 只需要：
arr = null
```

### 3.常见内存泄露情况

#### 3.1 意外的全局变量

```js
function foo(arg) {
	bar = 'this is a hidden global variable'
}
```

另一种意外的全局变量可能由`this`创建：

```js
function foo() {
	this.variable = 'potential accidental global'
}

foo()	// foo调用 this指向了全局对象window
```

使用**严格模式**，可以避免意外的全局变量。

#### 3.2 定时器

```js
var someResource = getData()
setInterval(function() {
	var node = document.getElementById('Node')
	if (node) {
		node.innerHTML = JSON.stringify(someResource);
	}
}, 1000)
```

就算id为`Node`的元素从`DOM`中移除，该定时器也会存在，同时，因为回调函数中对`someResource`的引用，定时器之外的`someResource`也不会被释放。

> 同理包括使用事件监听`addEventListener`监听，在不监听的情况下需要使用`removeEventListener`取消事件监听。

#### 3.3 闭包

维持函数内局部变量，使其得不到释放

```js
function bindEvent() {
	var obj = document.createElement('xxx')
	var unused = function() {
		console.log(obj, '闭包内引用obj obj不会被释放')
	}
	obj = null	// 解决方法
}
```

#### 3.4 没有清理对DOM元素的引用

```js
const refA = document.getElementById('refA')
document.body.removeChild(refA)	// 删除DOM
console.log('refA', refA)	// 还存在引用能打印出refA的值 没有释放内存

refA = null
console.log('refA', refA)	// 解除引用
```

## 十、bind-call-apply的区别

### 1.作用

`call`、`apply`、`bind`作用是改变函数执行时的上下文，即改变函数运行时`this`的指向。

```js
const name = 'lucy'
const obj = {
	name: 'martin',
	say: function() {
		console.log(this.name)
	}
}
obj.say()	// martin this指向obj对象
setTimeout(obj.say, 0)	// lucy this指向window对象
```

`setTimeout`定时器作为回调函数执行，因此会回到主栈，执行时是在全局上下文环境中执行的，此时的`this`指向`window`。

```js
// bind改变this指向
setTimeout(obj.say.bind(obj), 0)	// martin this指向obj对象
```

### 2.区别

#### 2.1 apply

`apply`接受两个参数，第一个参数是`this`的指向，第二个参数是函数接受的参数，以**数组**的形式传入。改变`this`指向后**原函数会立即执行**，且此方法只会**临时改变`this`指向一次**。

```js
function fn(...args) {
	console.log(this, args)
}
let obj = {
    myname: '张三'
}

fn.apply(obj, [1, 2])	// obj [1, 2]
fn(1, 2)	// window [1, 2]
```

![image-20240110160130405](https://gitee.com/v876774538/my-img/raw/master/image-20240110160130405.png)

注意：若this指向为`null`或`undefined`的时候，默认指向`window`(在浏览器中)

```js
fn.apply(null, [1, 2]) // this指向window
fn.apply(undefined, [1, 2]) // this指向window
```

#### 2.2 call

`call`方法的第一个参数也是`this`的指向，后面传入的参数是一个**参数列表**。

与`apply`一样，改变`this`指向后，原函数会立即执行，且此方法只是临时改变`this`指向一次。

```js
function fn(...args) {
	console.log(this, args)
}
let obj = {
	myname: '张三',
}

fn.call(obj, 1, 2)	// obj [1, 2]
fn(1, 2)	// window [1, 2]
```

注意：同样的，当第一个参数为`null`、`undefined`的时候，默认指向`window`(在浏览器中)

```js
fn.call(null, [1, 2]) // this指向window
fn.call(undefined, [1, 2]) // this指向window
```

#### 2.3 bind

`bind`方法与`call`十分相似，第一个参数指定`this`指向，后面传入的参数也是一个参数列表，但这个参数列表可以**分多次传入**。

改变`this`指向后不会立即执行，而是**返回一个永久改变`this`指向的函数**。

```js
function fn(...args) {
	console.log(this, args)
}
let obj = {
	myname: '张三'
}

const bindFn = fn.bind(obj)	// 返回一个永久改变了this的函数
bindFn(1, 2)	// obj [1, 2]
fn(1, 2)	// window [1, 2]
```

### 3.实现

`bind`的实现步骤，可以分解为**三部分**：

1. 修改`this`指向

2. 动态传递参数

   ```js
   // 方式1：只在bind中传递函数参数
   fn.bind(obj, 1, 2)()
   
   // 方式2：在bind中传递函数参数，也在返回函数中传递参数
   fn.bind(obj, 1)(2)
   ```

3. 兼容`new`关键字

   ```js
   Function.prototype.myBind = function (context) {
     // 判断调用对象是否为函数
     if (typeof this !== 'function') {
       throw new TypeError('Error')
     }
   
     // 获取参数
     const args = [...arguments].slice(1),
       fn = this
   
     return function Fn() {
       // 根据调用方式，传入不同绑定值
       return fn.apply(this instanceof Fn ? new fn(...arguments) : context, args.concat(...arguments))
     }
   }
   ```

## 十一、继承

js实现继承的方式有很多种，比如`原型链继承`、`借用构造函数继承`、`组合继承`、`寄生继承`、`寄生组合继承`、ES6新增的`extends`继承。

### 1.概念

继承(inheritance)是面向对象技术当中的一个概念。

若一个类别B继承自另一个类别A，就把这个B称为A的**子类**，把A称为B的**父类**，也可以说A是B的**超类**。

继承的**优点**：

- 继承可以使得子类拥有父类的各种属性和方法，而不需要再次编写相同的代码；
- 在子类继承父类的同时，可以重新定义某些属性，并重写某些方法（覆盖），使其在父类的基础上获得与父类不同的功能；

```js
// 车（父）
class Car {
	constructor(color, speed) {
		this.color = color
		this.speed = speed
		...
	}
}
```

```js
// 货车（子）
class Truck extends Car {
    constructor(color, speed) {
        super(color, speed)
        this.Container = true	// 货箱
    }
}
```

### 2.继承方式

![image-20240110163239892](https://gitee.com/v876774538/my-img/raw/master/image-20240110163239892.png)

#### 2.1 原型链继承

```js
function Parent() {
	this.name = 'parent1'
	this.play = [1, 2, 3]
}

function Child() {
	this.type = 'child2'
}

Child.prototype = new Parent()
console.log(new Child())
```

![image-20240110163903830](https://gitee.com/v876774538/my-img/raw/master/image-20240110163903830.png)

**注意**：

```js
function Parent() {
	this.name = 'parent1'
	this.play = [1, 2, 3]
}

function Child() {
	this.type = 'child2'
}

Child.prototype = new Parent()
var s1 = new Child()
var s2 = new Child()
s1.play.push(4)	// 改变s1的play属性
console.log('s1', s1.play, 's2', s2.play)	// s1 (4) [1, 2, 3, 4] s2 (4) [1, 2, 3, 4]
// s2的play属性也随之改变
```

两个实例使用的是同一个原型对象，其内存空间是共享的。

#### 2.2 构造函数继承

借助`call`调用`Parent`函数

```js
function Parent() {
	this.name = 'parent1'
}

// 往Parent原型对象上挂载方法
Parent.prototype.getName = function() {
	return this.name
}

function Child() {
	Parent.call(this)
	this.type = 'child'
}

let child = new Child()
console.log(child)
console.log(child.getName())	// 报错
```

![image-20240110170530088](https://gitee.com/v876774538/my-img/raw/master/image-20240110170530088.png)

父类的原型对象中，一旦存在父类之前自己定义的方法，那么子类将无法继承这些方法。

相比原型链继承，**父类的引用属性不会被共享**，但是只能继承父类的实例属性和方法，**不能继承其原型属性或方法**。

#### 2.3 组合继承

结合了**原型链继承**与**构造函数继承**。

```js
function Parent3() {
  this.name = 'parent3'
  this.play = [1, 2, 3]
}

Parent3.prototype.getName = function () {
  return this.name
}
function Child3() {
  // 第二次调用 Parent3()
  Parent3.call(this)
  this.type = 'child3'
}

// 第一次调用 Parent3()
Child3.prototype = new Parent3()
// 手动挂上构造器，指向自己的构造函数
Child3.prototype.constructor = Child3
var s3 = new Child3()
var s4 = new Child3()
s3.play.push(4)
console.log(s3.play, s4.play) // 不互相影响
console.log(s3.getName()) // 正常输出'parent3'
console.log(s4.getName()) // 正常输出'parent3'
```

注意：`Parent3`执行了两次，造成了多构造一次的性能开销。

#### 2.4 原型式继承

主要借助`Object.create`方法实现普通对象的继承。

```js
let parent4 = {
    name: 'parent4',
    friends: ['p1', 'p2', 'p3'],
    getName: function () {
        return this.name
    }
}

// Object.create() 静态方法以一个现有对象为原型 创建一个新对象
let person1 = Object.create(parent4)
person1.name = 'tom'
person1.friends.push('jerry')

let person2 = Object.create(parent4)
person2.name = 'nancy'
person2.friends.push('lucy')

console.log(person1.name)   // tom
console.log(person1.name == person1.getName())  // true
console.log(person1.friends)    // ["p1", "p2", "p3","jerry","lucy"]

console.log(person2.name)   // nancy
console.log(person2.friends)    // ["p1", "p2", "p3","jerry","lucy"]	// 相互印象
```

注意：由于`Object.create`方法实现的是**浅拷贝**，多个实例的引用类型属性指向相同的内存，存在篡改的可能。

#### 2.5 寄生式继承

寄生式继承在原型式继承的基础上进行优化，利用浅拷贝的能力进行增强，添加一些方法。

```js
let parent5 = {
	name: 'parent5',
	friends: ['p1', 'p2', 'p3'],
	getName: function() {
		return this.name
	}
}

function clone(origin) {
	let clone = Object.create(origin)
	clone.getFriends = function() {
		return this.friends
	}
	return clone
}

let person1 = clone(parent5)

console.log(person1.getName())	// parent5
console.log(person1.getFriends())	// ['p1', 'p2', 'p3']
```

注意：缺点与原型式继承相同。

#### 2.6 寄生组合式继承

所有继承方式里面**相对最优**的继承方式。

```js
function clone(parent, child) {
	// 改用Object.create 减少组合继承中多进行一次构造的过程
    child.prototype = Object.create(parent.prototype)
    child.prototype.constructor = child
}

function Parent6() {
    this.name = 'parent6'
    this.play = [1, 2, 3]
}

Parent6.prototype.getName = function() {
    return this.name
}

function Child6() {
    Parent6.call(this)
    this.friends = 'child6
}

clone(Parent6, Child6)

Child6.prototype.getFriends = function() {
    return this.friends
}

let person6 = new Child6()
console.log(person6) //{friends:"child5",name:"child5",play:[1,2,3],__proto__:Parent6}
console.log(person6.getName()) // parent6
console.log(person6.getFriends()) // child5
```

#### 2.7 **extends**

`ES6`提供的`extends`关键字可以直接实现`javascript`继承（实际实现采用的也是寄生组合继承的方式）。

> `class`类补充说明：
>
> 类是用于**创建对象的模板**。
>
> 使用`class`关键字来创建一个类，类体放在一对大括号`{}`中，我们可以在`{}`中定义类成员的位置，如方法或构造函数。
>
> 每个类中包含了一个特殊方法`constructor()`。它是类的**构造函数**，这种方法用于**创建和初始化**一个由`class`创建的对象。
>
> - 在ES6中，class类作为对象的模板被音容，可以通过class关键字定义类；
> - class的本质是`function`；
> - 它可以看做一个语法糖，让对象原型的写法更加清晰、面向对象编程的语法；
> - 类不可以重复声明；
> - 类定义不会被提升，这意味着必须在访问前对类进行定义。

```js
class Person {
	constructor(name) {
		this.name = name
	}
	// 原型方法
	// Person.prototype.getName = function() {}
	// 简写
	getName = function() {
		console.log('Person:', this.name)
	}
}

class Gamer extends Person {
	constructor(name, age) {
		super(name)
		this.age = age
	}
}

const asuna = new Gamer('Asuna', 20)
asuna.getName()	// 成功访问到父类的方法
```

### 3.总结

![img](https://fanyouf.gitee.io/interview/assets/img/0df74700-731c-11eb-ab90-d9ae814b240d.9569f832.png)

## 十二、new操作符

### 1.概述

在`Javasrcipt`中，`new`操作符用于创建一个给定构造函数的**实例对象**。

```js
function Person(name, age) {
	this.name = name
	this.age = age
}

Person.prototype.sayName = function() {
	console.log(this.name)
}
const person1 = new Person('Tom', 20)
console.log(person1)	// Person { name: 'Tom', age: 20 }
person1.sayName()	// Tom
```

`new`通过构造函数`Person`创建出来的实例可以访问到构造函数中的属性及构造函数原型链中的属性。

在构造函数中显式地加上返回值，并且这个返回值是一个**原始类型**：

```js
function Test(name) {
	this.name = name
	return 1
}
const t = new Test('xxx')
console.log(t)	// { "name": "xxx" }	// 返回的是对象
console.log(t.name)	// xxx
```

可以发现，构造函数中返回一个原始值，然而这个**返回值并没有作用**。

下面在构造函数中返回一个**对象**：

```js
function Test(name) {
	this.name = name
	console.log(this) // Test { name: 'xxx' }
	return { age: 26 }
}
const t = new Test('xxx')
console.log(t) // { age: 26 }
console.log(t.name) // 'undefined'
```

### 2.流程

`new`关键字主要做了以下工作：

- 创建一个新对象`obj`；
- 将对象与构建函数**通过原型链连接**起来；
- 将构建函数中的`this`绑定到新建的对象`obj`上；
- 根据构建函数返回类型做判断，如果是原始值则被忽略，若返回对象需要正常处理

![image-20240115153748554](https://gitee.com/v876774538/my-img/raw/master/image-20240115153748554.png)

### 3.手写new操作符

```js
function myNew(Func, ...args) {
	// 创建一个新对象
	const obj = {}
	// 新对象原型指向构造函数原型对象
	obj.__proto__ == Func.prototype
	// 将构建函数的this指向新对象
	let result = Func.apply(obj, args)
	// 根据返回值判断
	return result instanceof Object ? result : obj
}
```

## 十三、数组常用方法

### 1.操作方法

数组基本操作可以归纳为`增`、`删`、`改`、`查`。

#### 1.1 增

- `push()`

  `push()`方法接收任意数量的参数，并将它们添加到**数组的末尾**，返回数组的最新**长度**。

  ```js
  let colors = []
  let count = colors.push('red', 'green')
  console.log(count)
  console.log(colors)
  ```

- `unshift()`

  `unshift()`方法在**数组的开头**添加任意多个值，返回数组的最新**长度**。

  ```js
  let colors = new Array()
  let count = colors.unshift('red', 'green')
  console.log(count)
  console.log(colors)
  ```

- `splice()`

  `splice()`方法传入三个参数，分别是开始位置、要删除的元素数量、插入的元素，返回**空数组**。

  ```js
  let colors = ['red', 'green', 'blue']
  let removed = colors.splice(1, 0, 'yellow', 'orange')	// 0 不删除 在1的位置上添加yellow orange
  console.log(colors) // red,yellow,orange,green,blue
  console.log(removed) // []
  ```

- `concat()`

  `concat()`首先会创建一个当前数组的副本，然后把它的参数添加到**副本末尾**，最后**返回这个新构建的数组，不会影响原数组**。用于**连接两个或多个数组**。

  ```js
  let colors = ['red', 'green', 'blue']
  let colors2 = colors.concat('yellow', ['black', 'brown'])
  console.log(colors) // ["red", "green","blue"]
  console.log(colors2) // ["red", "green", "blue", "yellow", "black", "brown"]
  ```

#### 1.2 删

- `pop()`

  `pop()`方法用于**删除数组的最后一项**（将最后一项pop出来），同时减少数组的`length`值，返回**被删除的项**。

  ```js
  let colors = ['red', 'green']
  let item = colors.pop() // 取得最后一项
  console.log(item) // green
  console.log(colors)	// red
  console.log(colors.length) // 1
  ```

- `shift()`

  `shift()`方法用于**删除数组的第一项**，同时减少数组的`length`值，返回**被删除的项**。

  ```js
  let colors = ['red', 'green']
  let item = colors.shift() // 取得第一项
  console.log(item) // red
  console.log(colors)	// green
  console.log(colors.length) // 1
  ```

- `splice()`

  `splice()`方法传入两个参数，分别是**起始位置，删除元素的数量**。返回**删除元素的数组**。

  ```js
  let colors = ['red', 'green', 'blue']
  let removed = colors.splice(0, 1) // 删除第一项
  console.log(colors) // green,blue
  console.log(removed) // red，只有一个元素的数组
  ```

- `slice()`

  `slice()`方法截取，用于创建一个包含原有数组中一个或多个元素的新数组，不会影响原始数组。

  ```js
  let colors = ['red', 'green', 'blue', 'yellow', 'purple']
  let colors2 = colors.slice(1)	// 从索引位置1开始截取
  let colors3 = colors.slice(1, 4)	// 截取位置[1, 4)
  console.log(colors) // red,green,blue,yellow,purple
  concole.log(colors2) // green,blue,yellow,purple
  concole.log(colors3) // green,blue,yellow
  ```

#### 1.3 改

- `splice()`

  `splice()`方法传入三个参数，分别是开始位置，要删除元素的数量，要插入的任意多个元素，返回删除元素的数组，对原数组产生影响。

  ```js
  let colors = ['red', 'green', 'blue']
  let removed = colors.splice(1, 1, 'red', 'purple') // 插入两个值，删除一个元素
  console.log(colors) // red,red,purple,blue
  console.log(removed) // green，只有一个元素的数组
  ```

#### 1.4 查

- `indexOf()`

  `indexOf()`返回要查找的**元素在数组中的位置**，如果**没找到则返回-1**。

  ```js
  let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]
  numbers.indexOf(4) // 3
  ```

- `includes()`

  `includes()`方法返回要查找的元素在数组中的位置，找到返回`true`，否则`false`。只能用于判断是否存在。

  ```js
  let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]
  numbers.includes(4) // true
  ```

- `find()`

  `find()`方法返回第一个匹配的元素。

  ```js
  const people = [
    {
      name: 'Matt',
      age: 27,
    },
    {
      name: 'Nicholas',
      age: 29,
    },
  ]
  people.find((element, index, array) => element.age < 28) // // {name: "Matt", age: 27}
  ```

### 2.排序方法

- `reserve()`

  数组反转。会改变原数组。

  ```js
  let values = [1, 2, 3, 4, 5]
  values.reverse()
  console.log(values)	// 5, 4, 3, 2, 1
  ```

- `sort()`

  数组排序，`sort()`方法接受一个比较函数，用于判断哪个值应该排在前面。会改变原数组。

  ```js
  function compare(value1, value2) {
    if (value1 < value2) {
      return -1
    } else if (value1 > value2) {
      return 1
    } else {
      return 0
    }
  }
  let values = [0, 1, 5, 10, 15]
  values.sort(compare)
  alert(values) // 0,1,5,10,15
  ```

  ```js
  let values = [0, 1, 5, 10, 15]
  // 升序
  values.sort((a, b) => {
  	return a - b
  })
  
  // 降序
  values.sort((a, b) => {
  	return b - a
  })
  ```

### 3.转换方法

- `join()`

  `join()`方法接收一个参数，即**字符串分隔符**，返回包含所有项的字符串。

  ```js
  let colors = ['red', 'green', 'blue']
  console.log(colors.join(','))	// red,green,blue
  console.log(colors.join('|'))	// red|green|blue
  ```

### 4.迭代方法

常用来迭代数组的方法，都**不改变原数组**：

- `some()`

  对数组每一项都运行传入的测试函数，如果**至少有一个**元素返回`true`，则这个方法返回`true`。用于判断数组中是否存在满足条件的元素。

  ```js
  let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]
  let someResult = numbers.some((item, index, array) => item > 2)
  console.log(someResult) // true
  ```

- `every()`

  对数组每一项都运行传入的测试函数，如果**所有**元素返回`true`，则这个方法返回`true`。用于判断数组中的元素是否都满足条件。

  ```js
  let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]
  let everyResult = numbers.every((item, index, array) => item > 2)
  console.log(everyResult) // false
  ```

- `forEach()`

  对数组每一项都运行传入的函数，没有返回值。

  ```js
  let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]
  numbers.forEach((item, index, array) => {
    // 执行某些操作
  })
  ```

- `filter()`

  对数组每一项都运行传入的函数，为`true`的项会组成新的数组后返回。用于过滤出满足条件的元素。

  ```js
  let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]
  let filterResult = numbers.filter((item, index, array) => item > 2)
  console.log(filterResult) // 3,4,5,4,3
  ```

- `map()`

  对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的**数组**。

  ```js
  let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]
  let mapResult = numbers.map((item, index, array) => item * 2)
  console.log(mapResult) // 2,4,6,8,10,8,6,4,2
  ```

## 十四、字符串的常用方法

### 1.操作方法

#### 1.1 增

注意：此处的增并非直接增添新内容，而是创建一个字符串副本，再进行操作。

除了常用`+`或`${}`进行的字符串拼接之外，还可以通过`concat()`方法进行拼接。

- `concat()`

  用于将一个或多个字符串拼接成一个新字符串。

  ```js
  let stringValue = 'hello'
  let result = stringValue.concat('world')
  console.log(result)	// helloworld
  console.log(stringValue)	// hello
  ```

#### 1.2 删

以下方法都不会改变原数组。

- `slice()`

- `substr()`

- `substring()`

  ```js
  let stringValue = 'hello world'
  console.log(stringValue.slice(3)) // "lo world"	// 从3位置开始截取
  console.log(stringValue.substring(3)) // "lo world"	// 
  console.log(stringValue.substr(3)) // "lo world"
  console.log(stringValue.slice(3, 7)) // "lo w"
  console.log(stringValue.substring(3, 7)) // "lo w"
  console.log(stringValue.substr(3, 7)) // "lo worl"
  ```


#### 1.3 改

以下方法都不会改变原数组。

- `trim()`、`trimLeft()`、`trimRight()`

  删除字符串前后/前/后所有空格。

  ```js
  let stringValue = ' hello world '
  let trimmedStringValue = stringValue.trim()	// 删除前后所有空格
  console.log(stringValue)	// ' hello world '
  console.log(trimmedStringValue)	// 'hello world'
  ```

- `repeat()`

  接收一个整数参数，表示要将该字符串复制多少次，然后返回拼接所有副本后的结果。

  ```js
  let stringValue = 'na '
  let copyResult = stringValue.repeat(2)	// na na 
  ```

- `padStart()`、`padEnd()`

  复制字符串，如果小于指定长度，则在要求的一边填充字符串，直至满足长度条件。

  ```js
  let stringValue = 'foo'
  console.log(stringValue.padStart(6))	// ' foo'
  console.log(stringValue.padEnd(9, '.'))	// 'foo......'
  ```

- `toLowerCase()`、`toUpperCase()`

  大小写转化。

  ```Js
  let stringValue = 'Hello World'
  console.log(stringValue.toLowerCase())	// 'hello world'
  console.log(stringValue.toUpperCase())	// 'HELLO WORLD'
  ```

#### 1.4 查

除了通过索引的方式获取字符串的值，还可以通过：

- `charAt()`

  返回给定索引位置的字符。

  ```js
  let message = 'abcde'
  console.log(message.charAt(2))	// c
  ```

- `indexOf()`

  查询字符在字符串中的位置，若未找到，返回`-1`。

  ```js
  let stringValue = 'hello world'
  console.log(stringValue.indexOf('o'))	// 4
  ```

- `startWith()`

  查询是否以某个字符串起始，返回布尔值。

  ```js
  let message = 'foobarbaz'
  console.log(message.startWith('foo'))	// true
  console.log(message.startWith('bar'))	// false
  ```

- `includes()`

  查询是否包含某个字符串，返回布尔值。

  ```js
  let message = 'foobarbaz'
  console.log(message.includes('bar'))	// true
  console.log(message.includes('quz'))	// false
  ```

### 2.转换方法

- `split`

  把字符串按照指定的分隔符，拆分成数组中的每一项。

  ```js
  let str = '12+13+34'
  let arr = str.split('+')
  console.log(arr)	// [12, 13, 34]
  ```

### 3.模板匹配方法

- `match()`

  接收一个参数，可以是正则表达式字符串，也可以是`RegExp`对象，返回数组。

  ```js
  let text = 'cat, bat, sat, fat'
  let pattern = '/.at/'	// 匹配以at结尾
  let matches = text.match(pattern)
  console.log(matches[0])	// cat
  ```

- `search()`

  接收一个参数，可以是正则表达式字符串，也可以是`RegExp`对象，找到则返回匹配索引，否则返回`-f`。

  ```js
  let text = 'cat, bat, sat, fat'
  let pos = text.search(/at/)
  console.log(pos) // 1
  ```

- `replace()`

  接收两个参数，第一个参数为匹配的内容，第二个参数未替换的元素（可用函数）。

  ```js
  let text = 'cat, bat, sat, fat'
  let result = text.replace('at', ond)
  console.log(result)	// 'cond, bat, sat, fat'
  ```

## 十五、reduce

### 1.作用

`reduce()`方法将数组缩减为单个值。

`reduce()`方法为数组的每个值（从左到右）执行提供的函数。

函数的返回值储存在**累加器**中。

> 注意：对没有值的数组元素，不执行`reduce()`方法。`reduce()`不会改变原数组。

### 2.语法

```js
array.reduce(function(total, currentValue, currentIndex, arr), initialValue)
```

### 3.参数值

| 参数                                         | 描述                                                         |
| -------------------------------------------- | ------------------------------------------------------------ |
| `function(total, currentValue, index, arr) ` | 必需，为数组中的每一个元素运行的函数。<br />函数参数：<br />`total`：必需。<br />`initialValue`，或函数先前返回的值。 |
| `initialValue`                               | 可选，作为初始值传递给函数的值。                             |

### 4.实例

```js
data(){
    return{
        result: [
            {
                subject: 'math',
                score: 10
            },
            {
                subject: 'chinese',
                score: 20
            },
            {
                subject: 'english',
                score: 30
            }
        ];
    };
},
computed:{
    totalResults(){
        return this.result.reduce((sum, item) => {
            return sum + item.score
        }
    }
}, 0)
```

### 5.简单用法

```js
var arr = [1, 2, 3, 4]
var sum = arr.reduce((x, y) => x + y)	// 求和
var mul = arr.reduce((x, y) => x * y)	// 求积

console.log( sum ); //求和，10
console.log( mul ); //求乘积，24
```

### 6.高级用法

#### 6.1 计算数组中每个元素出现的次数

```js
let names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice'];
 
let nameNum = names.reduce((pre, cur)=>{
  if(cur in pre){
    pre[cur]++
  } else{
    pre[cur] = 1 
  }
  return pre
}, {})
console.log(nameNum); //{Alice: 2, Bob: 1, Tiff: 1, Bruce: 1}
```

#### 6.2 数组去重

```js
let arr = [1, 2, 3, 4, 4, 1]
let newArr = arr.reduce((pre, cur)=>{
    // 数组中不存在
    if(!pre.includes(cur)) {
      return pre.concat(cur)
    } else{
      return pre
    }
}, [])
console.log(newArr);// [1, 2, 3, 4]
```

#### 6.3 将二维数组转化为一维

```js
let arr = [[0, 1], [2, 3], [4, 5]]
let newArr = arr.reduce((pre, cur) =>{
    return pre.concat(cur)
}, [])
console.log(newArr); // [0, 1, 2, 3, 4, 5]
```

## 十六、this理解

### 1.默认绑定

全局环境中定义的函数，函数内部的this指向`window`对象。

```js
// 全局环境定义person函数，内部使用this关键字
var name = 'Jenny'
function person() {
	return this.name	// this指向window
}

console.log(person())	// Jenny
```

注意：**严格模式**下，不能将全局对象用于默认绑定，this会绑定到`undefined`。

### 2.隐式绑定

函数还可以作为某个对象的方法调用，此时this指向的就是这个**上级对象**。

```js
function test() {
	console.log(this.x)
}

var obj = {}
obj.x = 1
obj.m = test

obj.m()	// 1
```

```js
var o = {
	a: 10,
	b: {
		fn: function() {
			console.log(this.a)	// undefined	// this的上一级对象为b b内部并没有定义a变量
		}
	}
}
o.b.fn()
```

特殊情况：

```js
var o = {
  a: 10,
  b: {
    a: 12,
    fn: function () {
      console.log(this.a) //undefined
      console.log(this) //window
    },
  },
}
var j = o.b.fn
j()
```

### 3.new绑定

通过构建函数`new`关键字生成一个实例对象，此时this指向这个实例对象。

```js
function test() {
	this.x = 1
}

var obj = new test()
console.log(obj.x)	// 1
```

特殊情况：

```js
function fn() {
	this.user = 'xxx'
	return {}	// new的过程遇到return一个对象 此时this指向返回的对象
}

var a = new fn()
console.log(a.user)	// undefined
```

```js
function fn() {
	this.user = 'xxx'
	return 1	// new的过程遇到return一个简单类型或null this指向实例对象
}

var a = new fn()
console.log(a.user)	// xxx
```

### 4.显式绑定

`apply()`、`call()`、`bind()`是函数的一个方法，作用是改变函数的调用对象。它的第一个参数就表示改变后的调用这个函数的对象。因此，此时this指向的就是这个函数的第一个参数。

```js
var x = 0
function test() {
	console.log(this.x)
}

var obj = {}
obj.x = 1
obj.m = test
obj.m.apply(obj)	// 1
```

### 5.箭头函数

箭头函数没有自己的this。

箭头函数中所使用的this来自于**函数作用域链**，它的取值遵循普通变量一样的规则，在函数作用域链中一级一级向上。

```js
const obj = {
	sayThis: () => {
		console.log(this)
	}
}
obj.sayThis()	// window

const globalSay = obj.sayThis
globalSay()	// window
```

绑定监听事件：

```js
const button = document.getElementById('btn')
button.addEventListener('click', () => {
	console.log(this === window)	// true
	this.innerHTML = 'clicked button'
})
```

### 6.优先级

> new绑定 ＞ 显式绑定 ＞ 隐式绑定 ＞ 默认绑定

## 十七、高阶函数

### 1.概念

高阶函数是一个**接收函数作为参数**，或**将函数作为返回值**的函数。

例如，`Array.prototype.map`，`Array.prototype.filter`和`Array.prototype.reduce`是语言中内置的一些高阶函数。

闭包的实现与回调函数都属于高阶函数。

## 十八、防抖和节流

### 1.概念

> “防抖就是回城，节流就是放技能。”

- **防抖**

  单位时间内，频繁触发事件，但**只执行最后一次**。触发事件n秒后才执行函数，如果在n秒内又触发了事件，则会重新计算函数执行时间。

- **节流**

  单位时间内，频繁触发事件，但**只执行一次**。n秒后再执行该事件，若在n秒内被重复触发，则重新计时。

  主要应用场景：发送短信验证码。

### 2.实现

#### 2.1 防抖

非立即执行版：

```js
/**
 * 非立即执行防抖函数
 * @param {Function} func 
 * @param {number} delay 
 * @returns 
 */
function debounce(func, delay) {
   let timeout
   return function () {
       const _this = this
       const args = [...arguments]
       if (timeout) {
           clearTimeout(timeout)
       }
       timeout = setTimeout(() => {
           func.apply(_this, args)
       }, delay)
   }
}

```

立即执行版：

触发事件后函数会立即执行，n 秒内触发事件不会执行功能函数下一次调用，n秒后再次触发才会再次执行功能函数。

```js
// 防抖函数，立即执行版本 
function debounce(func, wait) { 
    let timeout; 
    return function () { 
        const context = this; 
        const args = [...arguments]; 
        if (timeout) clearTimeout(timeout); 
        const callNow = !timeout; 
        timeout = setTimeout(() => { 
            timeout = null; 
        }, wait); 
        if (callNow) func.apply(context, args); 
    }; 
}

```

非立即执行与立即执行结合，通过immediate进行判断：

```js
// 防抖函数，合并版本，immediate为true时为立即执行
function debounce(func, wait, immediate) {
let timeout;
    return function () {
      const context = this;
      const args = [...arguments];
      if (timeout) clearTimeout(timeout);
      if (immediate) {
        const callNow = !timeout;
        timeout = setTimeout(() => {
          timeout = null;
        }, wait)
        if (callNow) func.apply(context, args)
      }
      else {
        timeout = setTimeout(() => {
          func.apply(context, args)
        }, wait);
      }
    }
}

```

#### 2.2 节流

定时器写法：

```js
function throttled(fn, delay = 500)	{
	let timmer = null
	return function(...args) {
		if (!timmer) {
			timmer = setTimeout(() => {
				fn.apply(this, args)
				timmer = null
			}, delay)
		}
	}
}
```

时间戳与定时器结合（更精确）：

```js
function throttled(fn, delay) {
	let timer = null
	let starttime = Date.now()
	return function () {
	let curTime = Date.now() // 当前时间
    let remaining = delay - (curTime - starttime) // 从上一次到现在，还剩下多少多余时间
    let context = this
    let args = arguments
    clearTimeout(timer)
    if (remaining <= 0) {
        fn.apply(context, args)
        starttime = Date.now()
    } else {
        timer = setTimeout(fn, remaining)
    }
  }
}
```

**实例**：验证码60s倒计时

```js
// 验证码60s倒计时
verification() {
    const TIME_COUNT = 60;
    if (!this.timer) {
        this.count = TIME_COUNT;
        this.codeShow = false;
        this.timer = setInterval(() => {
            if (this.count > 1 && this.count <= TIME_COUNT) {
                this.count--;
            } else {
                this.codeShow = true;
                clearInterval(this.timer);
                this.timer = null;
            }
        }, 1000)
    }
},
// 获取验证码
getCode() {
    let regPhone = /^1[3456789]\d{9}$/;
    if (this.utils.isNone(this.form.phone)) {
        this.utils.showToast('请输入手机号码');
        return false;
    } else if (!regPhone.test(this.form.phone)) {
        this.utils.showToast('手机号码格式有误');
        return false;
    }
    if (this.codeTouch) {
        return false
    }
    this.codeTouch = true
    this.$request('post', this.APIURL.sendSms, {
        userName: this.form.phone,
        smsType: 'LOGIN'
    }).then((res) => {
        setTimeout(() => {
            this.codeTouch = false
            uni.hideLoading()
        }, 500)
        if (!res.success) {
            this.utils.showToast(res.respMsg);
            return false
        }
        this.verification()
        this.utils.showToast('短信发送成功！')
    })
},
```

## 十九、递归

### 1.递归

递归(Recursion)，在数学与计算机科学中，指在函数在内部调用自身的函数。

一般来说，递归需要有边界条件、递归前进阶段和递归返回阶段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。

**实例**：计算x的n次方。

```js
// 迭代
function pow(x, n) {
	let result = 1
	
	for (let i = 0; i < n; i++) {
		result *= x
	}
	return result
}
```

```js
// 递归
function pow(x, n) {
	if (n == 1) {
		return x
	}
	else {
		return x * pow(x, n - 1)
	}
}
```

### 2.尾递归

尾递归，即在函数尾位置调用自身。尾递归也是递归的一种特殊情况。

在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储，递归次数过多容易造成栈溢出。这时候，我们就可以使用**尾递归**，即**一个函数中所有递归形式的调用都出现在函数的末尾**，对于尾递归来说，由于只存在一个调用记录，所以永远不会发生"栈溢出"错误。

**实例**：实现阶乘。

```js
// 普通递归
function factorial(n) {
    if (n == 1) {
        return 1
    }
    return n * factorial(n - 1)
}

factorial(5)
```

若n等于5，该方法需要执行5次，才返回最终的计算表达式，复杂度为O(n)。每次都要保存这个方法，容易造成栈溢出。

```js
// 尾递归
function factorial(n, total) {
	if (n == 1) {
		return total
	}
	return factorial(n - 1, n * total)
}

factorial(5)
```

可以看到，每一次返回的就是一个新的函数，不带上一个函数的参数，也就不需要储存上一个函数了。尾递归只需要保存一个调用栈，复杂度 O(1)。

### 3.应用场景

#### 3.1 数组求和

```js
function sumArray(arr, total) {
  if (arr.length === 1) {
    return total
  }
  return sumArray(arr, total + arr.pop())
}
```

#### 3.2 斐波那契数列

```js
function factorial2(n, start = 1, total = 1) {
  if (n <= 2) {
    return total
  }
  return factorial2(n - 1, total, total + start)
}
```

#### 3.3 数组扁平化

```js
let a = [1, 2, 3, [1, 2, 3, [1, 2, 3]]]
// 变成
let a = [1, 2, 3, 1, 2, 3, 1, 2, 3]
// 具体实现
function flat(arr = [], result = []) {
  arr.forEach((v) => {
    if (Array.isArray(v)) {
      result = result.concat(flat(v, []))
    } else {
      result.push(v)
    }
  })
  return result
}
```

#### 3.4 数组对象格式化

```js
let obj = {
  a: '1',
  b: {
    c: '2',
    D: {
      E: '3',
    },
  },
}
// 转化为如下：
let obj = {
  a: '1',
  b: {
    c: '2',
    d: {
      e: '3',
    },
  },
}

// 代码实现
function keysLower(obj) {
  let reg = new RegExp('([A-Z]+)', 'g')
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      let temp = obj[key]
      if (reg.test(key.toString())) {
        // 将修改后的属性名重新赋值给temp，并在对象obj内添加一个转换后的属性
        temp = obj[
          key.replace(reg, function (result) {
            return result.toLowerCase()
          })
        ] = obj[key]
        // 将之前大写的键属性删除
        delete obj[key]
      }
      // 如果属性是对象或者数组，重新执行函数
      if (typeof temp === 'object' || Object.prototype.toString.call(temp) === '[object Array]') {
        keysLower(temp)
      }
    }
  }
  return obj
}
```

## 二十、函数缓存

### 1.概念

保存函数的运算结果。

这种做法是典型的**用内存去换取性能**的手段，常用语缓存数据计算结果和缓存对象。

```js
const add = (a, b) => a + b
const calc = memoize(add)	// 函数缓存
calc(10, 20)	// 30
calc(10, 20)	// 30 缓存
```

缓存只是一个临时的数据存储，保存数据以便将来对该数据的请求能够更快地得到处理。

### 2.实现

#### 2.1 基础

实现函数缓存主要依靠**闭包**、**柯里化**、**高阶函数**：

- 闭包

  闭包可以理解为，函数+函数体内可访问的变量总和

  ```js
  ;(function() {
  	var a = 1
  	function add() {
  		const b = 2
  		let sum = b + a
  		console.log(sum)	// 3
  	}
  	add()
  })()
  ```

- 柯里化

  把接受多个参数的函数转换成接受单一参数的函数

  ```js
  // 非函数柯里化
  var add = function(x, y) {
  	return x + y
  }
  add(3, 4)	// 7
  
  // 函数柯里化
  var add2 = function(x) {
      // 返回函数
      return function(y) {
          return x + y
      }
  }
  
  add2(3)(4)	// 7	// 将一个二元函数拆分成两个一元函数
  ```

- 高阶函数

  **接收其他函数作为参数**或**返回其他函数**的函数

  ```js
  function foo() {
  	var a = 2
  	
  	function bar() {
  		console.log(a)
  	}
  	return bar
  }
  
  var baz = foo()
  baz()	// 2
  ```

#### 2.2 原理

实现函数缓存，原理就是把参数和对应的结果数据存在一个对象中，调用时判断参数对应的数据是否已经存在，存在就直接返回对应的结果数据，否则就返回计算结果。

```js
const memoize = function (func, content) {
	let cache = Object.create(null)
	content = content || this
	return (...key) => {
		// 不存在
		if (!cache[key]) {
			cache[key] = func.apply(content, key)
		}
		// 存在
		return cache[key]
	}
}
```

```js
// 调用
const calc = memoize(add)
const num1 = calc(100, 200)
const num2 = calc(100, 200)	// 使用缓存结果
```

## 二十一、柯里化

前文提到，函数柯里化就是把能够**接收多个参数的函数转化为接收单一参数的函数**，并且**返回接收余下参数且返回结果的新函数**的技术。

函数柯里化的主要作用和特点就是**参数复用**、**提前返回**和**延迟执行**。

```js
//柯里化之前
function sum(a,b,c,d,e){
    console.log(a+b+c+d+e)
}
sum(1,2,3,4,5);
//柯里化
function sum1(a){
    return function sum2(b){
        return function sum3(c){
             return function sum4(d){
                 return function sum5(e){
                    console.log(a+b+c+d+e)
                 }
             }
        }
    }
}

sum1(1)(2)(3)(4)(5);
```

多层柯里化代码不美观，可读性较差，我们可以封装一个函数来帮助我们完成柯里化转化：

```js
// 函数柯里化封装（这个封装可以直接复制走使用）
function curry(fn, args) {
    var length = fn.length;
    var args = args || [];
    return function () {
        newArgs = args.concat(Array.prototype.slice.call(arguments));
        if (newArgs.length < length) {
            return curry.call(this, fn, newArgs);
        } else {
            return fn.apply(this, newArgs);
        }
    }
}

//需要被柯里化的函数
function multiFn(a, b, c) {
    return a * b * c;
}

//multi是柯里化之后的函数
var multi = curry(multiFn);
console.log(multi(2)(3)(4));
console.log(multi(2, 3, 4));
console.log(multi(2)(3, 4));
console.log(multi(2, 3)(4));
```

实例：

```js
//校验手机号
function validatePhone(regExp,warn,phone){
  const reg = regExp;
  if (phone && reg.test(phone) === false) {
    return Promise.reject(warn);
  }
  return Promise.resolve();
}

//调用校验
validatePhone(/^(13[0-9]|14[0-9]|15[0-9]|166|17[0-9]|18[0-9]|19[8|9])\d{8}$/,"手机号格式不符",137****1234)
//调用校验
validatePhone(/^(13[0-9]|14[0-9]|15[0-9]|166|17[0-9]|18[0-9]|19[8|9])\d{8}$/,"手机号格式不符",159****6204)
//调用校验
validatePhone(/^(13[0-9]|14[0-9]|15[0-9]|166|17[0-9]|18[0-9]|19[8|9])\d{8}$/,"手机号格式不符",137****2125)
//调用校验
validatePhone(/^(13[0-9]|14[0-9]|15[0-9]|166|17[0-9]|18[0-9]|19[8|9])\d{8}$/,"手机号格式不符",191****5236)
```

```js
//完成柯里化
const curryValid = curry(validatePhone);
const validatePhoneCurry  =curryValid(/^(13[0-9]|14[0-9]|15[0-9]|166|17[0-9]|18[0-9]|19[8|9])\d{8}$/,"手机号格式不符");

//调用柯里化之后的函数
validatePhoneCurry(159****6204);
validatePhoneCurry(137****1234);
validatePhoneCurry(137****2125);
validatePhoneCurry(191****5236);
```

## 二十二、函数式编程

### 1.概念

函数式编程是一种**编程范式**，一种编写程序的方法论。

> 主要的编程范式有三种：**命令式编程**、**声明式编程**和**函数式编程**。

相比命令式编程，**函数式编程**更加**强调程序执行的结果**而非执行的过程，倡导利用若干简单的执行单元让计算结果渐进、逐层推到复杂的运算。

```js
// 命令式编程
var array = [0, 1, 2, 3]
for (let i = 0; i < array.length; i++) {
	array[i] = Math.pow(array[i], 2)
}

// 函数式编程
;[0, 1, 2, 3].map((num) => Math.pow(num, 2))
```

### 2.纯函数

函数式编程旨在尽可能提高代码的无状态性和不变性。

纯函数是对给定的输入返还相同输出的函数，并且要求所有的数据都是不可变的，即**纯函数=无状态+数据不可变**。

![img](https://static.vue-js.com/04f50720-8535-11eb-ab90-d9ae814b240d.png)

```js
let double = (value) => value * 2
```

特性：

- 函数内部传入指定的值，就会返回确定且唯一的值；
- 不会造成超出作用域的变化，例如修改全局变量或引用传递的参数。

```js
// 纯函数
function foo(num1, num2) {
	return num1 * 2 + num2 * num2
}
```

```js
// 非纯函数 修改了全局变量
var name = "abc"
function foo2 () {
    console.log("foo2正在执行，属于其他执行内容")
    name = "qbz"
}
foo2()
```

```js
// 非纯函数 修改了传入的参数
function foo3 (info) {
    info.age = 30
}

var obj1 = { name: '21', age: 100 }
foo3(obj1)
console.log(obj1)  // { name: '21', age: 30 }
```

优点：

- 不依赖外部环境计算，不会产生副作用，提高函数的复用性；
- 可读性更强，函数不管是否是纯函数，都会有一个语义化的名称，便于阅读；
- 可以组装成复杂任务，符合**模块化**概念及**单一职责**原则。

缺点：

- 性能：函数式编程相对于指令式编程，由于会对方法进行过度包装，会产生上下文切换的性能开销；
- 资源占用：在js中为了实现对象状态的不可变，往往会创建新的对象，因此，对垃圾回收产生的压力远超其他编程方式；
- 递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作。

### 3.高阶函数

![img](https://static.vue-js.com/104af1c0-8535-11eb-ab90-d9ae814b240d.png)

高级函数，就是以函数作为输入或者输出的函数被称为高阶函数。

通过高阶函数抽象过程，注重结果：

```js
const forEach = function(arr, fn) {
	for(let i = 0; i < arr.length; i++) {
		fn(arr[i])
	}
}
let arr = [1, 2, 3]
forEach(arr, (item) => {
	console.log(item)
})
```

### 4.组合与管道

#### 4.1 组合

```js
const double = x => x * 2;
const increment = x => x + 1;

const incrementThenDouble = x => double(increment(x))	// (x + 1) * 2
console.log(incrementThenDouble(3));	// 8
```

执行顺序从右往左。

#### 4.2 管道

管道是函数组合的一种变体，从左向右执行。使得数据处理的流程更符合直觉。

```js
const pipeline = (...functions) => input => functions.reduce((acc, fn) => fn(acc), input)

const doubleThenIncrement = pipeline(double, increment);
console.log(doubleThenIncrement(3));	// 7
```

## 二十三、Proxy

### 1.概念

- 定义

  用于定义基本操作的自定义行为。

- 本质

  修改的是程序默认行为，形同于在编程语言层面上做修改，属于**元编程**。

- 元编程

  元编程(Meta Programming)又称为超编译，是指类计算机程序的编写。这类计算机程序编写或操纵其他程序（或自身）作为它们的数据，或者在运行时完成部分本应在编译时完成的工作。

  ```shell
  #!/bin/bash
  # meta program
  echo '#!/bin/bash' >program
  for ((I=1; I<=1024; I++)) do
  	echo "echo $I" >>prorgam
  done
  chmod +x program
  ```

  这段程序每执行一次都会帮我们生成一个名为`program`的文件，文件内容为1024行`echo`。如果手动来编写1024行代码，效率显然低微。

  元编程优点：与手工编写全部代码相比，程序员可以获得更高的工作效率，给程序更大地灵活度去处理新的情况而无需重新编译。

  > `Proxy`亦是如此，用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。

### 2.用法

`Proxy`为构造函数，用来生成`Proxy`实例。

```js
var proxy = new Proxy(target, handler)
```

- `target`：表示要拦截的目标对象（任何类型的对象，包括原生数组、函数，甚至另一个代理）
- `handler`：通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理p的行为

#### 2.1 handler

- get(target,propKey,receiver)：拦截对象属性的读取
- set(target,propKey,value,receiver)：拦截对象属性的设置
- has(target,propKey)：拦截`propKey in proxy`的操作，返回一个布尔值
- deleteProperty(target,propKey)：拦截`delete proxy[propKey]`的操作，返回一个布尔值
- ownKeys(target)：拦截`Object.keys(proxy)`、`for...in`等循环，返回一个数组
- getOwnPropertyDescriptor(target, propKey)：拦截`Object.getOwnPropertyDescriptor(proxy, propKey)`，返回属性的描述对象
- defineProperty(target, propKey, propDesc)：拦截`Object.defineProperty(proxy, propKey, propDesc）`，返回一个布尔值
- preventExtensions(target)：拦截`Object.preventExtensions(proxy)`，返回一个布尔值
- getPrototypeOf(target)：拦截`Object.getPrototypeOf(proxy)`，返回一个对象
- isExtensible(target)：拦截`Object.isExtensible(proxy)`，返回一个布尔值
- setPrototypeOf(target, proto)：拦截`Object.setPrototypeOf(proxy, proto)`，返回一个布尔值
- apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作
- construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作

#### 2.2 Reflect

若需要在`Proxy`内部调用对象的默认行为，建议使用`Reflect`，是`ES6`中操作对象而提供的新`API`。

基本特点：

- 只要`Proxy`对象具有的代理方法，`Reflect`对象全部具有，以静态方法的形式存在
- 修改某些`Object`方法的返回结果，让其变得更合理（定义不存在属性行为的时候不报错而是返回`false`）
- 让`Object`操作都变成函数行为

#### 2.3 get()

`get()`接收三个参数，依次为**目标对象**、**属性名**和`proxy`实例本身（可选）。

```js
var person = {
	name: '张三'
}
var proxy = new Proxy(person, {
	get: function(target, propKey) {
		return Reflect.get(target, propKey)
	}
})

console.log(proxy.name)	// 张三
```

`get()`能**对增删改查进行拦截**，当我们读取数组负数的索引：

```js
function createArray(...elements) {
	let handler = {
		get(target, propKey, receiver) {
            let index = Number(propKey)
            if (index < 0) {
                // 负数索引
                propKey = String(target.lenght + index)
            }
            return Reflect.get(target, propKey, receiver)
        }
	}
    
    let target = []
    target.push(...elements)
    return new Proxy(target, handler)
}

let arr = createArray('a', 'b', 'c')
arr[-1]	// c
```

注意：若一个属性不可配置(configurable)且不可写入(writable)，则`Proxy`不能修改该属性，否则会报错。

```js
// Object.defineProperties(obj, props) 在对象上定义属性
const target = Object.defineProperties(
	{},
	{
		foo: {
			value: 123,
			writable: false,	// 不可写
			configurable: false,	// 不可配置
		}
	}
)

const handler = {
	get(target, handler) {
		return 'abc'
	}
}

const proxy = new Proxy(target, handler)
console.log(proxy.foo)	// TypeError: Invariant check failed
```

#### 2.4 set()

`set()`方法用于拦截某个属性的**赋值**操作。可以接受四个参数，依次为**目标对象**、**属性名**、**属性值**和`proxy`实例本身。

```js
// 限制person对象的age属性为不大于200的整数
let validator = {
	set: function(obj, prop, value) {
		if (prop === 'age') {
			if (!Number.isInteger(value)) {
				throw new TypeError('The age is not an integer')
			}
			if (value > 200) {
				throw new RangeError('The age seems invalid')
			}
		}
		
		// 满足条件的age属性及其他属性，直接保存
		obj[prop] = value
	}
}

let person = new Proxy({}, validator)

person.age = 100
console.log(person.age)	// 100
person.age = 'yound'	// 报错
person.age = 300	// 报错
```

注意：若目标对象自身的某个属性，不可写且不可配置，那么`set`方法将不起作用。

```js
const obj = {}
Object.defineProperty(obj, 'foo', {
	value: 'bar',
	writable: false,
})

const handler = {
	set: function(obj, prop, value, receiver) {
		obj[prop] = 'baz'
        // return true	// 严格模式下，set代理如果没有返回true就会报错
	}
}

const proxy = new Proxy(obj, handler)
proxy.foo = 'baz'
console.log(proxy.foo)	// 'bar'
```

#### 2.5 deleteProperty()

`deleteProperty()`方法用于拦截`delete`操作，如果这个方法抛出错误或返回`false`，当前属性就无法被`delete`命令删除。

```js
var handler = {
	deleteProperty(target, key) {
		invariant(key, 'delete')
		Reflect.deleteProperty(target, key)
		return true
	}
}
function invariant(key, action) {
    if (key[0] === '_') {
        throw new Error('无法删除私有属性')
    }
}

var target = {_prop: 'foo'}
var proxy = new Proxy(target, handler)
delete proxy._prop	// Error：无法删除私有属性
```

注意：目标对象自身的不可配置的属性，不能被`deleteProperty`方法删除，否则报错。

#### 2.6 取消代理

```js
Proxy.revocable(target, handler);
```

### 3.使用场景

`Proxy`功能类似于设计模式中的代理模式，常用功能如下：

- 拦截和监视外部对对象的访问；
- 降低函数或类的复杂度；
- 在复杂操作前对操作进行校验或对所需资源进行管理。

#### 3.1 保障数据类型的准确性

```js
let numericDataStore = {
	count: 0,
	amount: 1234,
	total: 14
}
numericDataStore = new Proxy(numericDataStore, {
	set(target, key, value, proxy) {
		if (typeof value !== 'number') {
			throw Errow('属性只能是number类型')
		}
		return Reflect.set(target, key, value, proxy)
	}
})

numericDataStore.count = 'foo'	// Error: 属性只能是number类型
numericDataStore.count = 333
```

#### 3.2 声明私有属性不允许外界访问

```js
let api = {
	_apiKey: '123abc456def',
	getUsers: function() {},
	getUser: function(userId) {},
	setUser: function(userId, config) {}
}

const RESTRICTED = ['_apiKey']
api = new Proxy(api, {
    get(target, key, proxy) {
        if (RESTRICTED.indexOf(key) > -1) {
            throw Error(`${key}不可访问`)
        }
        return Reflect.get(target, key, proxy)
    },
    set(target, key, value, proxy) {
        if (RESTRICTED.indexOf(key) > -1) {
            throw Error(`${key}不可修改`)
        }
        return Reflect.get(target, key, value, proxy)
    }
})

console.log(api._apiKey)	// 错误
api._apiKey = '987654321'	// 错误
```

## 二十四、Promise

### 1.介绍

#### 1.1 概念

`Promise`译为承诺，是**异步编程**的一种解决方案。

```js
// 传统异步编程解决方案：回调
doSomething(function (result) {
  doSomethingElse(result, function (newResult) {
      doThirdThing(newResult, function (finalResult) {
          console.log('得到最终结果: ' + finalResult)
        },
        failureCallback
      )
    },
    failureCallback
  )
}, failureCallback)	// 形成了经典的回调地狱
```

```js
// 使用Promise
doSomething().then((result) => {
	return doSomethingElse(result)
}).then((newResult) => {
	return doThirdThing(newResult)
}).then((finalResult) => {
	console.log('得到最终结果：' + finalResult)
}).catch(failureCallback)
```

优点：

- 链式操作降低了编码难度；
- 增强代码可读性。

#### 1.2 状态

`Promise`的三种状态：

- `pending`：进行中
- `fulfilled`/`resolved`：已成功
- `rejected`：已失败

#### 1.3 特点

- 对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪种状态。
- 状态改变是不可逆的：一旦状态发生改变（`pending`->`fulfilled`或`pending`->`rejected`），就不会再改变，任何时候都可以得到这个结果。

#### 1.4 流程

![img](https://static.vue-js.com/1b02ae90-58a9-11eb-85f6-6fac77c0c9b3.png)

### 2.用法

`Promise`对象是一个构造函数，用来生成`Promise`实例。

```js
const promise = new Promise(function(resolve, reject) {})
```

- `resolve`函数：将`Promise`对象的状态从“未完成”变为“成功”；
- `reject`函数：将`Promise`对象的状态从“未完成”变为“失败”。

#### 2.1 实例方法

- `then()`

  `then`是实例状态发生改变时的回调函数，第一个参数是`resolved`状态的回调函数，第二个参数是`rejected`状态的回调函数**（一般使用`catch`代替`then`的第二个参数）**。

  `then`方法返回的是一个新的`Promise`实例，所以`Promise`可以链式书写。

  ```js
  getJSON('/posts.json').then(function (json) {
  	return json.post
  }).then(function (post) {
      // ...
  })
  ```

- `catch()`

  `catch()`方法是`.then(null, rejection)`或`.then(undefined, rejection)`的别名，用于指定发生错误时的回调函数。

  ```js
  getJSON('/poset.json').then(function (posts) {
  	// ...
  }).catch(function (error) {
  	// 处理getJSON和前一个回调函数运行时发生的错误
  	console.log('发生错误！', error)
  })
  ```

  `Promise`对象的错误具有**冒泡**的性质，会一直向后传递，直到被捕获为止。

  ```js
  getJSON('/post/1.json').then(function (post) {
      return getJSON(post.commentURL)
  }).then(function (comments) {
      // some code
  }).catch(function (error) {
      // 处理前面三个Promise产生的错误
  })
  ```

- `finally()`

  `finally()`方法用于指定不管`Promise`对象最后状态如何，都会执行的操作。它的返回结果也是一个`Promise`。

  ```js
  promise
  .then(result => {···})
  .catch(error => {···})
  .finally(() => {···});
  ```

#### 2.2 静态方法

- `all()`

  `Promise.all()`方法用于将多个`Promise`实例，包装成一个新的`Promise`实例。

  ```js
  const p = Promise.all([p1, p2, p3])
  ```

  该方法接收一个**数组**（迭代对象）作为参数，数组成员都是`Promise`实例。

  实例`p`的状态由`p1`、`p2`、`p3`共同决定：

  - 只有当三者状态都为`fulfilled`时，`p`的状态才会变成`fulfilled`。此时`p1`、`p2`、`p3`的返回值组成一个数组，传递给p的回调函数；
  - 只要三者中某一个为`rejected`，`p`的状态就会变成`rejected`。此时第一个被`rejected`的实例的返回值，会传递给`p`的回调函数。

  注意：如果作为参数的`Promise`实例，自己定义了`catch`方法，那么它一旦被`rejected`，并不会触发`Promise.all()`的`catch`方法。

  ```js
  const p1 = new Promise((resolve, reject) => {
      resolve('hello')
  }).then((result) => {
      console.log('p1', result)
  }).catch((error) => {
      console.log('p1', error)
  })
  
  const p2 = new Promise((resolve, reject) => {
      throw new Error('p2 报错了')
  }).then((result) => {
      console.log('p2', result)
  }).catch((error) => {
      console.log('p2', error)
  })
  
  Promise.all([p1, p2]).then((result) => {
      console.log('all', result)
  }).catch((error) => {
      console.log('all', error)
  })
  ```

  ![image-20240226151436655](https://gitee.com/v876774538/my-img/raw/master/image-20240226151436655.png)

  ```js
  const p1 = new Promise((resolve, reject) => {
      resolve('hello')
  }).then((result) => {
      console.log('p1', result)
  }).catch((error) => {
      console.log('p1', error)
  })
  
  const p2 = new Promise((resolve, reject) => {
      throw new Error('p2 报错了')
  }).then((result) => {
      console.log('p2', result)
  })
  
  Promise.all([p1, p2]).then((result) => {
      console.log('all', result)
  }).catch((error) => {
      console.log('all', error)
  })
  ```

  ![image-20240226151552970](https://gitee.com/v876774538/my-img/raw/master/image-20240226151552970.png)

  **实例**：等待多个请求完成后进行操作

  ```js
  Promise.all([
      this.$http('post', this.APIURL.userCenter).then(res => {
          console.log('res1', res)
          this.userInfo = Object.assign(this.userInfo, res)
      }),
      this.$http('post', this.APIURL.userConfig).then(res => {
          console.log('res2', res)
          this.userInfo = Object.assign(this.userInfo, res)
      }),
  ]).then(() => {
      uni.hideLoading()
      console.log('promise all', this.userInfo)
      uni.setStorageSync('userInfo', this.userInfo)	// 合并两个接口的用户信息
  })
  ```

  需要使用遍历的情况

  ```js
  modalList: [{
          label: '支付宝',
          val: 'ALI',
          info: '',
          iconUrl: require('@/static/my/withdraw/alipay.png'),
          url: '/pages/my/withdrawSettings/alipay',
          isActive: false,
      },
      {
          label: '银行卡',
          val: 'LG',
          info: '',
          iconUrl: require('@/static/my/withdraw/bankcard.png'),
          url: '/pages/my/withdrawSettings/bankcard',
          isActive: false,
      },
      {
          label: '对公转账',
          val: 'DG',
          info: '',
          iconUrl: require('@/static/my/withdraw/publicTransfer.png'),
          url: '/pages/my/withdrawSettings/publicTransfer',
          isActive: false,
      },
  ], // 渠道列表
  ```

  ```js
  // 渠道配置
  modalInit() {
      var ps = []
      this.modalList.forEach((item, index) => {
          var channel = item.val
          var p = this.cashConfig(item.val, (res) => {
              console.log(item.label, res)
              if (res) {
                  item.isActive = true
                  this.modalFlag = false
                  if (item.label == '支付宝') {
                      item.info = this.userInfo.alipayAccount ? this.userInfo
                          .alipayAccount : ''
                  } else if (item.label == '银行卡') {
                      item.info = this.userInfo.bankName && this.userInfo.bankNo ?
                          `${this.userInfo.bankName}(${this.userInfo.bankNo.slice(-4)})` :
                          ''
                  } else if (item.label == '对公转账') {
                      item.info = this.corporateAccount.name ? this.corporateAccount
                          .name : ''
                  }
              }
          })
          ps.push(p)
      })
      console.log('ps', ps)
  
      Promise.all(ps).then(() => {
          console.log('flag', this.modalFlag)
          // 未开通任何渠道
          if (this.modalFlag) {
              this.utils.showToast('提现渠道未配置，请联系管理员进行配置！')
              setTimeout(() => {
                  uni.navigateBack(1)
              }, 2000)
          }
      })
  },
  // 提现规则
  cashConfig(channel, callback) {
      // 这里需要return Promise
      return this.$http('get', this.APIURL.cashConfig, {
          type: this.type == 1 ? 'balance' : 'bounty',
          channel: channel == 'ALI' ? 'ZFB' : channel
      }).then(res => {
          if (!res.success) {
              this.utils.showToast(res.message);
              return false;
          }
          if (res.data && res.data.cashStatus == 1) {
              this.rule = res.data
              this.modalType = channel
          }
          if (callback) {
              callback(res.data.cashStatus == 1 ? true : false)
          }
      })
  },
  ```

- `race()`

  `Promise.race()`同样是将多个`Promise`实例包装成一个新的`Promise`实例。

  ```js
  const p = Promise.race([p1, p2, p3])
  ```

  只要`p1`、`p2`、`p3`中有一个实例率先发生改变，`p`的状态就跟着改变。率先改变的`Promise`实例的返回值则传递给`p`的回调函数。

  ```js
  const p = Promise.race([
    fetch('/resource-that-may-take-a-while'),
    new Promise(function (resolve, reject) {
      setTimeout(() => reject(new Error('request timeout')), 5000)
    }),
  ])
  
  p.then(console.log).catch(console.error)
  ```

- `allSettled()`

  `Promise.allSettled()`方法接收一组`Promise`实例作为参数，包装成一个新的`Promise`实例。

  只有等到所有这些参数实例都返回结果，**不管是`fulfilled`还是`rejected`**，包装实例才会结束。

  ```js
  const promises = [fetch('/api-1'), fetch('/api-2'), fetch('/api-3')]
  
  await Promise.allSettled(promises)
  removeLoadingIndicator()
  ```

- `resolve()`

  ```js
  Promise.resolve('foo')
  // 等价于
  new Promise((resolve) => resolve('foo'))
  ```

- `reject()`

  ```js
  const p = Promise.reject('出错了')
  // 等同于
  const p = new Promise((resolve, reject) => reject('出错了'))
  
  p.then(null, function (s) {
    console.log(s)	// 出错了
  })
  ```

- `try()`

### 3.使用场景

- 将图片加载写成`Promise`，一旦加载完成，`Promise`的状态就发生变化

  ```js
  const preloadImage = function (path) {
      return new Promise((resolve, reject) => {
          const image = new Image()
          image.onload = resolve
          image.onerror = reject
          image.src = path
      })
  }
  preloadImage('https://segmentfault.com/img/bVbp7k9').then((res) => {
      console.log(res)
  })
  ```

- `all()`实现合并多个请求，汇总所有请求结果

  ```js
  function initLoad() {
    // loading.show() //加载loading
    Promise.all([getBannerList(), getStoreList(), getCategoryList()])
      .then((res) => {
        console.log(res)
        loading.hide() //关闭loading
      })
      .catch((err) => {
        console.log(err)
        loading.hide() //关闭loading
      })
  }
  //数据初始化
  initLoad()
  ```

- `race()`设置图片请求超时

  ```js
  const preloadImage = function (path) {
      return new Promise((resolve, reject) => {
          const image = new Image()
          image.onload = resolve
          image.onerror = reject
          image.src = path
      })
  }
  
  // 延时函数 用于给请求计时
  function timeout() {
  	var p = new Promise((resolve, reject) => {
  		setTimeout(() => {
  			reject('图片请求超时')
  		}, 5000)
  	})
      return p
  }
  
  Promise.race([preloadImage('https://segmentfault.com/img/bVbp7k9'), timeout()]).then((res) => {
  	console.log(res)
  }).catch((err) => {
  	console.log(err)
  })
  ```

- `Promise.all`升级：保证一个promise失败之后，`Promise.all`还能正常收到消息

  ```js
  const promise1 = Promise.resolve(3)
  const promise2 = Promise.reject(new Error('promise2 Error'))
  const promise3 = new Promise((resolve, reject) => {
      setTimeout(resolve, 100, 'foo')
  })
  
  Promise.all([promise1, promise2, promise3].map((p) => {
      p.catch((e) => {
          console.log(p, e)
      }).then((values) => {
          console.log(p, values)
      })
  }))
  ```

  ![image-20240226161041519](https://gitee.com/v876774538/my-img/raw/master/image-20240226161041519.png)

- 接口请求封装：

  ```js
  function http(method,url, data) {
  	return new Promise((resolve, reject) => {
  		if (!method) {
  			method = 'GET'
  		}
  		uni.request({
  			url: config.baseUrl + url,
  			data: data,
  			method: method,
  			header: {
  				'content-type': 'application/json',
  				// 'content-Type': 'application/x-www-form-urlencoded',
  				'Authorization':apiFilter(url)?'Bearer '+uni.getStorageSync('token'):'',
  			},
  			success: (res) => {
  				if(res.data.code == '4000'){
  					this.utils.showToast("请重新登录")
  					setTimeout(()=>{
  						uni.reLaunch({
  							url:'/pages/login/index'
  						})
  					},800)
  					return ;
  				}
  				if(res.statusCode !== 200){
  					this.utils.showToast("抱歉，服务器出错")
  					resolve(res.data)
  					return ;
  				}
  				
  				resolve(res.data)
  			},
  			fail: (res) => {
  				console.log(res)
  				this.utils.showToast("网络连接错误")
  				reject(res)
  			}
  		})
  	})
  }
  ```

## 二十五、工作常用js方法

### 1.给数字加上千分位

```
// 123
// 1,234
// 123,456
// 1,234,567
// 12,345,678
```

#### 1.1 倒序遍历

改良版，可以包含/保留小数。

```js
function numberFilter(num, fix = 2) {
    if (!num) {
        num = 0;
    }
    num = num * 1; // 保证为数字型
    num = num.toFixed(fix); // 转为字符串，默认保留2位小数

    var int = num.slice(0, fix * -1 -1);    // 整数
    var ext = num.slice(fix * -1 -1);   // 小数

    let result = ''; // 存放结果
    // 倒序遍历整数部分
    int = int.split('').reverse();
    int.forEach((v, i) => {
        // 遍历时，后遍历的数需要放在先遍历的数前面
        result = v + result;
        // 每隔3位放入1个逗号
        if (i % 3 === 2 && i !== int.length - 1) {
            result = ',' + result;
        }
    })
    result += ext
    console.log(result);
    return result;
}
```

#### 1.2 分开处理

```js
function numberFilter(num, fix = 2) {
    if (!num) {
        num = 0;
    }
    num = num * 1; // 保证为数字型
    num = num.toFixed(fix); // 转为字符串，默认保留2位小数

    var int = num.slice(0, fix * -1 - 1); // 整数
    var ext = num.slice(fix * -1 - 1); // 小数

    const len = int.length;
    const remainderLen = len % 3; // 长度是3的倍数的剩余部分
    // 取出剩余字符串
    var result = remainderLen ? [int.substring(0, remainderLen)]: [];
    // 对长度是3的倍数的部分做遍历
    for (let i = remainderLen; i < len; i += 3) {
        result.push(int.substring(i, i + 3))
    }
    result = result.join(',') + ext
    console.log(result);
    return result;
}
```

#### 1.3 正则表达式

```js
function numberFilter(num, fix = 2) {
    if (!num) {
        num = 0;
    }
    num = num * 1; // 保证为数字型
    num = num.toFixed(fix); // 转为字符串，默认保留2位小数

    var int = num.slice(0, fix * -1 - 1); // 整数
    var ext = num.slice(fix * -1 - 1); // 小数

    let result = int.replace(/(?<!^)(?=(\d{3})+$)/g, ',');  // 替换后面是1个活多个3个数字且不是开头位置的地方为,
    result += ext;
    console.log(result)
    return result;
}
```

### 2.数组扁平化

数组扁平化是指将一个**多维数组**变为一个**一维数组**。

```js
const arr = [1, [2, [3, [4, 5]]], 6]; // => [1, 2, 3, 4, 5, 6]
```

#### 2.1 flat

```js
const res1 = arr.flat(Infinity);	// Infinity作为深度，展开任意深度的嵌套数组
```

#### 2.2 使用正则

```js
const res2 = JSON.stringify(arr).replace(/\[|\]/g, '').split(',');
```

#### 2.3 使用reduce

```js
const flatten = arr => {
	return arr.reduce((pre, cur) => {
		return pre.concat(Array.isArray(cur) ? flatten(cur) : cur);	
	}, [])
}

const res3 = flatten(arr);
```

#### 2.4 函数递归

```js
const res4= [];
const fn = arr => {
  for (let i = 0; i < arr.length; i++) {
    if (Array.isArray(arr[i])) {
      fn(arr[i]);
    } else {
      res4.push(arr[i]);
    }
  }
}
fn(arr);
```

### 3.数组去重

```js
const arr = [1, 1, '1', 17, true, true, false, false, 'true', 'a', {}, {}];
// => [1, '1', 17, true, false, 'true', 'a', {}, {}]
```

#### 3.1 利用Set

`Set`对象是值的合集(collection)。**集合中的元素只会出现一次**，即集合中的元素是唯一的。

`Array.from()`静态方法从可迭代或类数组对象创建一个新的浅拷贝的数组实例。

```js
console.log(Array.from('foo'));
// Expected output: Array ["f", "o", "o"]

console.log(Array.from([1, 2, 3], (x) => x + x));
// Expected output: Array [2, 4, 6]
```

```js
const res1 = Array.from(new Set(arr))
```

#### 3.2 两层for循环+splice

遍历对比数值，删除相同项。

```js
const unique = function(arr) {
	let len = arr.length;
	for (let i = 0; i < len; i++) {
		for (let j = i + 1; j < len; j++) {
			if (arr[i] === arr[j]) {
				arr.splice(j, 1);	// 删除
				len--;
				j--;	// 保证j的值经过自加后不变
			}
		}
	}
    return arr;
}
```

#### 3.3 利用indexOf或include

遍历旧数组，判断新数组中是否存在该元素，不存在则加入。

```js
// indexOf
const unique = function(arr) {
    let res = [];
    for (let i = 0; i< arr.length; i++) {
        if (res.indexOf(arr[i] === -1)) {
            res.push(arr[i]);	// 若不存在，将数值push进新数组res
        }
    }
    return res;
}

// include
const unique = function(arr) {
    let res = [];
    for (let i = 0; i < arr.length; i++) {
        if (!res.includes(arr[i])) {
            res.push(arr[i]);	// 若不存在，将数值push进新数组res
        }
    }
}
```

#### 3.4 利用Map

```js
const unique4 = arr => {  
  const map = new Map();  
  const res = [];  
  for (let i = 0; i < arr.length; i++) {    
    if (!map.has(arr[i])) {      
      map.set(arr[i], true);
      res.push(arr[i]);    
    }  
  }  
  return res;
}
```

#### 3.5 补充：数组对象去重

```js
var arr = [{
  key: '01',
  value: '西施'
}, {
  key: '02',
  value: '王昭君'
}, {
  key: '03',
  value: '杨玉环'
}, {
  key: '04',
  value: '貂蝉'
}, {
  key: '01',
  value: '西施'
}, {
  key: '01',
  value: '西施'
}];
```

```js
var obj = {};
arr = arr.reduce(function (item, next) {
  obj[next.key] ? '' : obj[next.key] = true && item.push(next);
  return item;
}, []);
console.log(arr); // [{key: "01", value: "西施"},{key: "02", value: "王昭君"},{key: "03", value: "杨玉环"},{key: "04", value: "貂蝉"}]
```

# Vue

## 一、响应式原理

### 1.Vue2响应式原理

`Vue.js`是采用**数据劫持**结合**发布者-订阅者**模式的方式。

通过`Object.defineProperty()`来劫持各个属性的`setter`、`getter`，在**数据变动时发布消息给订阅者**，触发相应的**监听回调**。

基本使用：

```js
// 劫持对象的属性
Object.defineProperty(obj, 'a', {
	set(val) {
		console.log('obj.a被赋值', val)
	},
	get() {
		console.log('obj.a'被访问)
	}
})
```

封装函数：

```js
function defineReactive(obj, key, value) {
	Object.defineProperty(obj, 'a', {
        set(val) {
            console.log('obj.a被赋值', val)
        },
        get() {
            console.log('obj.a'被访问)
        }
    })
}

let obj = { a: 1, b: 2 }
defineReactive(obj, 'a', obj['a'])
```

循环+递归：

```js
function defineReactive(obj, key, value) {
	Object.defineProperty(obj, 'a', {
        set(val) {
            console.log('obj.a被赋值', val)
        },
        get() {
            console.log('obj.a'被访问)
        }
    })
}

let obj = { a: 1, b: 2, c: { c1: 0 }}
function walk(obj) {
    for(let key in obj) {
        let value = obj[key]
        if (typeof value == 'object') {
            walk(value)
        }
        else {
            defineReactive(obj, key, value)
        }
    }
}

walk(obj)
```

存在的问题：

- 深度监听需要**一次性递归**；
- 无法监听对象新增或删除的属性；
- 无法监听数组的元素操作。

### 2.Vue3响应式原理

`Vue3`使用`Proxy`来监控数据的变化。`Proxy`是ES6中提供的功能，其作用为：用于**定义基本操作的自定义行为**（如属性查找、赋值、枚举、函数调用等）。

相对于`Object.defineProperty()`有以下特点：

`Proxy`直接**代理整个对象而非对象属性**。这样只需要做一层代理就可以监听同级结构下所有属性的变化，包括新增属性和删除属性。`Proxy`**可以监听数组的变化**。

`Proxy`可以有效地解决Vue2上面存在的三个问题：

```js
let obj = { a: 1, b: 2, c: { c1: 0 }}

function reactive(obj) {
	return new Proxy(obj, {
        // 对对象的增删改进行拦截
		get(target, key) {
			console.log(key, '被访问')
			let value = target[key]
			if (typeof value === 'object') {
				return reactive(value)
			} else {
				return target[key]
			}
		},
		set(target, key, newValue) {
			target[key] = newValue
			console.log(key, '被设置')
		}
	})
}
let newObj = reactive(obj)
```

## 二、虚拟DOM

## 三、DOM diff算法

## 四、key

### 1.概念

`key`是一个特殊的熟悉名，类似`html`元素上的`id`属性。在vue中设置key的作用主要是为了**提升diff算法的效率**。

### 2.场景

- `v-for`循环渲染时，需要给单元加上`key`：

  ```html
  <ul>
  	<li v-for="(item, index) in list" :key="index">...</li>
  </ul>
  ```

- 用`+new Date()`生成的时间戳作为`key`，手动强制触发重新渲染：

  ```html
  <Comp :key="+new Date()" />
  ```

### 3.作用

**设置key与不设置key的区别：**

创建一个实例，2s后往`list`数组中插入数据。

```html
<body>
    <div id="demo">
        <p v-for="(item, index) in list" :key="index">
            {{ item }}
        </p>
    </div>
    <srcipt src="../../dist/vue.js"></srcipt>
	<script>
    	// 创建实例
        const app = new Vue({
            el: '#demo',
            data: {
                list: ['a', 'b', 'c', 'd', 'e']
            },
            mounted() {
                setTimeout(() => {
                    // 索引为2的位置，删除0个，添加新元素'f'
                    this.list.splice(2, 0, 'f')	// ['a', 'b', 'f', 'c',, d', 'e']
                }, 1000)
            }
        })
    </script>
</body>
```

在不使用key的情况，vue会进行这样的操作：**一共发生了3次更新，1次插入操作。**

![img](https://static.vue-js.com/c9da6790-3f41-11eb-85f6-6fac77c0c9b3.png)

- 比较 A，A，相同类型的节点，进行`patch`，但数据相同，不发生`dom`操作
- 比较 B，B，相同类型的节点，进行`patch`，但数据相同，不发生`dom`操作
- 比较 C，F，相同类型的节点，进行`patch`，数据不同，发生`dom`操作
- 比较 D，C，相同类型的节点，进行`patch`，数据不同，发生`dom`操作
- 比较 E，D，相同类型的节点，进行`patch`，数据不同，发生`dom`操作
- 循环结束，将 E 插入到`DOM`中

在使用key的情况，vue会进行这样的操作：**一共发生了0次更新，1次插入操作。*

![img](https://pic2.zhimg.com/80/v2-6e88cc53a7e427f0ae8340cf930ac30d_720w.webp)

- 比较 A，A，相同类型的节点，进行`patch`，但数据相同，不发生`dom`操作
- 比较 B，B，相同类型的节点，进行`patch`，但数据相同，不发生`dom`操作
- 比较 C，F，不相同类型的节点
- 比较 E、E，相同类型的节点，进行`patch`，但数据相同，不发生`dom`操作
- 比较 D、D，相同类型的节点，进行`patch`，但数据相同，不发生`dom`操作
- 比较 C、C，相同类型的节点，进行`patch`，但数据相同，不发生`dom`操作
- 循环结束，将 F 插入到 C 之前

> 综上述，设置`key`能够大大减少对页面`DOM`的操作，提高`diff`效率。

注意：设置key值一定能提高diff效率吗？

不一定。

> 当Vue.js用`v-for`更新已渲染过的元素列表时，默认采用“就地复用”的策略。如果数据项的顺序被改变，Vue将不会移动DOM元素来匹配数据项的顺序，而是简单地复用此处每个元素（尽量使用已经存在的`DOM`元素，直接在已有的DOM上进行复用修改），并且确保它在特定索引下显示已被渲染过的每个元素。

## 五、$nextTick

### 1.定义

> 在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM。

我们可以理解成，Vue在更新DOM时是异步执行的。当数据发生变化，Vue将开启一个异步更新队列，视图需要等待队列中所有数据变化完成之后，再统一进行更新。

### 2.作用

```js
for (let i = 0; i < 10000; i++) {
	num = i
}
```

如果没有`$nextTick`更新机制，那么`num`每次更新值都会触发视图更新（更新10000次），而有了`$nextTick`机制，只需要更新一次。因此`$nextTick`本质上是一种**优化策略**。

### 3.使用场景

如果想要在修改数据后立刻得到更新后的`DOM`结构，可以使用`Vue.$nextTick`。

```js
// 修改数据
vm.message = '修改后的值'
// DOM 还没有更新
console.log(vm.$el.textContent) // 原始的值
Vue.nextTick(function () {
  // DOM 更新了
  console.log(vm.$el.textContent) // 修改后的值
})
```

`$nextTick()`会返回一个`Promise`对象，可以使用`async/await`完成相同作用的事情。

```js
this.message = '修改后的值'
console.log(this.$el.textContent)	// 原始的值
await this.$nextTick()
console.log(this.$el.textContext)	// 修改后的值
```

## 六、$set

### 1.定义

当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值时，我们会发现页面并没有同步更新。这是因为`Object.defineProperty()`的限制，无法监听到数组变化或对象新增或删除的属性。

### 2.实现原理

- 如果目标是数组，直接使用数组的`splice`方法触发响应式；
- 如果目标是对象，会先判断属性是否存在、对象是否响应式。如果要对属性进行响应式处理，则是通过调用`defineReactive`方法进行响应式处理。

### 3.使用

```js
$set(对象, 属性名, 值)
```

作用：**手动添加响应式的效果**。

## 七、v-show和v-if

### 1.作用

控制元素的显示/隐藏。

### 2.区别

- 控制手段

  `v-show`通过为元素添加css`display: none`来隐藏元素，元素依然存在；`v-if`控制显示隐藏则是将整个元素添加或删除。

- 编译过程

  `v-if`切换有一个局部编译/卸载的过程，切换过程中销毁和重建内部的事件监听和子组件；`v-show`只是简单地基于`css`切换。

- 编译条件

  `v-if`是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建：

  - `v-show`由`false`变为`true`并不会触发组件的生命周期；

  - `v-if`由`false`变为`true`时，触发组件的`beforeCreate`、`create`、`beforeMount`、`mounted`钩子（**重建**）；

    由`true`变为`false`时，触发组件的`beforeDestory`和`destoryed`钩子（**销毁**）。

- 性能消耗

  `v-if`由更高的切换消耗；`v-show`由更高的**初始渲染**消耗。

### 3.场景

- 需要频繁切换的情况，使用`v-show`：手风琴菜单、`tab`页签……
- 在运行时条件很少改变，则使用`v-if`：用户登录之后，根据他的权限展示不同的内容。

## 八、computed和watch

> `watch`和`computed`都是以Vue的**依赖追踪机制**为基础的：当某一个或多个数据（称他们为**依赖数据**）发生变化时，所有依赖这些数据的相关数据都会自动地发生变化（自动调用相关的函数去实现数据的变动）。

### 1.computed

- 支持缓存，只有依赖数据发生改变，才会重新进行计算；
- 不支持异步，当`computed`内有异步操作时无效，无法监听数据的变化；
- `computed`是计算属性，也就是依赖某个值或者`props`通过计算得来的数据；
- `computed`的值是在`getter`执行之后进行缓存的，只有在它依赖的数据发生变化时，会重新调用getter来计算。

```vue
<script>
    export default {
        data: {
            firstName: 'Foo',
            lastName: 'Bar'
        },
        computed: {
            fullName() {
                return this.firstName + ' ' + this.lastName
            }
        }
    }
</script>
```

有时需要自己设定`setter`和`getter`，所有setter和getter的`this`上下文自动绑定为Vue实例：

```vue
<script>
    export default {
        data: {
            firstName: 'Foo',
            lastName: 'Bar'
        },
        computed: {
            fullName: {
            	// getter
                get: function() {
                    return this.firstName + ' ' + this.lastName
                },
                // setter
                set: function(newValue) {
                    var names = newValue.split(' ')
                    this.firstName = names[0]
                    this.lastName = names[names.length - 1]
                }
            }
        }
    }
</script>
```

### 2.watch
