# CSS

## 一、CSS3新特性

- `border-radius`：圆角边框
- `box-shadow`：盒子阴影
- `background-size`：背景图片大小
- `transition`：过渡
- `transform`：转换（位移、旋转、缩放）
- `animation`：动画
- `linear-gradient`：线性渐变
- `box-sizing`：css3盒子模型

## 二、BFC

BFC(Block Formatting Context)，块级格式化上下文。是用于布局块级盒子的独立渲染区域。

> W3C官方解释：`BFC`它决定了元素如何对其内容进行定位，以及与其它元素的关系和相互作用，当涉及到可视化布局时，`Block Formatting Context`提供了一个环境，`HTML`在这个环境中按照一定的规则进行布局。

简单来说就是，`BFC`是一个完全独立的空间（布局环境），让**空间里的子元素不会影响到外面的布局**。那么怎么使用`BFC`呢，**`BFC`可以看做是一个`CSS`元素属性**。

### 1.怎样触发BFC

- HTML根元素；
- position为`absolute`或`fixed`（绝对定位、固定定位）；
- float属性不为`none`（浮动）；
- overflow不为`visible`；
- display为`inline-block`、`table-cell`、`table-caption`、`flex`。

### 2.BFC解决了什么问题

1. 使用`float`脱离文档流，导致高度塌陷

   ```html
   <style>
     .par {
       border: 5px solid #fcc;
       width: 300px;
     }
   
     .child {
       border: 5px solid #f66;
       width: 100px;
       height: 100px;
       float: left;
     }
   </style>
   <body>
     <div class="par">
       <div class="child"></div>
       <div class="child"></div>
     </div>
   </body>
   ```

   ![img](https://static.vue-js.com/ec5d4410-9511-11eb-85f6-6fac77c0c9b3.png)

   而`BFC`在计算高度时，浮动元素也会参与，所以我们可以触发`.par`元素的`BFC`，则内部浮动元素计算高度时候也会计算。

   ```css
   .par {
     overflow: hidden;
   }
   ```

   ![img](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAcEAAAC6CAYAAADWKfZeAAAERUlEQVR4nO3cMWtUWRiA4S+baBAjRLC1TWthI1hZ+IMtrCysLCzsLRURVBQDiQSGhNli6mQ3sxmz5n2e5haXc/iKgRcO587WcrlcDgAE/XXdAwDAdRFBALJEEIAsEQQgSwQByBJBALJEEIAsEQQga+fCt8vlzPHxzOnpbxoHAC5hZ2dmb29ma2u95Re+XS5nPn+e+fVrrc0BYKPu3p05OFg7go5DAcgSQQCyRBCALBEEIEsEAci6+HboRRaLmQ8fVk+AP8H29syjRzP7+9c9CZdxdjZzeLh6XrH1I3hyMvPu3czR0RWOA7BBt27NPHky8/DhdU/CZSwWq2/WNxBBx6EAZIkgAFkiCECWCAKQJYIAZK1/O/QiDx7MPH26uo4M53nzZubr18ut2d9f/bZ2dzczEzfD27erP/+Hf7CZCN6/P/P8+eo6Mpzn/fvLR/DevZlnz1ZPOM/HjyLIv+I4FIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByBJBALJEEIAsEQQgSwQByNrZyK4/f868ejWzvb2R7bkhfvy4/Jqjo5nXr2d2d69+Hm6OL1+uewL+EJuJ4PfvMy9ebGRr4g4PZ16+vO4pgBvCcSgAWSIIQJYIApAlggBkiSAAWevfDr1zZ+bx45nF4grHAdig7e2Zk5OZT5+uexIu4+xs5vR0I1uvH8Hbt2cODq5wFIDfYLGY+fbtuqfgf8JxKABZIghAlggCkCWCAGSJIABZW8vlcnnu2+Vy5vh4Y1dTAeA/2dmZ2dub2dpaa/nFEQSAG8xxKABZIghAlggCkCWCAGSJIABZIghAlggCkCWCAGSJIABZIghA1t9sT2c0JjdqvAAAAABJRU5ErkJggg==)

2. margin边距重叠

   ```html
   <style>
     p {
       color: #f55;
       background: #fcc;
       width: 200px;
       line-height: 100px;
       text-align: center;
       margin: 100px;
     }
   </style>
   <body>
     <p>Haha</p>
     <p>Hehe</p>
   </body>
   ```

   ![img](data:image/png;base64,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)

   两个`p`元素之间的距离为`100px`，发生了`margin`重叠（塌陷），以最大的为准，如果第一个 P 的`margin`为 80 的话，两个 P 之间的距离还是 100，**以最大的为准**。

   可以**在`p`外面包裹一层容器，并触发这个容器生成一个`BFC`，那么两个`p`就不属于同一个`BFC`**，则不会出现`margin`重叠

   ```html
   <style>
     .wrap {
       overflow: hidden; // 新的BFC
     }
     p {
       color: #f55;
       background: #fcc;
       width: 200px;
       line-height: 100px;
       text-align: center;
       margin: 100px;
     }
   </style>
   <body>
     <p>Haha</p>
     <div class="wrap">
       <p>Hehe</p>
     </div>
   </body>
   ```

   ![img](data:image/png;base64,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)

3. 两栏布局

   ```html
   <style>
     body {
       width: 300px;
       position: relative;
     }
   
     .aside {
       width: 100px;
       height: 150px;
       float: left;
       background: #f66;
     }
   
     .main {
       height: 200px;
       background: #fcc;
     }
   </style>
   <body>
     <div class="aside"></div>
     <div class="main"></div>
   </body>
   ```

   ![img](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAbIAAAEsCAYAAACmHzYvAAAFB0lEQVR4nO3YIU5kURRF0UtBEIRAgiAoFJiav2YMTIAZIJFUXutOtel88bNhLXnFy3E7eRdrrTUAEHXYewAAbCFkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpV2eX7++Zt7eZz88d5pDx9DTz8rL3CqDu9nbm4WHTE+chO51m3t9nPj42PcwPdzzO3N/vvQL4CTaGzNciAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApAkZAGlCBkCakAGQJmQApF2dXQ6HmdfXmbu7HeaQ8fi49wKAmflXyC4vZ47HmefnHeYAwP/xtQhAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKQJGQBpQgZAmpABkCZkAKRdrLXWX5e1Zr6+Zk6nnSYB8GtcX8/c3Gx64jxkABDiaxGANCEDIE3IAEgTMgDShAyANCEDIE3IAEgTMgDShAyANCEDIE3IAEj7A5bFIWh0uWkWAAAAAElFTkSuQmCC)

   每个元素的左外边距与包含块的左边界相接触，因此，虽然`.aslide`为浮动元素，但是`main`的左边依然会与包含块的左边相接触。

   而**`BFC`的区域不会与浮动盒子重叠**，所以我们可以**通过触发`main`生成`BFC`**，以此适应两栏布局。

   ```css
   .main {
     overflow: hidden;
   }
   ```

   ![img](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAa0AAAEmCAYAAADRIc8sAAAExElEQVR4nO3YsWnDQACG0XPwANpBtcGtJ/K63sGdh/BlgKhQIER8yXvlccVfCD5OpznnHAAQ8HH0AADYS7QAyBAtADJEC4AM0QIgQ7QAyBAtADJEC4AM0QIg47x5er//8gxybrcxLpejVwB16zrGsuy+7qUFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQIZoAZAhWgBkiBYAGaIFQMZpzjm/nD4eB0wh5f0eY+PTAfiWdR1jWXZfP2+eXq8/NYe/6vkc4/U6egXwz/g9CECGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZJzmnPPoEQCwh5cWABmiBUCGaAGQIVoAZIgWABmiBUCGaAGQIVoAZHwCQNcaPMMeeNgAAAAASUVORK5CYII=)

### 3.清除浮动的方法总结

#### 1.1 额外标签法

给需要清除浮动的元素后，额外添加一个空白标签。

- 优点：通俗易懂、书写方便；
- 缺点：添加许多无意义的标签，结构化较差。

```html
<div class="fahter">
        <div class="big">big</div>
        <div class="small">small</div>
        <div class="clear">额外标签法</div>
</div>
```

```css
.big, .small {
    float: left;
}

.clear {
	clear: both;
}
```

#### 1.2 父级添加`overflow`

通过`触发BFC`的方式实现清除浮动。

必须定义`width`或`zoom: 1`(设置或检索对象的缩放比例，设置`zoom: 1`可以在IE6下清除浮动、解决margin导致的重叠等问题)，同时不能定义`height`，使用`overflow: hiiden`时，浏览器会自动检查浮动区域的高度。

```css
.fahter{
    width: 400px;
    border: 1px solid deeppink;
    overflow: hidden;
}
```

#### 1.3 使用`after`伪元素清除浮动

额外标签法的升级版，优点是无需单独添加标签、且符合闭合浮动思想，结构语义化正确，不容易出现奇怪的bug。

IE8及非IE浏览器支持`:after`。

```html
<body>
    <div class="father clearfix">
        <div class="big">big</div>
        <div class="small">small</div>
        <!--<div class="clear">额外标签法</div>-->
    </div>
    <div class="footer"></div>
</body>
```

```css
.clearfix:after {/*伪元素是行内元素 正常浏览器清除浮动方法*/
    content: "";
    display: block;
    height: 0;
    clear:both;
    visibility: hidden;
}
.clearfix {
    *zoom: 1;/*ie6清除浮动的方式 *号只有IE6-IE7执行，其他浏览器不执行*/
}
```

#### 1.4 使用`before`和`after`**双伪元素清除浮动**

```html
<div class="father clearfix">
    <div class="big">big</div>
    <div class="small">small</div>
</div>
<div class="footer"></div>
</div>
```

```css
<style>
    .father{
        border: 1px solid black;
        *zoom: 1;
    }
    .clearfix:after,.clearfix:before{
       content: "";
       display: block;
       clear: both;
    }
    .big ,.small{
        width: 200px;
        height: 200px;
        float: left;
    }
    .big{
        background-color: red;
    }
    .small{
        background-color: blue;
    }
</style>
```

单伪元素清除法和双伪元素清除法的区别：单伪元素只能清除浮动，双伪元素既能清除浮动，又能解决**外边距塌陷问题**（垂直方向相邻的块级元素，兄弟元素之间会出现外边距合并的问题，父子元素之间会出现外边距塌陷的问题，**即给子元素设置`margin-top`，父元素会随子元素同时向下移动**）。

解决方法：

- 让父元素上外边距不相邻：
  - 给父元素设置上外框
  - 给父元素设置上内边距
  - 在html结构中父子元素之间加一个`table`标签
- 开启父元素的BFC：
  - 父元素设置`overflow: hidden`
  - 父元素设置`display: table`
- 把父元素或子元素转换为行内块

**双伪元素解决外边距塌陷问题，利用了让父子元素外边距不相邻的原理**。

## 三、盒子模型

盒子模型组成有四部分构成，分别是：`内容`、`内边距`、`外边距`、`边框`。

2种盒子模型：

#### 1.1 标准盒子模型

`box-sizing: content-box`

标准盒子模型 = content(内容) + border(边框) + padding(内边距)

![img](https://static.vue-js.com/c0e1d2e0-8f9b-11eb-85f6-6fac77c0c9b3.png)

- 盒子总宽度 = width + padding + border + margin;
- 盒子总高度 = height + padding + border + margin

#### 1.2 怪异盒子模型

`box-sizing: border-box;`

怪异盒子模型 = content(内容) （内容的宽高已经包含了padding和border）

![img](https://static.vue-js.com/cfbb3ef0-8f9b-11eb-ab90-d9ae814b240d.png)

- 盒子总宽度 = width + margin;
- 盒子总高度 = height + margin;

## 四、flexbox

### 1.flex布局

`flexbox`是一种布局模型，让网页更加简单灵活，基于Flex精确灵活控制块级盒子的布局方式，并且避免浮动布局中脱离文档流现象发生。

### 2.常见属性

- `flex-direction`：决定主轴方向（项目排列方向）

  ```css
  .container {
  	flex-direction: row | row-reverse | column | column-reverse;
  }
  ```

  - row：默认值，水平方向，起点在左端
  - row-reverse：水平方向，起点在右端
  - column：垂直方向，起点在上沿
  - column-reverse：垂直方向，起点在下沿

  ![img](https://static.vue-js.com/0c9abc70-9838-11eb-ab90-d9ae814b240d.png)

- `flex-wrap`：决定容器内项目是否可换行

  ```css
  .container {
  	flex-wrap: nowrap | wrap | wrap-reverse;
  }
  ```

  - nowrap：默认值，不换行，使元素弹性伸缩

  - wrap：换行

  - wrap-reverse：换行，第一行在下方

    ![img](https://pic1.zhimg.com/80/v2-d9886eabf578e74323329237b80e1cdc_720w.webp)

- `flex-flow`：`flex-direction`和`flex-wrap`属性的简写形式，默认值为`row nowrap`

  ```css
  .box {
  	flex-wrap: <flex-direction> | <flex-wrap>;
  }
  ```

- `justify-content`：主轴上的对齐方式

  ```css
  .box {
  	justify-content: flex-start | flex-end | center | space-between;
  }
  ```

  - flex-start：默认值，左对齐
  - flex-end：右对齐
  - center：居中
  - space-between：两端对齐，项目之间的间隔都相等
  - space-around：项目两侧间隔相等

  ![img](https://static.vue-js.com/2d5ca950-9838-11eb-85f6-6fac77c0c9b3.png)

- `align-items`：定义项目在交叉轴上的对齐方式

  ```css
  .box {
  	justify-content: flex-start | flex-end | center | space-between
  }
  ```

  - flex-start：起点对齐
  - flex-end：重点对齐
  - center：中点对齐
  - baseline：项目的第一行文字的基线对齐
  - stretch：默认值，若项目未设置高度或设为`auto`，将占满整个容器的高度

- `align-content`：**只适用于多行的flex容器**，若子项仅有一行，该属性不起作用

  ```css
  .box {
    align-content: flex-start | flex-end | center | space-between | space-around | stretch;
  }
  ```

  - flex-start：与交叉轴的起点对齐
  - flex-end：与交叉轴的终点对齐
  - center：与交叉轴的中点对齐
  - space-between：与交叉轴两端对齐，轴线之间的间隔平均分布
  - space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍
  - stretch（默认值）：轴线占满整个交叉轴

  ![img](https://static.vue-js.com/39bcb0f0-9838-11eb-ab90-d9ae814b240d.png)

### 3.其他容器成员属性

- `order`：定义项目的排列顺序。**数字越小，排列越靠前，默认为0**。

  ```css
  .item {
  	order: <integer>;
  }
  ```

- `flex-grow`：定义**项目的放大比例**（容器宽度>元素总宽度时如何伸展）。默认为0，即如果存在剩余空间，也不放大。

  ```css
  .item {
  	flex-grow: <number>
  }
  ```

  ![img](https://static.vue-js.com/48c8c5c0-9838-11eb-ab90-d9ae814b240d.png)

  ![img](https://static.vue-js.com/5b822b20-9838-11eb-ab90-d9ae814b240d.png)

  注意：若弹性容器的宽度正好等于元素宽度总和，无多余宽度，此时无论`flex-grow`是什么值都不会生效。

- `flex-shrink`：定义了项目的**缩小比例**（容器宽度<元素总宽度时如何收缩）。默认为 1，即如果空间不足，该项目将缩小。

  ```css
  .item {
    flex-shrink: <number>; /* default 1 */
  }
  ```

- `flex-basis`：设置的是元素在主轴上的初始尺寸，所谓的初始尺寸就是元素在`flex-grow`和`flex-shrink`生效前的尺寸。默认值为`auto`，即项目的本来大小；如设置了`width`则元素尺寸由`width/height`决定（主轴方向），没有设置则由内容决定；**当设置为 0 的是，会根据内容撑开**；也可以设为跟`width`或`height`属性一样的值（比如 350px），则项目将占据固定空间。

  ```css
  .item {
    flex-basis: <length> | auto; /* default auto */
  }
  ```

- `flex`：`flex`属性是`flex-grow`, `flex-shrink` 和 `flex-basis`的简写，默认值为`0 1 auto`。

  ```css
  .item {
    flex: none | [ < 'flex-grow' > < 'flex-shrink' >? || < 'flex-basis' > ];
  }
  ```

  - flex: 1 = flex: 1 1 **0%**
  - flex: 2 = flex: 2 1 0%
  - flex: auto = flex: 1 1 **auto**
  - flex: none = flex: 0 0 auto，常用于固定尺寸不伸缩

  > `flex:1`和`flex:auto`的区别，可以归结于`flex-basis:0`和`flex-basis:auto`的区别：
  >
  > 当设置为0时（绝对弹性元素），此时相当于告诉`flex-grow`和`flex-shrink`在伸缩的时候不需要考虑我的尺寸
  >
  > 当设置为`auto`时（相对弹性元素），此时则需要在伸缩时将元素尺寸纳入考虑

  注意：建议优先使用这个属性，而不是单独写三个分离的属性。

- `align-self`：允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性。默认值为`auto`，表示继承父元素的`align-items`属性，如果没有父元素，则等同于`stretch`。

  ```css
  .item {
    align-self: auto | flex-start | flex-end | center | baseline | stretch;
  }
  ```

  ![img](https://static.vue-js.com/6f8304a0-9838-11eb-85f6-6fac77c0c9b3.png)

## 五、CSS绘制三角形

### 1.原理

边框实际上并不是一条直线，如果我们将四条边设置为不同的颜色，并逐渐将边框放大，可以看到每条边框都是一个梯形：

![img](https://static.vue-js.com/78d4bd90-a27a-11eb-85f6-6fac77c0c9b3.png)

当分别取消边框的时候，会发生下面几种情况：

- 取消一条边的时候，与这条边相接触的部分会变成直线；
- 当仅有邻边时，两个边会变成对分的三角形；
- 当保留边没有其他接触时，极限情况下所有内容都会消失。

![img](https://static.vue-js.com/84586ef0-a27a-11eb-85f6-6fac77c0c9b3.png)

### 2.实心三角形

使用CSS绘制三角形的原理是利用**盒子边框**完成的，其步骤如下：

1. 设置一个盒子；

2. 设置四周不同颜色的边框；

   ![img](https://static.vue-js.com/e3f244e0-a279-11eb-ab90-d9ae814b240d.png)

3. 为边框设置粗细；

   ![img](https://static.vue-js.com/ee0b42b0-a279-11eb-ab90-d9ae814b240d.png)

4. 将`盒子宽高设置为0`，`仅保留边框`；

   ![img](https://static.vue-js.com/2afaa030-a27a-11eb-85f6-6fac77c0c9b3.png)

5. 得到四个三角形，选择其中一个，`将其他三个三角形设置为透明`色。

```css
div {
  width: 0px;
  height: 0px;
  border-top: 20px solid transparent;
  border-bottom: 20px solid red;
  border-left: 20px solid transparent;
  border-right: 20px solid transparent;
}
```

### 3.空心三角形

```css
.border {
	width: 0;
	height: 0;
	border-style: solid;
	border-width: 0 50px 50px;
	border-color: transparent transparent #d9534f;
	position: relative;
}
```

利用伪类新建一个小一点的三角形定位到大的三角形上，实现空心三角形的效果。

```css
.border:after {
	content: '';
	border-style: solid;
	border-width: 0 40px 40px;
    border-color: transparent transparent #96ceb4;
    position: absolute;
    top: 0;
    left: 0;
}
```

![i](https://static.vue-js.com/59f4d720-a27a-11eb-85f6-6fac77c0c9b3.png)

最终代码如下：

```css
.border {
	width: 0;
	height: 0;
	border-style: solid;
	border-width: 0 50px 50px;
	border-color: transparent transparent #d9534f;
	position: relative;
}

.border:after {
	content: '';
	border-style: solid;
	border-width: 0 40px 40px;
	border-color: transparent transparent #fff;
	position: absolute;
	top: 6px;
	left: -40px;
}
```

## 六、CSS选择器

```html
<div id="box">
  <div class="one">
    <p class="one_1"></p>
    <p class="one_1"></p>
  </div>
  <div class="two"></div>
  <div class="two"></div>
  <div class="two"></div>
</div>
```

### 1.选择器

- id选择器：`#box`，选择id为box的元素

- 类选择器：`.box`，选择类名为box的所有元素

- 标签选择器：`div`，选择标签为div的所有元素

- 后代选择器：`#box div`，选择id为box的元素内部所有div元素

- 子选择器：`.one>.one_1`，选择父元素类名为one的所有类名为one_1的元素

- 相邻兄弟选择器：`.one+.two`，选择紧邻类名为one的元素之后同级的类名为two的元素

  ```html
  <div id="box">
      <div class="two">0</div>
      <div class="one">
        <p class="one_1"></p>
        <p class="one_1"></p>
      </div>
      <div class="two">1</div>
      <div class="two">2</div>
      <div class="two">3</div>
      <div class="one"></div>
    </div>
  ```

  ```css
  .one+.two {
      width: 100px;
      height: 100px;
      background: red;
  }
  ```

  ![image-20231128153638960](https://gitee.com/v876774538/my-img/raw/master/image-20231128153638960.png)

- 群组选择器：`div, p`，选择div、p的所有元素

- 交集选择器：`.one .one_1`，选择同时符合.one和.one_1条件的元素

- 伪类选择器：

  - `:link`：选择未被访问的链接
  - `:visited`：选择已被访问的链接
  - `:hover`：鼠标指针悬停在上面的元素
  - `:active`：选择活动链接（当你点击一个链接时，它变成活动链接。为了产生预期的效果，在css定义中，`:active`必须位于`:hover`之后）
  - `:focus`：选择具有焦点的
  - `:first-child`：父元素的首个子元素

- 伪元素选择器：

  - `:first-letter`：用来指定元素第一个字母的样式

  - `:first-line`：用来指定元素第一行

    ```html
    <div id="box">
        <p>
            天上白玉京，十二楼五城。<br>
            仙人抚我顶，结发受长生。<br>
            误逐世间乐，颇穷理乱情。<br>
            九十六圣君，浮云挂空名。<br>
            天地赌一掷，未能忘战争。<br>
            试涉霸王略，将期轩冕荣。<br>
            时命乃大谬， 弃之海上行。<br>
            学剑翻自哂， 为文竟何成。<br>
            剑非万人敌， 文窃四海声。<br>
            儿戏不足道， 五噫出西京。<br>
        </p>
    </div>
    ```

    ```css
    p {
        color: #333;
    }
    
    p:first-letter {
        color: red;
    }
    
    p:first-line {
        color: blue;
    }
    ```

    ![image-20231128155201051](https://gitee.com/v876774538/my-img/raw/master/image-20231128155201051.png)

  - `:before`：选择器在被选元素的内容前面插入内容

  - `:after`：选择器在被选元素的内容后面插入内容

- 属性选择器

  - `[attribute]`：选择带有attribute属性的元素

    ```css
    a[target] {
    	background: yellow;
    }
    ```

  - `[attribute=value]`：选择所有使用attribute=value的元素

    ```css
    a[target="_blank"] {
    	background: yellow;
    }
    ```

  - `[attribute~=value]`：选择attribute属性包含value的元素

    ```css
    [title~="flower"] {
      border: 5px solid yellow;
    }
    ```

    上面的例子会匹配以下属性的元素：title="flower"、title="summer flower" 以及 title="flower new"，**但不匹配：title="my-flower" 或 title="flowers"。**

    ```html
    <div id="box">
        <div class="flower">flower</div>
        <div class="flowers">flowers</div>
        <div class="summer flower">summer flower</div>
        <div class="my-flower">my-flower</div>
    </div>
    ```

    ```css
    div {
        width: 100px;
        height: 100px;
        border: 1px solid #333;
    }
    
    [class~="flower"] {
        background: red;
    }
    ```

    ![image-20231128160721193](https://gitee.com/v876774538/my-img/raw/master/image-20231128160721193.png)

  - `[attribute|=value]`：选择attribute属性以value开头的元素

    ```css
    [class|="top"] {
      background: yellow;
    }
    ```

    下例选取 class 属性以 "top" 开头的所有元素：

    **提示：**值必须是**完整或单独的单词**，比如 class="top" 或者后跟连字符的，比如 class="top-text"。

    ```html
    <div id="box">
        <div class="flower">flower</div>
        <div class="flowers">flowers</div>
        <div class="summer flower">summer flower</div>
        <div class="my-flower">my-flower</div>
        <div class="flower-my">flower-my</div>
    </div>
    ```

    ```css
    div {
        width: 100px;
        height: 100px;
        border: 1px solid #333;
    }
    
    [class|="flower"] {
        background: red;
    }
    ```

    ![image-20231128161011075](https://gitee.com/v876774538/my-img/raw/master/image-20231128161011075.png)

CSS3新增选择器：

- 全部兄弟选择器（层次选择器）：`.one~.two`，选择**所有**符合条件的兄弟元素

  ```css
  .one~.two {
      width: 100px;
      height: 100px;
      background: red;
  }
  ```

  ![image-20231128155615800](https://gitee.com/v876774538/my-img/raw/master/image-20231128155615800.png)

- 属性选择器：

  - `[attribute*=value]`：选择attribute属性值包含value的所有元素

    **提示：**值不必是完整单词！

  - `[attribute^=value]`：选择attribute属性开头为value的所有元素

    **提示：**值不必是完整单词！

  - `[attribute$=value]`：选择attribute属性结尾为value的所有元素

    **提示：**值不必是完整单词！

  > 应用场景：**为不带`class`或`id`的表单设置样式**。

  ```css
  input[type="text"] {
    width: 150px;
    display: block;
    margin-bottom: 10px;
    background-color: yellow;
  }
  
  input[type="button"] {
    width: 120px;
    margin-left: 35px;
    display: block;
  }
  ```

### 2.优先级

> 内联 > ID 选择器 > 类选择器 > 标签选择器

**计算规则**：具体的计算层⾯，优先级是由`A、B、C、D`的值来决定的。

- 如果`存在内联样式`，那么`A=1`，否则A=0；
- B的值等于`ID选择器出现的次数`；
- C的值等于`类选择器`、`属性选择器`和`伪类`出现的次数；
- D的值等于`标签选择器`和`伪元素`出现的总次数

举例：

```css
#nav-global > ul > li > a.nav-link;
```

- A=0
- B=1
- C=1
- D=3

推出其优先级值为：(0, 1, 1, 3)。

**比较规则**：

- 从左往右依次比较，较大者优先级更高；
- 若相等，则继续右移一位进行比较；
- 若4位全部相等，则后者覆盖前者

**提示**：若外部样式需要覆盖内联样式，需要使用`!important`。

### 3.CSS继承属性

在CSS中，继承指的是给父元素设置一些属性，后代元素会自动拥有这些属性。

**继承属性**有：

- 字体系列属性

  ```css
  font: 组合字体 
  font-family: 规定元素的字体系列
  font-weight: 设置字体的粗细
  font-size: 设置字体的尺寸
  font-style: 定义字体的风格
  font-variant: 偏大或偏小的字体
  ```

  **提示**：

  - a 标签的字体颜色不能被继承
  - h1-h6 标签字体的大下也是不能被继承的

- 文本系列属性

  ```css
  text-indent：文本缩进
  text-align：文本水平对刘
  line-height：行高
  word-spacing：增加或减少单词间的空白
  letter-spacing：增加或减少字符间的空白
  text-transform：控制文本大小写
  direction：规定文本的书写方向
  color：文本颜色
  ```

- 元素可见性

  ```css
  visibility
  ```

- 表格布局属性

  ```css
  caption-side：定位表格标题位置
  border-collapse：合并表格边框
  border-spacing：设置相邻单元格的边框间的距离
  empty-cells：单元格的边框的出现与消失
  table-layout：表格的宽度由什么决定
  ```

- 列表属性

  ```css
  list-style-type：文字前面的小点点样式
  list-style-position：小点点位置
  list-style：以上的属性可通过这属性集合
  ```

- 引用

  ```css
  quotes：设置嵌套引用的引号类型
  ```

- 光标属性

  ```css
  cursor：箭头可以变成需要的形状
  ```

**无继承的属性**：

- 元素显示类型/子元素布局类型

  ```css
  display
  ```

- 文本属性

  ```css
  vertical-align: 垂直居中
  text-decoration: 水平居中
  ```

- 盒子模型的属性

  ```css
  width: 宽度
  height: 高度
  padding: 内边距
  margin: 外边距
  border: 边框
  ```

- 背景属性

  ```css
  background-image: 背景图片
  background-color: 背景颜色
  background-position: 背景图像起始位置
  ```

- 定位属性

  ```css
  float: 浮动
  clear: 清除浮动
  position: 定位
  ```

- 生成内容属性：content、counter-reset、counter-increment

- 轮廓样式属性：outline-style、outline-width、outline-color、outline

- 页面样式属性：size、page-break-before、page-break-after

## 七、em/px/rem/vh/vw区别

在CSS单位中，可以分为**相对长度单位**和**绝对长度单位**：

|   CSS单位    |                                        |
| :----------: | -------------------------------------- |
| 相对长度单位 | em、ex、ch、rem、vw、vh、vmin、vmax、% |
| 绝对长度单位 | cm、mm、in、px、pt、pc                 |

### 1.px

#### 1.1 说明

`px`表示像素，所谓像素就是呈现在我们显示器上的一个个小点，这这个设备中，每个像素点都是大小等同的，与其他属性无关，所以像素是绝对长度单位。

### 2.em

#### 2.1 说明

`em`是相对长度单位，相对于当前对象内文本的字体尺寸。若当前对象内文本的字体尺寸未被设置，则采用相对于浏览器默认字体尺寸（`1em = 16px`）。

> 为了简化`font-size`的换算，我们需要在CSS中的`body`选择器中声明`font-size: 62.5%`，使em的值变为`1em = 16px * 62.5% = 10px`。即12px = 1.2em，16px = 1.6em。

#### 2.2 特点

- em的值并不是固定的
- em会**继承父级元素的字体大小**
- em是相对长度单位，若当前对象内文本的字体尺寸未被设置，则采用相对于浏览器默认字体尺寸
- **任意浏览器的默认字体大小都是16px**

#### 2.3 举例

```html
<div class="big">
	左边距14px
	<div class="small">左边距12px</div>
</div>
```

```css
html {
	font-size: 10px;  
} /*  公式16px*62.5%=10px  */
.big {
	margin-left: 1.4rem
}
.small {
	margin-left: 1.2rem;
}
```

![image-20231129143918619](https://gitee.com/v876774538/my-img/raw/master/image-20231129143918619.png)

### 3.rem

#### 3.1 说明

`rem`，CSS3新增的相对长度单位，相对于`HTML根元素`的`font-size`的值。

> 同理，若想要简化`font-size`转化，我们可以在根元素css中加入`font-size: 62.5%`。

```css
html {
	font-size: 62.5%;
} /*  公式16px*62.5%=10px  */
```

#### 3.2 特点

- rem单位集相对大小和绝对大小的优点于一身
- 与em不同之处就在于rem总是相对于根元素，而不需要像em一样使用级联的方式来计算尺寸

### 4.vh、vw

#### 4.1 说明

`vw`，即根据窗口的**宽度**，分成100等份：100vw表示满宽，50vw表示一半宽度。

vw始终针对窗口的宽度，同理，`vh`为窗口的**高度**。

此处的窗口分为几种情况：

- 桌面端：指浏览器的可视区域。即`window.innerWidth/window.innerHeight`大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。

  ![图片.png](http://ww.qdxiaochuan.com/zb_users/upload/2021/05/202105071620362786893461.png)

- 移动端：布局视口

  ![图片.png](http://ww.qdxiaochuan.com/zb_users/upload/2021/05/202105071620362817755517.png)

#### 4.2 vh/vw和%的区别

- vh与vw都是根据窗口大小比例适应显示，**根据浏览器窗口来进行定位的**

  ```css
  1vw = 窗口宽度的1%
  1vh = 窗口高度的1%
  ```

- %则根据**父元素**进行定位

  - 对于普通定位元素，%根据父元素进行定位
  - 对于`posiiton: absolute`的元素，相对于已定位的父元素
  - 对于`position: fixed`的元素，相对于ViewPort（可视窗口）

## 八、响应式设计

### 1.介绍

响应式网站设计（Responsive Web Design）是一种网络页面设计布局，页面的设计与开发应当根据用户行为以及设备环境（系统平台、屏幕尺寸等进行响应的响应和调整）。

响应式网站常见特点：

- 同时适配PC、平板和手机端等
- 标签导航在接近手持终端设备时改变为经典的抽屉式导航
- 网站的布局会根据视口来调整模块的大小和位置

![img](https://static.vue-js.com/ae68be30-9dba-11eb-85f6-6fac77c0c9b3.png)

### 2.实现方法

响应式设计的基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理，为了处理移动端，页面头部必须有`meta`声明`viewport`：

```html
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no”>
```

属性对应如下：

- `width=device-width`：自适应手机屏幕的尺寸宽度
- `maximun-scale`：缩放比例的最大值
- `inital-scale`：缩放的初始化
- `user-scalable`：是否允许用户缩放

#### 2.1 媒体查询

使用`@media`查询，可以针对不同的媒体类型定义不同的样式，如：

```css
@media screen and (max-width: 1920px) {
	...
}
```

```css
@media screen and (min-width: 375px) and (max-width: 600px) {
	body {
		font-size: 18px;
	}
}
```

#### 2.2 百分比

比如当浏览器的宽度或高度发生变化时，通过百分比单位，我们可以使浏览器中的组件的宽高随浏览器的变化而变化，从而实现响应式的效果。

`height`、`width`属性的百分比依托于父元素的宽高，但其他盒子属性则不完全依赖父元素：

- 子元素的`top`/`left`和`bottom`/`right`如果设置百分比，则相对于直接**非static定位的父元素**的高度/宽度

- 子元素的`padding`如果设置百分比，不论垂直方向或是水平方向，都**相对于直接父元素的width**，而与父元素的height无关

- 子元素的`margin`如果设置百分比，不论垂直方向还是水平方向，也是**相对于直接父元素的width**

- `border-radius`相对于自身的**宽高**

  ```css
  border-radius: 50%;	// 圆
  ```

  **补充**

  border-radius设置原则：

  - 若为一个值，则用其为半径构建圆形，这个圆与边框的交集形成圆角的效果；

  - 若为两个值，则这两个值分别为半长轴、半短轴构建椭圆，这个椭圆与边框的交集形成圆角效果

    ![img](https://img-blog.csdnimg.cn/20210309165959853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDEzNzU3NQ==,size_16,color_FFFFFF,t_70)

  举例：

  - 盒子宽高都为100px，设置`border-top-left-radius: 50%`，相当于用50px作为半径构建圆形

    ![img](https://img-blog.csdnimg.cn/20210309171931507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDEzNzU3NQ==,size_16,color_FFFFFF,t_70)

  - 盒子宽200px，高100px，设置`border-top-left-radius: 50%`，相当于用100px作为半长轴，50px作为半短轴构建圆形

    ![img](https://img-blog.csdnimg.cn/2021030917181783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDEzNzU3NQ==,size_16,color_FFFFFF,t_70)

  - 盒子宽高都为100px，设置`border-top-left-radius: 10% 50%`，相当于用10px作为半短轴，50px作为半长轴构建圆形

    ![img](https://img-blog.csdnimg.cn/20210309172342705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDEzNzU3NQ==,size_16,color_FFFFFF,t_70)

  - 盒子宽200px，高100px，设置`border-top-left-radius: 10% 50%`，相当于用20px作为半短轴，50px作为半长轴构建圆形

    ![img](https://img-blog.csdnimg.cn/20210309172437772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDEzNzU3NQ==,size_16,color_FFFFFF,t_70)

#### 2.3 vw/vh

`vw`表示相对于视图窗口的宽度，`vh`表示相对于视图窗口的高度。

任意层级元素，在使用vw为单位的情况下，1vw都等于**视图宽度**的百分之一。

#### 2.4 rem

> 前文提到，`rem`是相对于根元素`html`的`font-size`属性改变尺寸大小的单位，默认情况下浏览器字体大小为16px，此时`1rem = 16px`。

可以利用媒体查询的方法，针对不同设备分辨率改变根元素`font-size`的值，如：

```css
@media screen and (max-width: 414px) {
	html {
		font-size: 18px;
	}
}

@media screen and (max-width: 375px) {
	html {
		font-size: 16px;
	}
}

@media screen and (max-width: 320px) {
	html {
		font-size: 12px;
	}
}
```

为了更准确地监听设备可视窗口的变化，可以采用`js`的方法动态地修改`font-size`的值，以达到响应式的目的：

```js
// 动态为根元素设置字体大小
function init() {
	// 获取屏幕宽度
	var width = document.documentElement.clientWidth
	// 设置根元素字体大小
	document.documentElement.style.fontSize = width / 10 + 'px'
}

// 首次加载应用，设置
init()
// 监听手机旋转的事件和时机，重新设置
window.addventListener('orientationchange', init)
// 监听手机窗口变化，重新设置
window.addEventListener('resize', init)
```

无论设备可视窗口如何变化，始终设置`rem`为`width`的 1/10，实现了百分比布局。

**SANTIME官网**：http://syy333.dynv6.net:20080/syy/santime.git

```html
<script>
    (function (win) {
        var tid

        function refreshRem() {
            let designSize = 1920 // 设计图尺寸
            let html = document.documentElement
            let wW = html.clientWidth // 窗口宽度
            let rem = (wW * 100) / designSize
            document.documentElement.style.fontSize = rem + 'px'
        }

        win.addEventListener(
            'resize',
            function () {
                clearTimeout(tid)
                tid = setTimeout(refreshRem, 300)
            },
            false
        )
        win.addEventListener(
            'pageshow',
            function (e) {
                if (e.persisted) {
                    clearTimeout(tid)
                    tid = setTimeout(refreshRem, 300)
                }
            },
            false
        )

        refreshRem()
    })(window)

    $(function () {
        $('#foot').load('foot.html')
    })
</script>
```

#### 2.5 scale

页面缩放，最好用于固定宽高比的Web应用，如大屏或者固定窗口业务应用。

**三益友官网**：http://syy333.dynv6.net:20080/zhangzl/syy.git master分支

```js
window.onload = function() {
  setScale();
}
window.onresize = function () {
  setScale();
};
function setScale() {
  // 设计稿：1920 * 1080
  // 1.设计稿尺寸
  let targetWidth = 1920;
  // 2.拿到当前设备（浏览器）的宽度
  // document.documentElement  获取html的宽度
  let currentWidth = document.documentElement.clientWidth || document.body.clientWidth;
  // 3.计算缩放比率(屏幕过宽，根据高度计算缩放比例)
  let scaleRatio = currentWidth / targetWidth;
  // 4.开始缩放网页
  // 宽度>1920 顶部中心缩放
  if (currentWidth > targetWidth) {
    document.body.style = `transform: scale(${scaleRatio}); transform-origin: top center;`;
  }
  // 宽度<1920 顶部靠左缩放
  else {
    document.body.style = `transform: scale(${scaleRatio}); transform-origin: top left;`;
  }
}
```

注意：`transform`会导致`position:fixed`失效，故只能使用`position:absolute`，采用将滚动距离赋值给绝对定位的元素的方法。

```js
handleScroll() {
  var scrollTop =
    window.pageYOffset ||
    document.documentElement.scrollTop ||
    document.body.scrollTop;
  // let top = this.selectIndex == 0 ? 670 : 502;
  let top = document.documentElement.querySelector(".header").offsetHeight + document.documentElement.querySelector(".header").offsetTop;
  var headerElement = document.documentElement.querySelector(".header1");
  if (scrollTop >= top) {
    if (!this.show) {
      this.show = true;
      this.show1 = true;
    }
    headerElement.style = `top: ${scrollTop / this.scaleRatio}px`;
  } else {
    if (this.show) {
      this.show1 = false;
      setTimeout(() => {
        this.show = false;
      }, 400);
    }
  }
},
```

参考文献：[前端大屏适配几种方案_前端大屏适配方案_狮子歌歌_丶的博客-CSDN博客](https://blog.csdn.net/Liushiliu104/article/details/129372083?spm=1001.2100.3001.7377&utm_medium=distribute.pc_feed_blog_category.none-task-blog-classify_tag-8-129372083-null-null.nonecase&depth_1-utm_source=distribute.pc_feed_blog_category.none-task-blog-classify_tag-8-129372083-null-null.nonecase)

## 九、常见布局实现

### 1.两栏布局

#### 1.1 效果

双栏布局十分常见，往往是以一个**定宽栏**和一个**自适应的栏**并排展示存在。适用于有明显**主次关系**的网页。

![img](https://static.vue-js.com/fcb8ac50-976e-11eb-85f6-6fac77c0c9b3.png)



#### 1.2 实现思路

1. float浮动

   - 使用`float`左浮动左边栏
   - 右边模块用`margin-left`撑出内容块做内容展示
   - 为父级元素添加BFC，防止下方元素飞到上方内容

   ```html
   <!DOCTYPE html>
   <html lang="en">
   
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
   </head>
   
   <body>
       <div class="index">
           <div class="nav">
               <div class="li">1</div>
               <div class="li">2</div>
               <div class="li">3</div>
               <div class="li">4</div>
               <div class="li">5</div>
           </div>
           <div class="main">
               <div class="title">Title</div>
               <div class="box"></div>
   
           </div>
       </div>
   </body>
   <style>
       body {
           margin: 0;
       }
       
       .clearfix:after,
       .clearfix:before {
           content: "";
           display: block;
           clear: both;
       }
   
       .index {
           /* 父元素添加BFC */
           overflow: hidden;
           /* background: lightslategray; */
       }
   
       .nav {
           width: 21%;
           height: 100%;
           min-height: 100vh;
           float: left;
           background: lightblue;
       }
   
       .nav .li {
           height: 30px;
           line-height: 30px;
           padding: 0 15px;
           box-sizing: border-box;
       }
   
       .nav .li:first-child {
           background: lightcoral;
       }
   
       .main {
           margin-left: 21%;
           padding: 20px;
           box-sizing: border-box;
       }
   
       .main .box {
           width: 200px;
           height: 100px;
           background: red;
       }
   </style>
   
   </html>
   ```

   ![image-20231130101955341](https://gitee.com/v876774538/my-img/raw/master/image-20231130101955341.png)

2. flex布局

   ```html
   <!DOCTYPE html>
   <html lang="en">
   
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
   </head>
   
   <body>
       <div class="index">
           <div class="nav">
               <div class="li">1</div>
               <div class="li">2</div>
               <div class="li">3</div>
               <div class="li">4</div>
               <div class="li">5</div>
           </div>
           <div class="main">
               <div class="title">Title</div>
               <div class="box"></div>
   
           </div>
       </div>
   </body>
   <style>
       body {
           margin: 0;
       }
   
       .index {
           /* flex弹性布局 */
           display: flex;
       }
   
       .nav {
           width: 21%;
           height: 100%;
           min-height: 100vh;
           float: left;
           background: lightblue;
       }
   
       .nav .li {
           height: 30px;
           line-height: 30px;
           padding: 0 15px;
           box-sizing: border-box;
       }
   
       .nav .li:first-child {
           background: lightcoral;
       }
   
       .main {
           padding: 20px;
           box-sizing: border-box;
       }
   
       .main .box {
           width: 200px;
           height: 100px;
           background: red;
       }
   </style>
   
   </html>
   ```

### 2.三栏布局

#### 2.1 效果

![img](https://static.vue-js.com/0bf016e0-976f-11eb-ab90-d9ae814b240d.png)

#### 2.2 实现思路

1. 两边float，中间margin

   ```html
   <!DOCTYPE html>
   <html lang="en">
   
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
   </head>
   
   <body>
       <div class="wrap">
           <div class="left">左侧</div>
           <div class="right">右侧</div>
           <div class="center">
               中间
               <div class="box"></div>
           </div>
       </div>
   </body>
   <style>
       body {
           margin: 0;
       }
   
       .wrap {
           overflow: hidden;
       }
   
       .left, .right {
           width: 20%;
           height: 100%;
           min-height: 100vh;
       }
       
       .left {
           float: left;
           background: lightblue;
       }
   
       .right {
           float: right;
           background: lightcoral;
       }
   
       .center {
           margin: 0 20%;
           padding: 20px;
           box-sizing: border-box;
       }
   
       .center .box {
           width: 200px;
           height: 200px;
           background: red;
       }
   </style>
   
   </html>
   ```

   ![image-20231130103127406](https://gitee.com/v876774538/my-img/raw/master/image-20231130103127406.png)

2. 两边absolute，中间margin

   ```css
   body {
       margin: 0;
   }
   
   .wrap {
       position: relative;
   }
   
   .left, .right {
       width: 20%;
       height: 100%;
       min-height: 100vh;
   }
   
   .left {
       position: absolute;
       top: 0;
       left: 0;
       background: lightblue;
   }
   
   .right {
       position: absolute;
       top: 0;
       right: 0;
       background: lightcoral;
   }
   
   .center {
       margin: 0 20%;
       padding: 20px;
       box-sizing: border-box;
   }
   
   .center .box {
       width: 200px;
       height: 200px;
       background: red;
   }
   ```

3. 两边使用float和负margin

   ```html
   <!DOCTYPE html>
   <html lang="en">
   
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
   </head>
   
   <body>
       <div class="main-wrapper">
           <div class="main">中间自适应</div>
       </div>
       <div class="left">左边固定宽度</div>
       <div class="right">右边固定宽度</div>
   </body>
   <style>
       .left,
       .right,
       .main {
           height: 200px;
           line-height: 200px;
           text-align: center;
       }
   
       .main-wrapper {
           float: left;
           width: 100%;
       }
   
       .main {
           margin: 0 110px;
           background: black;
           color: white;
       }
   
       .left,
       .right {
           float: left;
           width: 100px;
           margin-left: -100%;
           background: green;
       }
   
       .right {
           margin-left: -100px;
           /* 同自身宽度 */
       }
   </style>
   
   </html>
   ```

   ![image-20231130110912093](https://gitee.com/v876774538/my-img/raw/master/image-20231130110912093.png)

4. display: table

   `<table>`标签用于展示行列数据，不适合用于布局。但可以使用`display: table`来实现布局的效果。

   ```html
   <!DOCTYPE html>
   <html lang="en">
   
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
   </head>
   
   <body>
       <div class="container">
           <div class="left">左边固定宽度</div>
           <div class="center">中间自适应</div>
           <div class="right">右边固定宽度</div>
       </div>
   </body>
   <style>
       body {
           margin: 0;
       }
   
       .container {
           /* 设置为表格 */
           display: table;
           /* 列宽由自身宽度决定 无需自动计算 */
           table-layout: fixed;
           width: 100%;
           height: 100%;
           min-height: 100vh;
       }
   
       .left, .right, .center {
           /* 设置为单元格 */
           display: table-cell;
       }
   
       .left, .right {
           width: 20%;
           height: 100%;
           min-height: 100vh;
       }
   
       .left {
           background: lightblue;
       }
   
       .right {
           background: lightcoral;
       }
   </style>
   
   </html>
   ```

   ![image-20231130111621587](https://gitee.com/v876774538/my-img/raw/master/image-20231130111621587.png)

5. flex实现

   ```html
   <!DOCTYPE html>
   <html lang="en">
   
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
   </head>
   
   <body>
       <div class="container">
           <div class="left">左边固定宽度</div>
           <div class="center">中间自适应</div>
           <div class="right">右边固定宽度</div>
       </div>
   </body>
   <style>
       body {
           margin: 0;
       }
   
       .container {
           width: 100%;
           height: 100%;
           min-height: 100vh;
           display: flex;
       }
   
       .left, .right, .center {
       }
   
       .left, .right {
           width: 20%;
           height: 100%;
           min-height: 100vh;
       }
   
       .left {
           background: lightblue;
       }
   
       .right {
           background: lightcoral;
       }
   
       .center {
           width: 100%;
           /* flex: 1; */
           background: lightseagreen;
       }
   </style>
   
   </html>
   ```

   - 仅需将容器设置为`display:flex;`，
   - 盒内元素两端对其，将中间元素设置为`100%`宽度，或者设为`flex:1`，即可填充空白
   - 盒内元素的高度撑开容器的高度

   优点：

   - 结构简单直观
   - 可以结合 flex 的其他功能实现更多效果，例如使用 order 属性调整显示顺序，让主体内容优先加载，但展示在中间

6. grid网格布局

   ```html
   <!DOCTYPE html>
   <html lang="en">
   
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
   </head>
   
   <body>
       <div class="container">
           <div class="left">左边固定宽度</div>
           <div class="center">中间自适应</div>
           <div class="right">右边固定宽度</div>
       </div>
   </body>
   <style>
       body {
           margin: 0;
       }
   
       .container {
           width: 100%;
           display: grid;
           grid-template-columns: 300px auto 300px;
       }
   
       .left, .right, .center {
           height: 100px;
       }
   
       .left {
           background: lightblue;
       }
   
       .right {
           background: lightcoral;
       }
   
       .center {
           width: 100%;
           /* flex: 1; */
           background: lightseagreen;
       }
   </style>
   
   </html>
   ```

   ![image-20231219191135377](https://gitee.com/v876774538/my-img/raw/master/image-20231219191135377.png)

   **grid布局的使用方法**：

   - 启用网格布局：`display: grid`

     块级容器（宽度撑满整行时）`display: grid;`

     行内容器（宽度随内容自适应时）`display: inline-grid;`

     > 注意：使用网格布局后，项目的`float`、`display: inline-block`、`display: table-cell`、`vertical-align`和`column-*`等设置都将失效。

   - 划分列：`grid-template-columns`

     - 将容器等分为3列，每列宽度为100px

       ```css
       grid-template-columns: 100px 100px 100px;
       ```

     - 将容器等分为3列，每列宽度为总宽度/3

       ```css
       grid-template-columns: 33.33% 33.33% 33.33%;
       ```

     - 将容器划分为3列，第一列的宽度:第二列的宽度 = 1:2

       ```css
       grid-template-columns: 1fr 2fr;
       ```

     - `fr`是fraction的缩写，意为“片段”，可与绝对长度的单位结合使用

       ```css
       grid-template-columns: 150px 1fr 2fr;
       ```

     - `auto`由浏览器自己决定长度

       ```css
       grid-template-columns: 100px auto 100px;
       ```

       ```css
       .container {
           grid-template-columns: 80px auto 100px;
           grid-template-rows: 25% 100px auto 60px;
       }
       ```

       ![img](https://img-blog.csdnimg.cn/adc776445c12412c93917b5271cc5182.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pyd6ZizMzk=,size_20,color_FFFFFF,t_70,g_se,x_16)

       > 参考：[css【详解】grid布局—— 网格布局（栅格布局）_css grid-CSDN博客](https://blog.csdn.net/weixin_41192489/article/details/115588135)

## 十、文本溢出的省略样式

### 1.单行溢出

```css
white-spcae: nowrap;		// 文本强制不换行
text-overflow: ellipsis;	// 文本溢出展示省略号，规定当文本溢出时，显示省略号来代表被修剪的文本
overflow: hidden;			// 溢出隐藏，文字长度超出限定宽度，则隐藏超出的内容
```

```css
.p {
	width: 400px;	// 必须规定宽或最大宽度
	height: 40px;
	line-height: 40px;
	white-space: nowrap;
	overflow: hiiden;
	text-overflow: ellipsis;
}
```

### 2.多行溢出

```css
display: -webkit-box;			// 元素转换为弹性容器，在一行排列
-webkit-box-orient: vertical；	// 表示盒子对象的子元素的排列方式
-webkit-line-clamp: 3;			// 限制文本的行数，表示文本第几行省略
text-overflow: ellipsis;		// 溢出展示省略号
overflow: hiidden;				// 溢出隐藏
```

```css
.p {
	width: 400px;
	-webkit-line-clamp: 2;
	display: -webkit-box;
	-webkit-box-orient: vertical;
	overflow: hiiden;
	text-overflow: ellipsis;
}
```

## 十一、生成固定宽高比的盒子

### 1.padding-top

在Chrome88之前不支持`aspect-ratio`的时候，主要的方案是使用`padding-top`或`padding-bottom`来生成固定宽高比的盒子。

此方案也被称为`Padding-Top Hack`。该解决方案需要一个**父容器**和一个**绝对放置的子容器**。然后，可以将宽高比计算为百分比以设置为`padding-top`：

- 1：1长宽比= 1/1 = 1 = `padding-top: 100%`
- 4：3长宽比= 3/4 = 0.75 = `padding-top: 75%`
- 3：2长宽比= 2/3 = 0.66666 = `padding-top: 66.67%`
- 16：9长宽比= 9/16 = 0.5625 = `padding-top: 56.25%`

```html
<div class="container">
	<img class="media" src=""/>
</div>
```

```css
.container {
	position: relative;
	width: 100%;
	padding-top: 100%;	// 1:1 aspect ratio
}

.media {
	position: absolute;
	top: 0;
    width: 100%;
    height: 100%;
    background: blue;
}
```

![image-20231219195301731](https://gitee.com/v876774538/my-img/raw/master/image-20231219195301731.png)

### 2.aspect-ratio

```css
body {
    margin: 0;
}

.container {
    position: relative;
    width: 100%;
    aspect-ratio: 1 / 1;
}

.media {
    position: absolute;
    top: 0;
    width: 100%;
    height: 100%;
    background: blue;
}
```

## 十二、块级元素、行内元素和行内块的区别

### 1.块级元素(block)

- 占据一行；

- 高度、行高以及内外边距都可以设置；

- 宽度默认为它容器的100%；

- 可以容纳内联元素和其他块元素。

  常见块级元素：`div`、`h1`、`p`

### 2.行内元素(inline)

- 和其他元素共享一行；

- 高、行高以及内外边距均不可改变；

- 宽度就是其文字或图片的宽度，由内容撑开，不可改变。

  常见行内元素：`i`、`span`、`a`

### 3.行内块元素(inline-block)

- 和其他元素共享一行

- 行高以及内外边距都可以改变。

  常见行内块元素：`button`、`img`、`input`

## 十三、link和import的区别

```css
<style>
	/*每个页面公共css */
	@import url("./common/common.less");

	...
</style>
```

```html
<link rel="shortcut icon" href="https://img.alicdn.com/tps/i4/TB1_oz6GVXXXXaFXpXXJDFnIXXX-64-64.ico" type="image/x-icon"/>
<link rel="stylesheet" href="https://g.alicdn.com/thx/cube/1.3.2/cube.min.css">
<link rel="stylesheet" href="demo.css">
<link rel="stylesheet" href="iconfont.css">
```

### 1.从属关系区别

- `@import`是CSS提供的语法规则，只有导入样式表的作用；
- `link`是HTML提供的标签，不仅可以加载CSS文件，还可以定义RSS、rel连接属性等。

### 2.加载顺序区别

- 加载页面时，`link`标签引入的CSS被同时加载；
- `@import`引入的CSS将在**页面加载完毕后被加载**。

### 3.兼容性区别

- `@import`是CSS2.1才有的语法，故只可在IE5+被识别；
- `link`标签作为HTML元素，不存在兼容性问题。

### 4.DOM可控性区别

- 可以通过JS操作DOM，插入`link标签`来改变样式；
- 由于DOM方法是基于文档的，无法使用`@import`的方式插入样式。



# js

## 一、引用类型和基本类型的区别

### 1.总结

在js中把我们的数据进行了分类，可以理解为两大类：

- **基本数据类型**：`string`、`number`、`null`、`Boolean`、`undefind`、`symbol`
- **应用数据类型**：`Object`、`Array`、`Function`

> 区别：**基本数据类型保存在栈里**，可以**直接访问**它的值；而**引用数据类型保存在堆中**，栈里保存的是访问它们的**地址**，访问时通过地址访问堆中的值。

### 2.如何判断数据类型

- `typeof`：判断的粒度较粗，它能准确判断基础类型（不包括`null`）以及`Object`和`Function`，转而言之，它不能判断`null`和`Array`，会将它们都判断为`Object`。

- `instanceof`：用来判断对象的更具体的类型。instanceof的模拟实现，它的主要原理是沿着对象的原型链的方向，判断原型对象是否是构造器的prototype。

- `Array.isArray`：专门用来判断**是否为数组**。

- `Function.prototype.toString.call`：最全面的方法，代码运行如下

  ```js
  // 以数组为例
  Function.prototype.toString.call([])	// [object Array]
  ```

  返回结果是一个**字符串**

  ```js
  Object.prototype.toString.call([]).slice(8, -1).toLowerCase()	// 可以得到具体的类型，代码中的-1表示倒数第一个元素
  ```

  ```js
  var arr = ['1', '2']
  var obj = {name: '张三'}
  console.log('判断arr', Object.prototype.toString.call(arr).slice(8, -1).toLowerCase())	// array
  console.log('判断obj', Object.prototype.toString.call(obj).slice(8, -1).toLowerCase())	object
  ```

### 3.基本类型

#### 3.1 Number

数值最常见的整数类型为十进制，还可以设置八进制（0开头）、十六进制（0x开头）

```js
let intNum = 55
let octNum = 070
let hexNum = 0xa
```

浮点类型在数值中必须包含小数点

```js
let floatNum1 = 1.1
let floatNum2 = 0.1
let floatNum3 = .1
let floatNum4 = 3.125e7
console.log(floatNum1, floatNum2, floatNum3, floatNum4)	// 1.1 0.1 0.1 31250000
```

在数值类型中，存在一个特殊数字`NaN`，意为不是数值。用于**表示本来要返回数值的操作失败**了。

```js
console.log(0 / 0)	// NaN
console.log(-0 / +0)	// NaN
```

#### 3.2 String

字符串可以使用双引号`""`、单引号`''`或反引号`表示。

```js
let firstName = 'John'
let lastName = 'Jacob'
let lastName = `Jingleheimerschmidt`
```

字符串一旦创建，它们的值**是不可变的**。

```js
let lang = 'Java'
lang = lang + 'Script' // 先销毁再创建
```

#### 3.3 Boolean

布尔型`Boolean`有两个字面值：true/false。

通过`Boolean`可以将其他类型的数据转换成布尔值：

| 数据类型  | true                  | false        |
| --------- | --------------------- | ------------ |
| String    | 非空字符串            | 空字符串`''` |
| Number    | 非0数值（包括无穷值） | `0`、`NaN`   |
| Object    | 任意对象              | `null`       |
| Undefined | /                     | `undefined`  |

#### 3.4 Undefined

`Undefined`类型只有一个特殊值`undefined`。

当使用`var`或`let`**声明了变量但没有初始化**时，就相当于给变量赋予了`undefined`值。

```js
let message
console.log(message)	// undefined

console.log(age) // 没有声明过这个变量，报错
```

#### 3.5 Null

`Null`类型同样只有一个特殊值`null`。

`null`代表空对象指针，给`typeof`传一个`null`会返回`object`。

```js
let car = null
console.log(typeof car)	// object
```

`undefined`由`null`派生而来，因此：

```js
console.log(null == undefined)	// true
```

#### 3.6 Symbol

`Symbol`（符号）是原始值，且符号实例是唯一、不可变的。

符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。

```js
let genericSymbol = Symbol()
let otherGenericSymbol = Symbol()
console.log(genericSymbol == otherGenericSymbol)    // false

let fooSymbol = Symbol('foo')
let otherFooSymbol = Symbol('foo')
console.log(fooSymbol == otherFooSymbol)    // false
```

### 4.引用类型

#### 4.1 Object

创建`object`常用方式为对象**字面量表示法**，属性名可以是字符串或数值。

```js
let person = {
	name: 'Nicholas',
	age: 29,
	5: true,
}
```

#### 4.2 Array

js中的数组是一组有序的数据，但跟其他语言不同的是，数组中每个槽位**可以存储任意类型的数据**，数组大小也是动态的，会随着**数据添加**而**自动增长**。

```js
let colors = ['red', 2, {age: 20}]
colors.push(2)
console.log(colors)
```

![image-20231222135450705](https://gitee.com/v876774538/my-img/raw/master/image-20231222135450705.png)

#### 4.3 Function

`function`（函数）实际上是对象，每个函数都是`function`类型的实例，而`function`也有属性和方法，跟其他引用类型一样。

函数三种常见的表达方式：

1. 函数声明

   ```js
   function sum(num1, num2) {
   	return num1 + num2
   }
   ```

2. 函数表达式

   ```js
   let sum = function(num1, num2) {
   	return num1 + num2
   }
   ```

3. 箭头函数

   ```js
   let sum = (num1, num2) => {
   	return num1 + num2
   }
   ```

#### 4.4 其他引用类型

除上述三种引用类型外，还包括`Date`、`RegExp`、`Map`、`Set`等……

### 5.存储区别

#### 5.1 基本数据类型

基本数据类型存储在**栈**中，可以直接访问它的值。

```js
let a = 10;
let b = a;	// 赋值
b = 20;
console.log(a)	// 10
```

![img](https://static.vue-js.com/906ffb90-6463-11eb-85f6-6fac77c0c9b3.png)

#### 5.2 引用数据类型

引用数据类型存放在**堆**中，栈中存放它们的**引用地址**。

```js
var obj1 = {}
var obj2 = obj1	// 将obj2的地址指向obj1的堆
obj2.name = 'xxx'
console.log(obj1.name)	// xxx
```

![img](https://static.vue-js.com/a34bdd10-6463-11eb-ab90-d9ae814b240d.png)

## 二、==和===的区别

### 1.总结

- `=`：赋值操作
- `==`：判断二者的值是否相等，相等返回true，反之返回false
- `===`：判断二者是否**全等**（值和类型都相等），相等返回true，反之返回false

### 2.==

js中存在**隐式转换**，操作符`==`在比较中会**先进行类型转换**，再确定操作数是否相等。

```js
let result = true == 1	// true
```



### 3.
